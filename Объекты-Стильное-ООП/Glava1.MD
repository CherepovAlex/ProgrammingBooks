## Глава 1. Программирование объектов: введение

Прежде чем приступить к изучению стилей проектирования, давайте обсудим некоторые фундаментальные вопросы программирования с применением объектов. Мы кратко пройдемся по самым важным понятиям и поясним распространенную терминологию, с которой продолжим знакомиться и в последующих главах.

Мы.рассмотрим:
+ _Классы и объекты_ — создание объектов на основе классов, использование конструктора, статические и объектные методы, статические методы фабрик для создания новых экземпляров и выдача исключений в конструкторе (раздел.1.1).
+ _Состояние_ — объявление свойств `private` и `public`, задание им значений, константы, а также изменяемые и неизменяемые состояния (раздел.1.2).
+ _Поведение_ — `private-` и `public`-методы, передача значений в качестве аргументов и исключения `NullPointerException`(раздел.1.3).
+ _Зависимости_ — их инициализация, обнаружение и передача в конструктор в качестве аргумента (раздел.1.4).
+ _Наследование_ — интерфейсы, абстрактные классы, переопределение и финальные классы (раздел.1.5).
+ _Полиморфизм_ — один интерфейс, разное поведение (раздел.1.6).
+ _Композиция_ — присвоение объектов свойствам и создание более сложных объектов (раздел.1.7).
+ _Организация классов_ (раздел.1.8).
+ _Оператор возврата и исключения_ — возвращение значения из метода, исключения в методе, обработка исключений, объявление собственных классов исключений (раздел.1.9).
+ _Модульное тестирование_ — паттерн Arrange-Act-Assert, тестирование на сбои и использование дублеров тестов для замещения зависимостей (раздел.1.10).
+ _Динамические массивы_ — их использование для создания списков или маппингов (раздел.1.11).

Если вы знакомы с этими темами, можете смело пропускать эту главу и переходить к главе 2. Если только некоторые темы представляют для вас интерес, просмотрите соответствующие разделы. Если же вы начинающий объектно-ориентированный программист, я рекомендую прочесть главу целиком.

## 1.1. КЛАССЫ И ОБЪЕКТЫ
Поведение объекта в среде исполнения задается объявлением класса. На основе класса можно создавать любое количество объектов. В следующем листинге показан простой класс, у которого нет состояния или поведения, но который можно инстанцировать.

### Листинг 1.1. Минимально жизнеспособный класс

```java
class Foo
{
    // Здесь ничего нет
}
object1 = new Foo();
object2 = new Foo();
object1 == object2 // false // Два экземпляра одного класса нельзя считать равными
```

После того как вы создадите экземпляр, можно будет вызывать его методы.

### Листинг 1.2. Вызов метода экземпляра

```java
class Foo
{
    public function someMethod()    //: void
    {
        // Что-нибудь сделать 
    }
}
object1 = new Foo();
object1.someMethod();
```

Обычный метод, такой как `someMethod()`, можно вызвать только на _экземпляре класса_. Такой метод называется _объектным методом_. Можно также задать методы, вызываемые без наличия экземпляра. Они называются _статическими методами_.

### Листинг 1.3. Объявление статического метода

```java
class Foo
{
    public function anObjectMethod()    //: void
    {
        // ...
    }
    public static function aStaticMethod()  //: void
    {
        // ...
    }
}
object1 = new Foo();
object1.anObjectMethod(); // anObjectMethod() можно вызвать только на экземпляре SomeClass
Foo.aStaticMethod();      //  aStaticMethod() можно вызвать без экземпляра
```

Кроме объектных и статических методов, класс может иметь специальный метод—_конструктор_. Этот метод вызывается до того, как объекту присваивается ссылка. Если необходимо подготовить объект к использованию, это можно сделать в конструкторе.

### Листинг 1.4. Объявление метода-конструктора

```java
class Foo
{
    public function __construct()
    {
        // Подготовить объект
    }
}
object1 = new Foo();    // __construct будет явно вызван перед тем, как object1 будет присвоен экземпляр Foo
```

Можно помешать созданию объекта, вызвав _исключения_ в конструкторе, как показано в листинге ниже. Подробнее об исключениях см. в разделе 1.9.

### Листинг 1.5. Обработка исключения в конструкторе

```java
class Foo
{
    public function __construct()
    {
        throw new RuntimeException(); // Инстанцировать Foo невозможно, так как его конструктор всегда будет выдавать исключение
    }
}
try {
    object1 = new Foo();
} catch (RuntimeException exception) {
    // `object1` будет неопределен
}
```
Стандартный способ инстанцирования объекта класса — использование оператора `new`, как вы уже, наверно, заметили. Также можно задать статичный _фабричный метод_ класса, который будет возвращать новый экземпляр этого класса.

### Листинг 1.6. Объявление статичного фабричного метода

```java
class Foo
{
    public static function create() //: Foo
    {
        return new Foo();
    }
}
object1 = Foo.create();
object2 = Foo.create();
```

Метод `create()` нужно объявлять статичным, так как он вызывается на классе, а не на экземпляре класса.

[оглавление Главы 1](#глава-1-программирование-объектов-введение)

## 1.2. СОСТОЯНИЕ

Объект может хранить данные. Эти данные могут содержаться в _свойствах_. Свойства будут иметь _имя_ и _тип_; им можно присвоить значения в любой момент после создания объекта. Обычно свойства задаются в конструкторе.

### Листинг 1.7. Объявление свойств и присвоение им значений

```java
class Foo
{
    private int someNumber;
    private string someString;
    
    public function __construct()
    {
        this.someNumber = 10;
        this.someString = 'Hello, world!';
    }
}
object1 = Foo.create(); // После инициализации свойствам someNumber и someString будут присвоены значения 10 и Hello, world! соответственно
```

Данные, содержащиеся в объектах, также называют _состоянием объекта_. Если эти данные необходимо жестко закрепить, как в предыдущем листинге, лучше присвоить значение изначально или объявить для него константу.

### Листинг 1.8. Объявление констант

```java
class Foo
{
    private const int someNumber = 10; // В языке программирования может быть другой синтаксис. Например, в Java вы увидите final
    private someString = 'Hello, world!';
}
```

С другой стороны, если значение свойства должно быть переменным, можно позволить клиенту передавать значение для аргумента конструктора. Добавляя параметр в конструктор, вы вынуждаете клиентов предоставлять значение при создании экземпляра класса.

### Листинг 1.9. Добавление аргумента в конструктор

```java
class Foo
{
    private int someNumber;
    public function __construct(int initialNumber)
    {
        this.someNumber = initialNumber; // Невозможно создать экземпляр Foo без предоставления значения для аргумента initialNumber
    }
}
object1 = new Foo(); // не работает
object2 = new Foo(20);  // Должно сработать, здесь новому экземпляру класса Foo присваивается начальное значение 20
```

Если присвоить свойствам `someNumber` и `someString `модификатор `private`, они станут доступными только внутри экземпляров класса `Foo`. Это называется инкапсуляцией. Существуют и другие модификаторы для свойств: `protected` (см. раздел 1.5) и `public`. Присваивая свойству модификатор `public`, вы предоставляете любому клиенту доступ к нему.

### Листинг 1.10. Объявление свойства с модификатором public

```java
class Foo
{
    public const int someNumber;
    public string someString;
    // ...
}
object1 = new Foo();
number = object1.someNumber; // Так как свойство someNumber задано как константа, его значение менять нельзя, но хотя бы можно получить
object2.someString = 'Cliche'; // someString не константа, но это свойство задано c модификатором public, поэтому здесь можно менять его значение
```

**МОДИФИКАТОРОМ ПО УМОЛЧАНИЮ ДЛЯ СВОЙСТВ ДОЛЖЕН БЫТЬ PRIVATE** 

В общем случае предпочтительно использовать модификатор `private`. Ограничение доступа к данным объекта помогает скрывать детали его реализации. Так можно гарантировать, что клиентам не придется полагаться на специфичные данные объекта и они будут общаться с объектом через объявленные публичные методы (подробнее о методах см. в разделе 1.3). Мы разберем эту тему подробнее в следующих главах, например в разделах 6.3 и 9.8.

Инкапсуляция свойств (а также методов, см. раздел 1.3) основана на классах. Это означает, что если свойство имеет модификатор `private`, то к этому свойству имеют доступ все экземпляры класса, включая тот экземпляр, которому оно присвоено.

### Листинг 1.11. Обращение к свойству `private` другого экземпляра

```java
class Foo
{
    private int someNumber;
    // ...
    public function getSomeNumber() //: int
    {
        return this.someNumber; // Foo, конечно же, имеет доступ к собственному свойству someNumber
    }
    public function getSomeNumberFrom(Foo other)    //: int
    {
        return other.someNumber;    // Foo также имеет доступ к свойству someNumber других экземпляров Foo
    }
}
object1 = new Foo();
object2 = new Foo();
object2.getSomeNumberFrom(object1); // Здесь вернется значение свойства someNumber
```

Объект называется _изменяемым_, когда значение свойства объекта может меняться в течение всего времени существования объекта. Если свойства объекта не могут меняться после инициализации, то объект считается _неизменяемым_. Листинг ниже иллюстрирует оба случая.

### Листинг 1.12. Изменяемые и неизменяемые объекты

```java
class Mutable
{
    private int someNumber;
    public function __construct(int initialNumber)
    {
        this.someNumber = initialNumber;
    }
    public function increase()  //: void
    {
        this.someNumber = this.someNumber + 1;
    }
}
class Immutable
{
    private int someNumber;
    public function __construct(int initialNumber)
    {
        this.someNumber = initialNumber;
    }
    public function increase()  //: Immutable
    {
        return new Immutable(someNumber + 1);
    }
}
object1 = new Mutable(10);
object1.increase(); // Вызов increase() у Mutable изменит состояние объекта, модифицируя значение свойства someNumber

object2 = new Immutable(10);
object2 = object2.increase(); // Вызов increase() у immutable не изменит состояния object2. Вместо этого мы получим новый экземпляр с увеличенным значением someNumb
```

В разделе 4.4 мы подробнее рассмотрим изменяемые объекты и узнаем, как делать их неизменяемыми.

[оглавление Главы 1](#глава-1-программирование-объектов-введение)

## 1.3. ПОВЕДЕНИЕ

Кроме состояния объект обладает поведением, которым клиенты могут пользоваться. Это поведение объекта задается методами класса. Методы с модификатором `public` доступны клиентам объекта. Их можно вызывать в любое время после создания самого объекта. Некоторые методы возвращают сущности тому, кто его вызывает. В таком случае в качестве возвращаемого типа будет объявлен тип сущности. Некоторые методы ничего не возвращают. В таком случае возвращаемым типом будет void.

### Листинг 1.13. Поведение объекта задается публичными методами

```java
class Foo
{
    public function someMethod(): int
    {
        return /* ... */;
    }
    public function someOtherMethod(): void
    {
        // ...
    }
}
object1 = new Foo();
value = object1.someMethod(); // someMethod() возвращает целое число, которое можно присвоить переменной
object1.someOtherMethod();    // someOtherMethod() не возвращает ничего конкретного, поэтому клиент не сможет ничего присвоить переменной
```

Класс также может содержать объявления методов с модификатором 'private'. Это работает так же, как и для приватных переменных. Любой экземпляр данного класса может вызывать приватные методы на любых других экземплярах одного и того же класса, включая себя самого. Тем не менее приватные методы часто используются для выполнения мелких шагов в большом процессе.

## Листинг 1.14. Приватные методы

```java
class Foo
{
    public function someMethod()    //: int
    {
        value = this.stepOne();
        return this.stepTwo(value);
    }
    private function stepOne()  //: int
    {
        // ...
    }
    private function stepTwo(int value) //: int
    {
        // ...
    }
}
```

**ПРОВЕРЯЙТЕ НАЛИЧИЕ АРГУМЕНТОВ СО ЗНАЧЕНИЕМ NULL**
В некоторых языках клиенты могут передавать значение `null` в качестве аргумента, даже если тип параметра был явно задан. Так что в примере листинга 1.15 аргумент для `bar` может оказаться `null`, даже если его тип явно указан — `Bar`. Попытка вызывать метод `doSomething()` на объекте `bar` приведет к выдаче исключения `NullPoinerException`. Поэтому всегда нужно проверять наличие аргументов со значением `null` либо обращать внимание на предупреждения компилятора или статического анализатора о потенциальных исключениях `NullPointerException`.

Вымышленный язык программирования, используемый в этой книге, не позволяет передавать `null` в качестве аргумента. Если мы хотим разрешить передачу `null`, это необходимо задать явно при помощи вопросительного знака (?) после объявления параметра метода. Таким же образом это работает и для типов свойств и возвращаемых типов:

```java
class Foo {
    private string? foo;

    private function someOtherMethod(Bar? bar): Baz?

    {
        // ...
    }
}
```    

Так же как параметры конструкторов, можно задавать параметры методам. Клиенту придется предоставить специфичное значение в качестве аргумента при вызове метода. Сам метод может использовать значение для дальнейших действий: передать его вспомогательным объектам или использовать его для изменения значения свойства.

### Листинг 1.15. Несколько способов применения аргументов метода

```java
class Foo
{
    private int number;
    public function setNumber(int newNumber)    //: void Здесь аргумент newNumber станет новым значением свойства number
    {
        this.number = newNumber;
    }
    private function multiply(int other)    //: int В этом случае аргумент other будет умножаться на текущее значение свойства number
    {
        return this.number * other;
    }
private function someOtherMethod(Bar bar)   //: void Здесь в качестве аргумента передается другой объект, и Foo даже может вызвать его метод
    {
        bar.doSomething();
    }
}
```

## 1.4. ЗАВИСИМОСТИ



[оглавление Главы 1](#глава-1-программирование-объектов-введение)

[1.1. КЛАССЫ И ОБЪЕКТЫ](#11-классы-и-объекты)

[1.2. СОСТОЯНИЕ](#12-состояние)

[1.3. ПОВЕДЕНИЕ](#13-поведение)

[1.4. ЗАВИСИМОСТИ](#14-зависимости)