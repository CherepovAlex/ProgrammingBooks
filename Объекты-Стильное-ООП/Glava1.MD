## Глава 1. Программирование объектов: введение

Прежде чем приступить к изучению стилей проектирования, давайте обсудим некоторые фундаментальные вопросы программирования с применением объектов. Мы кратко пройдемся по самым важным понятиям и поясним распространенную терминологию, с которой продолжим знакомиться и в последующих главах.

Мы.рассмотрим:
+ _Классы и объекты_ — создание объектов на основе классов, использование конструктора, статические и объектные методы, статические методы фабрик для создания новых экземпляров и выдача исключений в конструкторе (раздел.1.1).
+ _Состояние_ — объявление свойств `private` и `public`, задание им значений, константы, а также изменяемые и неизменяемые состояния (раздел.1.2).
+ _Поведение_ — `private-` и `public`-методы, передача значений в качестве аргументов и исключения `NullPointerException`(раздел.1.3).
+ _Зависимости_ — их инициализация, обнаружение и передача в конструктор в качестве аргумента (раздел.1.4).
+ _Наследование_ — интерфейсы, абстрактные классы, переопределение и финальные классы (раздел.1.5).
+ _Полиморфизм_ — один интерфейс, разное поведение (раздел.1.6).
+ _Композиция_ — присвоение объектов свойствам и создание более сложных объектов (раздел.1.7).
+ _Организация классов_ (раздел.1.8).
+ _Оператор возврата и исключения_ — возвращение значения из метода, исключения в методе, обработка исключений, объявление собственных классов исключений (раздел.1.9).
+ _Модульное тестирование_ — паттерн Arrange-Act-Assert, тестирование на сбои и использование дублеров тестов для замещения зависимостей (раздел.1.10).
+ _Динамические массивы_ — их использование для создания списков или маппингов (раздел.1.11).

Если вы знакомы с этими темами, можете смело пропускать эту главу и переходить к главе 2. Если только некоторые темы представляют для вас интерес, просмотрите соответствующие разделы. Если же вы начинающий объектно-ориентированный программист, я рекомендую прочесть главу целиком.

## 1.1. КЛАССЫ И ОБЪЕКТЫ
Поведение объекта в среде исполнения задается объявлением класса. На основе класса можно создавать любое количество объектов. В следующем листинге показан простой класс, у которого нет состояния или поведения, но который можно инстанцировать.

### Листинг 1.1. Минимально жизнеспособный класс

```java
class Foo
{
    // Здесь ничего нет
}
object1 = new Foo();
object2 = new Foo();
object1 == object2 // false // Два экземпляра одного класса нельзя считать равными
```

После того как вы создадите экземпляр, можно будет вызывать его методы.

### Листинг 1.2. Вызов метода экземпляра

```java
class Foo
{
    public function someMethod()    //: void
    {
        // Что-нибудь сделать 
    }
}
object1 = new Foo();
object1.someMethod();
```

Обычный метод, такой как `someMethod()`, можно вызвать только на _экземпляре класса_. Такой метод называется _объектным методом_. Можно также задать методы, вызываемые без наличия экземпляра. Они называются _статическими методами_.

### Листинг 1.3. Объявление статического метода

```java
class Foo
{
    public function anObjectMethod()    //: void
    {
        // ...
    }
    public static function aStaticMethod()  //: void
    {
        // ...
    }
}
object1 = new Foo();
object1.anObjectMethod(); // anObjectMethod() можно вызвать только на экземпляре SomeClass
Foo.aStaticMethod();      //  aStaticMethod() можно вызвать без экземпляра
```

Кроме объектных и статических методов, класс может иметь специальный метод—_конструктор_. Этот метод вызывается до того, как объекту присваивается ссылка. Если необходимо подготовить объект к использованию, это можно сделать в конструкторе.

### Листинг 1.4. Объявление метода-конструктора

```java
class Foo
{
    public function __construct()
    {
        // Подготовить объект
    }
}
object1 = new Foo();    // __construct будет явно вызван перед тем, как object1 будет присвоен экземпляр Foo
```

Можно помешать созданию объекта, вызвав _исключения_ в конструкторе, как показано в листинге ниже. Подробнее об исключениях см. в разделе 1.9.

### Листинг 1.5. Обработка исключения в конструкторе

```java
class Foo
{
    public function __construct()
    {
        throw new RuntimeException(); // Инстанцировать Foo невозможно, так как его конструктор всегда будет выдавать исключение
    }
}
try {
    object1 = new Foo();
} catch (RuntimeException exception) {
    // `object1` будет неопределен
}
```
Стандартный способ инстанцирования объекта класса — использование оператора `new`, как вы уже, наверно, заметили. Также можно задать статичный _фабричный метод_ класса, который будет возвращать новый экземпляр этого класса.

### Листинг 1.6. Объявление статичного фабричного метода

```java
class Foo
{
    public static function create() //: Foo
    {
        return new Foo();
    }
}
object1 = Foo.create();
object2 = Foo.create();
```

Метод `create()` нужно объявлять статичным, так как он вызывается на классе, а не на экземпляре класса.

[оглавление Главы 1](#глава-1-программирование-объектов-введение)

## 1.2. СОСТОЯНИЕ

Объект может хранить данные. Эти данные могут содержаться в _свойствах_. Свойства будут иметь _имя_ и _тип_; им можно присвоить значения в любой момент после создания объекта. Обычно свойства задаются в конструкторе.

### Листинг 1.7. Объявление свойств и присвоение им значений

```java
class Foo
{
    private int someNumber;
    private string someString;
    
    public function __construct()
    {
        this.someNumber = 10;
        this.someString = 'Hello, world!';
    }
}
object1 = Foo.create(); // После инициализации свойствам someNumber и someString будут присвоены значения 10 и Hello, world! соответственно
```

Данные, содержащиеся в объектах, также называют _состоянием объекта_. Если эти данные необходимо жестко закрепить, как в предыдущем листинге, лучше присвоить значение изначально или объявить для него константу.

### Листинг 1.8. Объявление констант

```java
class Foo
{
    private const int someNumber = 10; // В языке программирования может быть другой синтаксис. Например, в Java вы увидите final
    private someString = 'Hello, world!';
}
```

С другой стороны, если значение свойства должно быть переменным, можно позволить клиенту передавать значение для аргумента конструктора. Добавляя параметр в конструктор, вы вынуждаете клиентов предоставлять значение при создании экземпляра класса.

### Листинг 1.9. Добавление аргумента в конструктор

```java
class Foo
{
    private int someNumber;
    public function __construct(int initialNumber)
    {
        this.someNumber = initialNumber; // Невозможно создать экземпляр Foo без предоставления значения для аргумента initialNumber
    }
}
object1 = new Foo(); // не работает
object2 = new Foo(20);  // Должно сработать, здесь новому экземпляру класса Foo присваивается начальное значение 20
```

Если присвоить свойствам `someNumber` и `someString `модификатор `private`, они станут доступными только внутри экземпляров класса `Foo`. Это называется инкапсуляцией. Существуют и другие модификаторы для свойств: `protected` (см. раздел 1.5) и `public`. Присваивая свойству модификатор `public`, вы предоставляете любому клиенту доступ к нему.

### Листинг 1.10. Объявление свойства с модификатором public

```java
class Foo
{
    public const int someNumber;
    public string someString;
    // ...
}
object1 = new Foo();
number = object1.someNumber; // Так как свойство someNumber задано как константа, его значение менять нельзя, но хотя бы можно получить
object2.someString = 'Cliche'; // someString не константа, но это свойство задано c модификатором public, поэтому здесь можно менять его значение
```

**МОДИФИКАТОРОМ ПО УМОЛЧАНИЮ ДЛЯ СВОЙСТВ ДОЛЖЕН БЫТЬ PRIVATE** 

В общем случае предпочтительно использовать модификатор `private`. Ограничение доступа к данным объекта помогает скрывать детали его реализации. Так можно гарантировать, что клиентам не придется полагаться на специфичные данные объекта и они будут общаться с объектом через объявленные публичные методы (подробнее о методах см. в разделе 1.3). Мы разберем эту тему подробнее в следующих главах, например в разделах 6.3 и 9.8.

Инкапсуляция свойств (а также методов, см. раздел 1.3) основана на классах. Это означает, что если свойство имеет модификатор `private`, то к этому свойству имеют доступ все экземпляры класса, включая тот экземпляр, которому оно присвоено.

### Листинг 1.11. Обращение к свойству `private` другого экземпляра

```java
class Foo
{
    private int someNumber;
    // ...
    public function getSomeNumber() //: int
    {
        return this.someNumber; // Foo, конечно же, имеет доступ к собственному свойству someNumber
    }
    public function getSomeNumberFrom(Foo other)    //: int
    {
        return other.someNumber;    // Foo также имеет доступ к свойству someNumber других экземпляров Foo
    }
}
object1 = new Foo();
object2 = new Foo();
object2.getSomeNumberFrom(object1); // Здесь вернется значение свойства someNumber
```

Объект называется _изменяемым_, когда значение свойства объекта может меняться в течение всего времени существования объекта. Если свойства объекта не могут меняться после инициализации, то объект считается _неизменяемым_. Листинг ниже иллюстрирует оба случая.

### Листинг 1.12. Изменяемые и неизменяемые объекты

```java
class Mutable
{
    private int someNumber;
    public function __construct(int initialNumber)
    {
        this.someNumber = initialNumber;
    }
    public function increase()  //: void
    {
        this.someNumber = this.someNumber + 1;
    }
}
class Immutable
{
    private int someNumber;
    public function __construct(int initialNumber)
    {
        this.someNumber = initialNumber;
    }
    public function increase()  //: Immutable
    {
        return new Immutable(someNumber + 1);
    }
}
object1 = new Mutable(10);
object1.increase(); // Вызов increase() у Mutable изменит состояние объекта, модифицируя значение свойства someNumber

object2 = new Immutable(10);
object2 = object2.increase(); // Вызов increase() у immutable не изменит состояния object2. Вместо этого мы получим новый экземпляр с увеличенным значением someNumb
```

В разделе 4.4 мы подробнее рассмотрим изменяемые объекты и узнаем, как делать их неизменяемыми.

[оглавление Главы 1](#глава-1-программирование-объектов-введение)

## 1.3. ПОВЕДЕНИЕ

Кроме состояния объект обладает поведением, которым клиенты могут пользоваться. Это поведение объекта задается методами класса. Методы с модификатором `public` доступны клиентам объекта. Их можно вызывать в любое время после создания самого объекта. Некоторые методы возвращают сущности тому, кто его вызывает. В таком случае в качестве возвращаемого типа будет объявлен тип сущности. Некоторые методы ничего не возвращают. В таком случае возвращаемым типом будет void.

### Листинг 1.13. Поведение объекта задается публичными методами

```java
class Foo
{
    public function someMethod(): int
    {
        return /* ... */;
    }
    public function someOtherMethod(): void
    {
        // ...
    }
}
object1 = new Foo();
value = object1.someMethod(); // someMethod() возвращает целое число, которое можно присвоить переменной
object1.someOtherMethod();    // someOtherMethod() не возвращает ничего конкретного, поэтому клиент не сможет ничего присвоить переменной
```

Класс также может содержать объявления методов с модификатором 'private'. Это работает так же, как и для приватных переменных. Любой экземпляр данного класса может вызывать приватные методы на любых других экземплярах одного и того же класса, включая себя самого. Тем не менее приватные методы часто используются для выполнения мелких шагов в большом процессе.

### Листинг 1.14. Приватные методы

```java
class Foo
{
    public function someMethod()    //: int
    {
        value = this.stepOne();
        return this.stepTwo(value);
    }
    private function stepOne()  //: int
    {
        // ...
    }
    private function stepTwo(int value) //: int
    {
        // ...
    }
}
```

**ПРОВЕРЯЙТЕ НАЛИЧИЕ АРГУМЕНТОВ СО ЗНАЧЕНИЕМ NULL**
В некоторых языках клиенты могут передавать значение `null` в качестве аргумента, даже если тип параметра был явно задан. Так что в примере листинга 1.15 аргумент для `bar` может оказаться `null`, даже если его тип явно указан — `Bar`. Попытка вызывать метод `doSomething()` на объекте `bar` приведет к выдаче исключения `NullPoinerException`. Поэтому всегда нужно проверять наличие аргументов со значением `null` либо обращать внимание на предупреждения компилятора или статического анализатора о потенциальных исключениях `NullPointerException`.

Вымышленный язык программирования, используемый в этой книге, не позволяет передавать `null` в качестве аргумента. Если мы хотим разрешить передачу `null`, это необходимо задать явно при помощи вопросительного знака (?) после объявления параметра метода. Таким же образом это работает и для типов свойств и возвращаемых типов:

```java
class Foo {
    private string? foo;

    private function someOtherMethod(Bar? bar): Baz?

    {
        // ...
    }
}
```    

Так же как параметры конструкторов, можно задавать параметры методам. Клиенту придется предоставить специфичное значение в качестве аргумента при вызове метода. Сам метод может использовать значение для дальнейших действий: передать его вспомогательным объектам или использовать его для изменения значения свойства.

### Листинг 1.15. Несколько способов применения аргументов метода

```java
class Foo
{
    private int number;
    public function setNumber(int newNumber)    //: void Здесь аргумент newNumber станет новым значением свойства number
    {
        this.number = newNumber;
    }
    private function multiply(int other)    //: int В этом случае аргумент other будет умножаться на текущее значение свойства number
    {
        return this.number * other;
    }
private function someOtherMethod(Bar bar)   //: void Здесь в качестве аргумента передается другой объект, и Foo даже может вызвать его метод
    {
        bar.doSomething();
    }
}
```

## 1.4. ЗАВИСИМОСТИ

Если объекту `Foo` нужен объект `Bar` для выполнения задачи, то `Bar` называют зависимостью `Foo`. Существуют три способа проверить, что у `Foo` есть доступ к зависимости `Bar`.

+ `Foo` может самостоятельно инициализировать `Bar`.
+ `Foo` может получить экземпляр `Bar` из известного источника.
+ `Foo` может получить экземпляр `Bar` во время вызова конструктора.

В листинге ниже проиллюстрирован каждый из этих трех вариантов.

### Листинг 1.16. Различные способы получения доступа Foo к экземпляру Logger

```java
class Foo {
    public function someMethod()    //: void
    {
        logger = new Logger();  // Foo инстанцирует Logger при необходимости
        logger.debug('...');
    }
}

class Foo {
    public function someMethod()    //: void
    {
        logger = ServiceLocator.getLogger(); //  Foo получает Logger из известного источника
        logger.debug('...');
    }
}

class Foo {
    private Logger logger;

    public function __construct(Logger logger) {
        this.logger = logger;   // Foo получает экземпляр Logger, предоставленный в качестве аргумента конструктора
    }

    public function someMethod() // : void
    {
        this.logger.debug('...');
    }
}
```

Как обращаться с зависимостями, мы рассмотрим подробнее в разделе 2.2. Сейчас же достаточно знать, что получение зависимостей из известного источника называется _локализацией сервисов_, а получение зависимостей в качестве аргументов конструктора — _внедрением зависимостей_.

[оглавление Главы 1](#глава-1-программирование-объектов-введение)

## 1.5. НАСЛЕДОВАНИЕ

Можно также задавать только часть класса и позволить другим классам его расширять. Например, у вас может быть класс без свойств и методов, только с сигнатурами методов. Такие классы обычно называют _интерфейсами_, и многие ООП-языки позволяют их таковыми объявлять. Класс затем использует интерфейс и предоставляет фактические реализации методов, определенных интерфейсом.

### Листинг 1.17. Реализации `Bar` и `Baz` интерфейса `Foo`

```java
interface Foo {
    public function foo()   //: void; // Интерфейс Foo объявляет метод foo(), но не предоставляет его реализацию
}

class Bar implements Foo    // Класс Bar неверно реализует интерфейс Foo, так как в нем нет реализации метода foo()
{
}

class Baz implements Foo    // Класс Baz правильно реализует интерфейс Foo, так как в нем представлена реализация метода foo()
{
    public foo():
    void {
        // ...
    }
}

```

В интерфейсах нельзя задать конкретную реализацию, но она может задаваться в _абстрактных классах_. Они позволяют предоставлять реализацию методов и сигнатуры методов. Абстрактный класс нельзя инстанцировать, но его можно расширить в другом классе, в котором будут реализовываться абстрактные методы.

### Листинг 1.18. `Baz` расширяет абстрактный класс `Foo`

```java
abstract class Foo
{
    abstract public function foo()  // : void; Метод foo() абстрактный и должен быть реализован расширяющим классом
    
    public function bar()   //: void Класс Foo задает реализацию методу bar() 
    {
        // ...
    }
}
class Baz extends Foo //    Baz — корректная реализация класса Foo, так как в нем представлена реализация ранее объявленного метода foo()
{
    public function foo()   //: void
    {
    }
}
```

И наконец, в классе могут быть заданы реализации всех его методов, а другие классы могут их расширять и переопределять.

### Листинг 1.19. Класс `Bar` расширяет класс `Foo` и частично меняет его поведение

```java
class Foo    // Foo — обычный класс, без абстрактных методов
{
    public function bar()   //: void
    {
        // сделать что-то
    }
}
class Bar extends Foo   // Bar расширяет Foo, который теперь является родительским классом. Bar может менять поведение его метода bar()
{
    public function bar()   //: void    // Foo — обычный класс, без абстрактных методов
    {
        // сделать что-то еще
    }
}

```

Классы, которые расширяют другие классы, получают доступ к родительским методам с модификаторами доступа `public` и `protected`.

### Листинг 1.20. Доступ к методам с модификаторами доступа `public` и `protected`

```java
class Foo
{
    public function foo()   //: void
    {
        // сделать что-то
    }
    protected function bar()    //: void
    {
    }
    private function baz()  //: void
    {
    }
}
class Bar extends Foo
{
    public function someMethod()    //: void
    {
        $this->foo(); //    foo() доступен, так как это метод с модификатором public
        $this->bar(); //    bar() доступен, так как это метод с модификатором protected
        //$this->baz();   //  baz() недоступен, так как это приватный метод
    }
}

```

Подклассы могут также переопределять родительские методы с модификаторами `public` и `protected`.

### Листинг 1.21. Переопределение методов с модификаторами public и protected

```java
class Foo
{
    public function foo()   // : void
    {
        // сделать что-то
    }
    protected function bar()    //: void
    {
    }
    private function baz()  //: void
    {
    }
}
class Bar extends Foo {
    public function foo()   //: void Метод foo() можно переопределить, так как это метод с модификатором public
    {
        // ...
    }

    protected function bar()    //: void Метод bar() можно переопределить, так как это метод c модификатором protected
    {
        // ...
    }

    private function baz()  //: void Метод baz() нельзя переопределять, так как это приватный метод
    {
        // не работает
    }
}    
```

В этой книге наследованию уделено не очень много внимания, несмотря на то что это крайне важный аспект ООП. На практике наследование зачастую приводит к усложнению дизайна. В книге мы в основном будем использовать наследование в двух случаях:

+ при объявлении интерфейсов для зависимостей;
+ при объявлении иерархии объектов, как, например, при объявлении кастомных исключений, которые расширяют встроенные классы исключений.

В большинстве случаев старайтесь не допускать расширений из классов. Для этого используйте ключевое слово `final` перед названием класса. Подробнее см. в разделе 9.7.

### Листинг 1.22. Класс `Bar` нельзя расширить

```java
final class Bar
{
    // ...
}
class Baz extends Bar // не работает    // Bar обозначен ключевым словом final, поэтому его запрещено расширять
{
    // ...
}
```

[оглавление Главы 1](#глава-1-программирование-объектов-введение)

## 1.6. ПОЛИМОРФИЗМ

Полиморфизм — это одна из основополагающих концепций ООП. Полиморфизм означает, что если для параметра задан определенный класс в качестве типа, то любой объект, являющийся экземпляром этого класса, можно передавать в качестве допустимого аргумента. Например, в следующем листинге любой экземпляр Foo можно передать в качестве аргумента методу `bar()`:

### Листинг 1.23. Любой экземпляр Foo будет допустим для метода bar()

```java
class Foo
{
    // ...
}
final class Bar
{
    public function bar(Foo foo)    // : void
    {
        foo.someMethod();
    }
}

```

Так как экземпляры `Foo` могут иметь различную конфигурацию или внутреннее состояние, то теоретически каждый из них может вести себя по-своему. Это значит, что можно влиять на поведение `bar()`, не изменяя сам метод `bar()`.

Еще больше влияния на поведение классов можно оказывать при помощи подклассов. Мы уже рассмотрели наследование и то, как использовать его для изменения поведения, унаследованного родительским классом, при помощи (частичного) переопределения в расширяющем классе. Любой объект, являющийся экземпляром расширения класса `Foo`, также будет считаться экземпляром класса `Foo`. Это также автоматически делает любой экземпляр расширения класса `Foo` допустимым аргументом для параметров типа `Foo`.

Как вы узнаете в главе 9, применять подклассы для изменения поведения объектов обычно не рекомендуется. В большинстве ситуаций лучше использовать полиморфизм в типе параметра интерфейса. В обоих вариантах код будет выглядеть одинаково (см. листинг 1.24), но во втором случае `Foo` представляет собой интерфейс.

### Листинг 1.24. Любой экземпляр Foo будет приемлем для метода bar()

```java
interface Foo    // Теперь Foo — интерфейс
{
    // ...
}
final class Bar
{
    public function bar(Foo foo)    //: void
    {
        foo.someMethod();
    }
}

```

[оглавление Главы 1](#глава-1-программирование-объектов-введение)

## 1.7. КОМПОЗИЦИЯ

Кроме демонстрации полиморфизма в листинге 1.25 показано, как использовать экземпляр `Foo` для работы в другом объекте.`(Bar)`. Если `Foo` — это сервис, то его можно предоставлять объекту класса `Bar` в качестве аргумента конструктора. `Bar` затем может назначить объект класса `Foo` своим свойством.

### Листинг 1.25. Предоставленный экземпляр `Foo` передается в качестве свойства объекта `Bar`

```java
final class Bar
{
    private Foo foo;
    public function __construct(Foo foo)
    {
        this.foo = foo;
    }
}
```

Передача объекта другому объекту в качестве свойства называется _композицией объектов_. При этом возникает более сложный объект, состоящий из множества простых. Композицию можно использовать вместе с полиморфизмом для создания объектов, содержащих другие объекты с известными типами (интерфейсов) без указания конкретных классов.

Композицию можно использовать для объектов-сервисов, внедряя возможность частичного конфигурирования их поведения, а также применять вместе с другими типами объектов, например с сущностями (их иногда называют _моделями_), для работы со связанными внутренними элементами. Например, в объекте `Order`, который содержит объекты `Line`, композиция позволяет устанавливать связь между заказами и элементами заказа. В этом случае клиенту может понадобиться предоставить не один объект `Line`, а целый ряд (массив)объектов Line.

### Листинг 1.26. Свойству объекта Order присваивается множество объектов Line

```java
final class Order
{
    private array lines;
    public function __construct(array lines)
    {
        this.lines = lines;    // Каждый элемент в lines — это объект Line
    }
}

```

[оглавление Главы 1](#глава-1-программирование-объектов-введение)

## 1.8. ОРГАНИЗАЦИЯ КЛАССОВ

В языках программирования обычно существует несколько возможностей для организации классов: директории, пространства имен, компоненты, модули, пакеты и т. п. В некоторых языках даже допускается хранить приватные классы в модулях или пакетах. Так же как область видимости переменных и методов, это помогает ограничить степень связанности модулей. Эта книга не содержит конкретных правил организации классов в большие группы — она описывает правила проектирования самих классов. Если вам интересны принципы организации классов на уровне компонентов, советую прочесть другую мою книгу, Principles of Package Design (Apress, 2018).

[оглавление Главы 1](#глава-1-программирование-объектов-введение)

## 1.9. ОПЕРАТОР ВОЗВРАТА И ИСКЛЮЧЕНИЯ

Когда вы вызываете методы, они обычно выполняются последовательно сверху вниз, пока не достигнут оператора возврата `return` или конца метода. Если вы хотите прервать выполнение метода, поместите в месте прерывания оператор `return`, который гарантирует, что оставшиеся выражения метода не будут выполняться.

### Листинг 1.27. Оператор return предотвращает дальнейшее выполнение метод

```java
final class Foo
{
    public function someMethod()    // : void
    {
        if (/* прервать здесь? */) {
            return;     // Метод с возвращаемым типом void не возвращает ничего
        }
        
        // ...
    }
    public function someOtherMethod()   // : bool
    {
        if (/* прервать здесь? */) {
            return false;   // Метод с указанным возвращаемым типом возвращает конкретные значения
        }
        // ...
        return true;
    }
}
```

Еще один способ прервать выполнение метода — _вызов исключения_. Исключение — это особый тип объекта, который при инстанцировании собирает информацию о том, где он был инстанцирован и что этому предшествовало (так называемое отслеживание стека). Обычно исключение свидетельствует о сбое в программе, например:
+ о.предоставлении.неверных.аргументов;
+ отсутствии.значения.в.массиве.для.данного.ключа;
+ недоступности.некоторых.внешних.сервисов.

В листинге ниже показано, как вызвать исключение.

### Листинг 1.28.  Выдача исключения также предотвращает дальнейшее выполнение метода

```java
final class Foo
{
    public function someMethod()    // : void
    {
        if (/* прервать здесь? */) {
            throw new RuntimeException(
                'Что-то пошло не так'  //   Можно прописать сообщение для исключения
            );
        }
        // ...
    }
}
```

Как только становится понятно, что метод не сможет выполнять задачу корректно, в нем нужно объявить выдачу исключения. В отличие от простого оператора `return`, при выдаче исключения метод не возвращает значений. Выполнение прекращается и может быть продолжено только клиентом, у которого вызов метода был объявлен внутри блока `try/catch`. Ниже в листинге показано, как это работает.

### Листинг 1.29. Клиент может восстановить выполнение метода после выдачи исключения, если будет использовать блок try/catch

```java
foo = new Foo();
try {
    foo.someMethod();
} catch (Exception) {
    // ...              // Если someMethod() выдаст исключение, catch() его поймает и выполнение остальных операций продолжится
}

```

В разных языках программирования предусматриваются свои классы исключений. Они образуют некоторую иерархию — например, `RuntimeException` расширяет `Exception`, `InvalidArgumentException` расширяет `LogicException`. Также можно объявить собственные классы исключений. Но они всегда должны расширять один из встроенных классов исключений. Пример — в листинге 1.30.

### Листинг 1.30. Объявление собственного исключения

```java
final class CanNotFindFoo extends RuntimeException
{
    // ... 1((CO25-1))
}
final class Foo
{
    public function someMethod()    // : void
    {
        if (/* прервать здесь?  */) {
            throw new CanNotFindFoo();
        }
        // ...
    }
}

```

Исключения — важный аспект проектирования объектов. Они входят в набор типов поведения, которое клиент может ожидать от объекта. Подробнее об исключениях мы поговорим позже, в разделе 5.2.

[оглавление Главы 1](#глава-1-программирование-объектов-введение)

## 1.10. МОДУЛЬНОЕ ТЕСТИРОВАНИЕ

Недостаточно просто объявить объекты посредством написания классов. 
Объекты служат определенной цели: они будут использоваться для выполнения конкретной задачи или для предоставления ответа на конкретный вопрос. 
Для надежности объект нужно наделить поведением, которого ожидает клиент. 
Бесспорно, можно написать код, скомпилировать его и запустить приложение, а затем узнать, получен ли ожидаемый результат. 
Но более грамотный подход — написать скрипт, который инстанцирует объект, вызывает его метод и затем сравнивает результат с ожидаемым. 

Фреймворки модульного тестирования поддерживают такой подход со скриптами. 
Фреймворк будет искать классы специфичного типа, называемые тестовыми классами. 
Затем он инстанцирует каждый класс и вызывает каждый метод, который обозначен как тестовый (методы с аннотацией `@test`). 

Базовая структура каждого метода выстроена по паттерну `Arrange-Act-Assert`:
+ **Arrange** (подготовка) — приведение тестируемого объекта (также называемого `SUT`, `subject.under.test`) в определенное известное состояние;
+ **Act** (действие) — вызов одного из его методов;
+ **Assert** (проверка) — оценка конечного состояния.

В листинге 1.31 показан простой класс с сопутствующими модульными тестами. 

### Листинг 1.31. Простой класс с несколькими модульными тестами

```java
final class Foo
{
    private int someNumber;
    public function __construct(int startWith)
    {
        this.someNumber = startWith;
    }
    public function increment() // : void
    {
        this.someNumber++;
    }
    public function someNumber()    //: int
    {
        return this.someNumber;
    }
}
final class FooTest
{
    /**
     * @test
     */
    public function you_can_start_with_a_given_number() // : void
    {
        // Arrange
        foo = new Foo(10);
        // Act          // Здесь не выполняется действие, это проверка состояния объекта
        // Assert
        assertEquals(10, foo.someNumber());
    }
    /**
     * @test
     */
    public function you_can_increment_the_number()  // : void
    {
        // Arrange
        foo = new Foo(10);
        // Act
        foo.increment();    // Вызываем метод increment(), что является действием. После этого проверяем, находится ли объект в ожидаемом состоянии
        // Assert
        assertEquals(11, foo.someNumber());
    }
}
```

Если во втором тесте значение, возвращаемое методом `someNumber()`, а именно `11`, равно ожидаемому, то все в порядке.  
Поток выполнения будет продолжаться под контролем тестового фреймворка. 
Если же `someNumber()` будет не полностью реализован или реализован с ошибками, то результатом вызова метода `assertEquals()` станет исключение. 
Если, например, `someNumber()` вернет значение 20, то тестовый фреймворк зафиксирует этот тест как проваленный. 
Когда вы исправите проблему и снова запустите тест, то он будет пройден. 

`assertEquals()` и похожие проверки, такие как `assertTrue()`, `assertNull()` и т.п., обычно уже содержатся в тестовом фреймворке. 
Их можно использовать для оценки возвращаемых значений вызванных методов. 
Еще может пригодиться проверка случаев, когда метод должен выдавать контролируемую ошибку.
Например, если вы хотите наложить ограничение на число, предоставляемое конструктору `Foo` в качестве аргумента (например, оно должно быть больше или равно 0), то следует проверить, что предоставление `Foo` отрицательного числа приведет к выдаче исключения.  
В.листинге.1.32.показано,.как.это.сделать.

### Листинг 1.32. Тестирование на ошибки
```java
final class Foo
{
    private int someNumber;
    public function __construct(int startWith)
    {
        if (startWith < 0) {
            throw new InvalidArgumentException(
                'Первое число не должно быть отрицательным'
            );
        }
        this.someNumber = startWith;
    }
    // ...
}
final class FooTest
{
    /**
     * @test
     */
    public function you_cannot_start_with_a_negative_number()   // : void
    {
        try {
            new Foo(-10);
            throw new RuntimeException( // Если в результате инстанцирования Foo с отрицательным числом не выдается исключение, необходимо считать тест проваленным
                'Конструктор должен завершиться ошибкой'
            );
        } catch (Exception exception) {
            if (exception.className != InvalidArgumentException.className) {
                throw new RuntimeException( // Если выданный класс исключения не совпадает с ожидаемым, необходимо считать тест проваленным
                    'Ожидается другой тип исключения'
                );
            }
            assertContains('negative', exception.getMessage()); // Наконец, проверяем, что сообщение исключения содержит ожидаемое ключевое слово
        }
    }
    // ...
}
```

Это стандартный код на каждый сценарий тестирования на ошибки. 
К счастью, в тестовых фреймворках обычно уже имеются инструменты для тестирования исключений — что-то вроде сервисной функции `expectException()`, представленной в следующем листинге. 

### Листинг 1.33. Сервисная функция для тестирования на ошибки

```java
final class FooTest
{
    /**
     * @test
     */
    public function you_cannot_start_with_a_negative_number()   // : void
    {
        expectException(
/*Ожидаемый класс исключения*/InvalidArgumentException.className, // Ожидаемое ключевое слово в сообщении
            'negative',
            function () {   // Анонимная функция, вызывающая метод, в котором ожидается ошибка
                new Foo(-10);
            }
        );
    }
    // ...
}
```

Если тестируемый объект имеет зависимости, то, возможно, вы не захотите использовать настоящие зависимости.  
Например, эти зависимости могут начать вносить изменения в базу данных или отправлять электронные письма. 
Каждый запуск тестов будет чреват этими нежелательными последствиями. 
В такой ситуации нужно заменить реальные зависимости объектами, похожими на настоящие зависимости, но с измененной частью поведения.  
Ниже представлен пример. 

### Листинг 1.34. Использование тестового дублера

```java
interface Mailer 1((CO28-1))
{
    public function sendWelcomeEmail(UserId userId) //: void;
}
final class ActualMailer implements Mailer  // Задайте интерфейс для зависимости и предоставьте его замену
{
    public function sendWelcomeEmail(UserId userId) //: void
    {
        // Отправить электронное письмо
    }
}
final class StandInMailer implements Mailer // Задайте интерфейс для зависимости и предоставьте его замену
{
    public function sendWelcomeEmail(UserId userId) //: void
    {
        // Ничего не делать
    }
}
class Foo
{
    private Mailer mailer;
    public function __construct(Mailer mailer)
    {
        this.mailer = mailer;
    }
}
// В тесте:
foo = new Foo(new StandInMailer()); //В тесте можно инстанцировать Foo, предоставляя эту замену в качестве аргумента конструктора
```

Если вам захочется проверить, что Foo действительно вызывает метод `sendWelcomeEmail()`, можете использовать особый вид замены под названием _имитация_ (mock).  
Тестовые фреймворки обычно содержат специальные инструменты для настройки таких имитаций и проведения нужных проверок. 
В листинге ниже показан пример применения имитации без использования специальных инструментов.  

### Листинг 1.35.  Использование простой имитации для проверки успешного вызова метода

```java
final class MockMailer implements Mailer
{
    private bool hasBeenCalled = false;
    public function sendWelcomeEmail(UserId userId) // : void
    {
        this.hasBeenCalled = true; // Единственное, что делает эта имитация, — фиксирует, что метод sendWelcomeEmail() действительно вызывается
    }

    public function hasBeenCalled() // : bool
    {
        return this.hasBeenCalled;
    }
}
class Foo
{
    private Mailer mailer;
    public function __construct(Mailer mailer)
    {
        this.mailer = mailer;
    }
    public function someMethod()    // : void
    {
        this.mailer.sendWelcomeEmail();
    }
}
// В тесте:
mockMailer = new MockMailer();

foo = new Foo(mockMailer);  // Мы предоставляем имитацию в качестве зависимости

foo.someMethod();

assertTrue(mockMailer.hasBeenCalled()); // В конце теста проверим, что имитация получила запрос на вызов метода sendWelcomeEmail()
```

Тестовые дублеры мы рассмотрим подробнее в разделах 6.6 и 7.7.

О тестировании и подходах к нему можно рассказать еще очень многое, но это не входит в задачи книги.  
В этом разделе я хотел показать некоторые базовые техники, используемые в модульном тестировании.  
Далее будут представлены более подробные примеры и выводы по этой теме. 

[оглавление Главы 1](#глава-1-программирование-объектов-введение)

## 1.11. ДИНАМИЧЕСКИЕ МАССИВЫ



[оглавление Главы 1](#глава-1-программирование-объектов-введение)

[1.1. КЛАССЫ И ОБЪЕКТЫ](#11-классы-и-объекты)

[1.2. СОСТОЯНИЕ](#12-состояние)

[1.3. ПОВЕДЕНИЕ](#13-поведение)

[1.4. ЗАВИСИМОСТИ](#14-зависимости)

[1.5. НАСЛЕДОВАНИЕ](#15-наследование)

[1.6. ПОЛИМОРФИЗМ](#16-полиморфизм)

[1.7. КОМПОЗИЦИЯ](#17-композиция)

[1.8. ОРГАНИЗАЦИЯ КЛАССОВ](#18-организация-классов)

[1.9. ОПЕРАТОР ВОЗВРАТА И ИСКЛЮЧЕНИЯ](#19-оператор-возврата-и-исключения)

[1.10. МОДУЛЬНОЕ ТЕСТИРОВАНИЕ](#110-модульное-тестирование)

[1.11. ДИНАМИЧЕСКИЕ МАССИВЫ](#111-динамические-массивы)



