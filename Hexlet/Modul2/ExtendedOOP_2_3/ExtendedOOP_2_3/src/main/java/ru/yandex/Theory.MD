# Что такое ООП?

Объектно-ориентированное программирование (ООП) - это подход к разработке программ, который базируется на моделировании 
объектов реального мира. В отличие от процедурного подхода, где программа состоит из функций и данных, в ООП основными 
строительными блоками являются **объекты** и **классы**.

## Почему ООП важно?

ООП помогает организовать код таким образом, чтобы он был:
- **Понятным**: кажжая часть программы решает конкретную задачу.
- **Масштабируемым**: проще добавлять новый функционал.
- **Повторно используемым**: код можно использовать в разным проектах.

Четыре ключевых принципа ООП:
1. **Абстракция**.
2. **Инкапсуляция**.
3. **Наследование**.
4. **Полиморфизм**.

# Классы и объекты в Java

Ключевой концепцией объектно-ориентированного программирования в Java являются **классы** и **объекты**. Понимание их 
роли - основа для работы с ООП.

## Что такое класс?

Класс - это **шаблон** или **схема**, описывающая, как будет выглядеть объект. В классе определяются: 
- **Свойства** объекта (поля) - его характеристики.
- **Методы** - действия, которые объект может выполнять.

Пример: класс `Person` может описывать человека. У него есть свойства, такие как имя и возраст, и методы, например, 
`introduce()`.

Пример класса:

```java
class Person {
    String name;    // Поле класса
    int age;
    
    // Метод класса
    public void introduce() {
        System.out.println("Привет, меня зовут " + name + " и мне " + age + " лет.");
    }
}
```

# Что такое объект?

Объект - это **экземпляр класса**, созданный на основе его описания. Каждый объект имеет свои значения полей и может 
вызывать методы, описанные в классе.

# Классы и объекты в Java

**Ключевые моменты:**

1. **Класс** - это описание, **объект** - конкретный представитель.
2. Один класс может создавать множество объектов. Например, класс `Car` может описывать машины, а объекты - это 
конкретные машины с разным цветом, маркой и т.д.
3. Класс определяет общую структуру, но каждый объект хранит свои данные.

Сравнение с реальной жизнью:

Представьте, что класс - это чертёж дома, а объект - построенный по этому чертежу дом. По одному чертежу можно построить 
несколько домов, но каждый из них будет уникальным, например, с разной мебелью.

**Практическая польза**:

Использование классов и объектов позволяет:

- Организовать данные и логику в приложении.
- Избежать дублирование кода.
- Упростить масштабирование и поддержку проекта.

Таким образом, понимание классов и объектов является первым шагом к освоению ООП в Java.

# Инкапсуляция

**Инкапсуляция** - это один из ключевых принципов объектно-ориентированного программирования, который обеспечивает 
защиту данных и управление доступом к ним. В Java этот принцип реализуется с помощью модификаторов доступа и методов 
для работы с полями объекта.

**Суть инкапсуляции**

Инкапсуляция подразумевает, что внутренние данные объекта скрыты от прямого доступа извне. Вместо этого взаимодействие с 
ними осуществляется через специальные определённые методы - геттеры и сеттеры. Это позволяет:
- Защитить данные от некорректных изменений.
- Управлять доступом к данным, ограничивая или контролируя его.
- Сохранить целостность объекта.

**Модификаторы доступа**

В Java модификаторы доступа играют важную роль в реализации инкапсуляции:
- `private` - доступ только внутри класс
- `public` - доступ из любой точки программы.
- `protected` и пакетная видимость (без модификатора) используется для более сложных случаев, но их часть рассматривают 
позже.

Пример: поля класса делаются `private`, а доступ к ним предоставляется через методы.

# Инкапсуляция

**Преимущества инкапсуляции**:

1. **Безопасность данных**: предотвращается прямое изменение полей извне.
2. **Контроль над доступом**: вы можете задавать правила, как изменять данные.
3. **Гибкость**: внутреннее устройство объекта может меняться без влияния на код, который с ним работает.
4. **Повышение читаемости**: благодаря методам становится понятно, как использовать объект.

**Аналогия из реального мира**

Подумайте о банкомате: вы не получаете доступ к механизмам внутри устройства, а взаимодействуйте с ним через интерфейс -
экран и кнопки. Это пример инкапсуляции: сложная система скрыта, и вы можете выполнять только разрешённые операции. 

**Заключение**

Инкапсуляция делает код более организованным, защищённым и удобным для сопровождения.

# Наследование

**Наследование** - это один из базовых принципов объектно-ориентированного программирования, который позволяет одному 
классу унаследовать свойства и методы другого класса. В Java наследование упрощает повторное использование кода и делает 
его более организованным. 

**Что такое наследование?**

**Наследование** - это механизм, при котором вы можете создавать новый класс (называемый **дочерним**, или 
**производным**), базирующийся на уже существующем классе (называемом **родительским**, или **базовым**). Дочерним 
класс получает: 

- Все поля и методы родительского класса (кроме тех, что помечены `private`).
- Возможность добавлять свои собственные поля и методы.

**Использование наследования в Java**

Для реализации наследования используется ключевое слово `extends`.

**Ключевые моменты**:

1. **Дочерний класс наследует все, что доступно в родительском классе** (кроме `private` полей и методов).
2. Дочерний класс может: 
    - Переопределять методы родительского класса.
    - Добавлять новые методы и поля.
3. Вызов конструктор родительского класса осуществляется через ключевок слово `super`.

**Преимущества наследования**: 

1. **Повторное использование кода**: не нужно заново писать общие для всех объектов методы.
2. **Легкость масштабирования**: новые классы можно создавать на основе существующих.
3. **Читаемость**: код становится проще, особенно в больших проектах.

**Аналогия из реальной жизни**

Представим, что класс `Animal` - это общий шаблон для всех животных, а `Dog` - конкретный вид животного, который 
наследует все общие свойства (имя, возможность есть) и добавляется свои (умение лять).

**Ограничения наследования**

- В Java отсутствует **множественное наследование классов**, чтобы избежать конфликтов (но можно использовать 
интерфейсы).
- Чрезмерное использование наследования может усложнить структуру программы. Если классы становятся слишком зависимыми 
друг от друга, это снижается гибкость кода. 

# Наследование vs композиция, контракты и LSP

_Наследование_ - мощный инструмент повторного использования кода, но его легко превратить в "жесткую сцепку" и хрупкую 
иерархию. _Композиция_ же даёт гибкость: вы собираете поведение из небольших, независимых компонентов, которые можно 
подменять и тестировать по отдельности. _Практическое правило_: если вам нужно "расширить поведение" без изменения 
внешнего контракта - начните с композиции и стратегий; если нужен общий **тип** (полиморфизм по интерфейсу) - 
используйте интерфейсы и только затем, при реальной иерархии "is-a", аккуратно применяйте наследование.

_Контракт_ - это набор гарантий и ожиданий между компонентами: инварианты класса, предусловия и постусловия методов. В 
Java мы формализуем контракт через интерфейсы, документацию, проверки аргументов и тесты. Важно: реализация не должна 
"сужать" контракт базового типа. Это напрямую связано с _принципом подстановки Барбары Лисков_ (LSP): объект подкласса 
должен быть взаимозаменяем с объектом базового класса без неожиданного изменения поведения для клиента.

Классический антипример LSP - `Square extends Rectangle`: клиент ожидает, что изменение ширины не изменит высоту, а у 
квадрата это не так. _Решение_ - не "искусственно" наследовать, а ввести общий интерфейс или абстракцию 
"_ПрямоугольнаяФигура_" и реализовать их независимо, избегая ложной связи `is-a`.

(см. пример OrderService)

Практические сигналы в пользу композиции:
- Нужны разные вариации поведния во время выполнения (стратегии).
- Иерарахия "разрастается" из-за флагов и условий
- Тесты становятся сложными из-за скрытых зависимостей базового класса.

# Полиморфизм

**Полиморфизм** - это один из фундаментальных принципов объектно-ориентированного программирования, который означает 
способность одного интерфейса работать с множеством реализаций. Это делает программы более гибкими, масштабируемыми и 
удобными для сопровождения.

**Что такое полиморфизм?**

В переводе с греческого, "_полиморфизм_" означает "_много форм_". В программировании это проявляется в том, что:
1. **Один метод или интерфейс может иметь разные реализации.**
2. **Один объект может вести себя по-разному в зависимости от контекста.**

В Java полиморфизм бывает двух типов:
- **Статический полиморфизм** (_compile-time_): реализуется через перегрузку методов.
- **Динамический полиморфизм** (_runtime_): реализуется через переопределение методов и наследование.

# Примеры полиморфизма

**Перегрузка методов (статический полиморфизм)**: Перегрузка - это наличие нескольких методов с одинаковым названием, но
разными параметрами.

(см. пример Main3)

**Переопределение методов (динамический полиморфизм)**: Переопределение позволяет дочернему классу задавать свою 
реализацию метода родительского класса.

(см. пример Main4)

# Полиморфизм глубже: перегрузка vs переопределение

Полиморфизм в Java бывает двух видов: **переопределение** (override) и **перегрузка** (overload). 
Переопределение - динамический полиморфизм: выбор метода делается **во время выполнения** по фактическому типу объекта. 
Перегрузка - статический полиморфизм: выбор метода фиксируется **на этапе компиляции** по сигнатуре (типы параметров) 
видимой компилятору.

**Переопределение (runtime dispatch)**
- Работает через вирутальные вызовы: `@Override` в подклассе заменяет поведение базового типа
- Разрешение вызова зависит от **фактического** типа объекта в рантайме.
- Разрешено ковариантное возвращаемое значение и нельзя усиливать проверяемые исключения.

(см. пример Main5)

Практика:
- Всегда ставьте `@Override` - так вы ловите опечатки и несоответствие сигнатуры.
- Документирйте инварианты и исключения: они составляют контракт типа.
- Помните: _статические_ методы и _приватные_ методы **не переопределяются**, а скрываются/изолируются.

Перегрузка (compile-time resolution)
- Несколько методов с одинаковым именем, разными параметрами
- Выбор версии делается компилятором по типам параметров, с учетом приоритетов: 
точное совпадение -> приведение/автобоксинг -> varargs.
- На рантайм полиморфизм перегрузка **не опирается**.

(см. пример Main6)

Подводные камни перегрузки:
- `null` выбирает наболее специфичную сигнатуру, либо вызывает неоднозначность.

```java
void m(String s) {}
void m(Object o) {}

m(null);    // вызовется m(String), как более специфичная
```

Автобоксинг/vararsg могут неожиданное перетянуть разрешение:

```java
void f(int x) {}
void f(Integer x) {}
void f(Object x) {}
void f(int... xs) {}

f(5);       // f(int)
f(null);    // компиляция невозможна: нет однозначного соответствия
```

# Дженерики без боли: PECS и стирание

Дженерики в Java - механизм **на этапе компиляции**: проверяют типы и вставляют приведения, а в рантайме типовые 
параметры стерты. Отсюда два ключевых эффекта: список `List<Integer>` и `List<String>` имеют одинаковый рантайм-тип 
`java.util.ArrayList`; перегрузки, отличающиеся только тип-параметрами, невозможны; проверка `instanceof List<Integer>` 
запрещена.

**PECS: Producer Extends, Consumer Super**

Простое правилов выбора вайлдкарда:
- **Производитель** (только читаем) -> `? extends T`
- **Потребитель** (только пишем) -> `? super T`
- И читаем, и пишем -> инвариантный `List<T>`

Почему так? Вайлдкард делает список **ковариантным для чтения** (`extends`) и **контравариантным для записи** (`super`). 
Базовый `List<T>` - **инвариантен**: `List<Dog>` не является `List<Animal>`.

(см. пример Main7)










































