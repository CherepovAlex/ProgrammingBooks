# Классы и методы

## Определение

**Класс** - это основополагающая структура в Java, которая используется для создания объектов. По сути, класс  
представляет собой шаблон, описывающий, какие свойства (данные) и методы (поведение) будут у объекта, созданного на 
основе этого класса. Можно представить класс как чертёж дома, а объекты - как сами дома, построенные по этому чертежу. 
Каждый объект имеет свою уникальную копию данных, но все они следуют одному и тому же шаблону, определённому в классе.

```java
public class Car {
    // Поля класса
    String model;
    String color;
    int year;
    // Методы класса
    void startEngine() {
        System.out.println("Engine started.");
    }
    void stopEngine() {
        System.out.println("Engine stopped.");
    }
}
```

## Класс vs объект: шаблон и экземпляр

- Класс - описание того, _какие_ данные и _какое_ поведение будут у объектов: поля (состояние) и методы (поведение). 
Аналогия: класс - чертёж. 
- Объект - конкретный экземпляр класса в памяти со своим собственным состоянием. Аналогия: дом, построенный по черетежу.
- Один класс порождаем множество объектов; у каждого - независимые значения полей. 
- Конструктор задаёт начальные правила создания объекта; оператор `new` выделяет память и возвращает ссылку. 
- Экземплярные члены принадлежат объекту; `static`-члены - самому классу и общие для всех объектов.

```java
class Rectangle {       // класс (шаблон)
    private final int w;    // состояние
    private final int h;
    Rectangle(int w, int h) {
        if (w <= 0 || h <= 0) throw new IllegalArgumentException();
        this.w = w; this.h = h;
    }
    int area() {            // поведение
        return w * h;
    }
}
class Main {
    public static void main(String[] args) {
        Rectangle a = new Rectangle(2, 3);  // объект (экземпляр) 
        Rectangle b = new Rectangle(5, 7);  // другой объект с другим состоянием
    }
}
```

## Поля: состояние; модификаторы доступа

Поля хранят состояние объекта или класса.
- Экземплярные поля - у каждого объекта свои значения.
- `static` поля - общие для всех экземпляров (состояние класса).
- `final` фиксрует ссылку/значение после инициализации.

Инкапсуляция через модификаторы доступа:
- `private` - доступ только внутри того же класса. Основной выбор для полей: защищает инварианты, позволяет
контролировать изменения через методы.
- `public` - доступен всем. Применять для констант (`public static final`) либо когда изменение не вредит инвариантам 
(редко). 
- `protected` - доступ из того же пакета и из подклассов. Полезно для наследования, но легко "протекает" внутрь API.
- _package-private_ (без модификатора) - доступен в пределах пакета. Удобно для "внутренних" деталей модуля.

Рекомендации:
- Поля почти всегда `private`; меняйте состояние через методы с валидацией.
- Константы делайте `public static final` (имена в UPPER_SNAKE_CASE)
- Для неизменяемых классов - `private final` поля, без сеттеров.

```java
class BankAccount {
    public static final String CURRENCY = "EUR";    // публичная константа
    private final String owner;         // инкапсулированное состояние
    private long balanceCents;
    
    // package-private конструктор для фабрики в том же пакете
    BankAccount(String owner, long initialCents) {
        if (owner == null || owner.isBlank() || initialCents < 0) {
            throw new IllegalArgumentException("Invalid data");
        }
        this.owner = owner;
        this.balanceCents = initialCents;
    }
    public String getOwner() { return owner;}
    public long getBalanceCents() { return balanceCents; }
    
    // контролируем изменение состояния
    public void deposit(long cents) {
        if (cents <= 0) throw new IllegalArgumentException("cents > 0");
        balanceCents += cents;
    }
    
    protected void applyFee(long cents) {   // доступ наследникам/пакету
        if (cents < 0 || cents > balanceCents) return;
        balanceCents -= cents;
    }
}
```

## Статические члены (static) vs экземплярные

**Кому принадлежат**:
- `static` поля/методы принадлежат _классу_. Общие для всех объектов, существуют без создания экземпляра.
- Экземплярные - принадлежат _конкретному объекту_. Каждая копия хранит своё состояние.

**Когда использовать** `static`
- _Константы_: `public static final int TIMEOUT = 5000;`
- _Утилиты без состояния_: чистые функции, форматирование, валидация.
- _Общее состояние класса_: счетчики, кэши (с осторожностью и синхронизацией).

**Когда использовать экземплярные**
- Когда есть _состояние объекта_ и поведение зависит от него.
- Когда нужно полиморфное поведение (динамическа диспетчеризация по объекту).

**Ограничения и ловушки** `static`
- Статические методы не используют `this` и не могут обращаться к нестатическим полям без ссылки на объект.
- Полиморфизм не работает: `static`-методы _не переопределяются_ (они скрываются).
- Глобальное состояние усложняет тестирование и конкурентный доступ - требуется потокобезопасность.

```java
class Counter {
    // Общее состояние класса
    private static long created;
    
    // Состояние конкретного объекта
    private final String name;
    
    public Couner(String name) {
        this.name = name;
        created++;  // изменяем обзее состояние (нужна синхранизация в многопоточности)
    }
    
    public String label() {     // экземплярный метод
        return "Counter[" + name + "]";
    }
    
    public static long createdCount() { // статический метод
        return created;
    }
    
    // Статическая фабрика (именованный "конструктор")
    public static Counter of(String name) {
        return new Counter(name);
    }
}

// Утилиарный класс без состояние
final class MathUtil {
    private MathUtil() {}   // запрет инстанцирования
    
    public static int max(int... xs) {  // удобный
        int m = Integer.MIN_VALUE;
        for (int x : xs) m = (x > m)? x : m;
        return m;
    }
}
```

## Методы: поведение; сигнатура и побочные эффекты

- Метод задаёт поведение класса: отвечает на вопрос "что объект умеет делать".
- Сигнатура метода - это его _имя_, _список параметров_ (_типы_ и _порядок_) и _тип возвращаемого значения_. 
Модификаторы (`public, static, final`) и исключения - часть объявления, но не сигнатуры перегрузки.
- Имя должно отражать действие: `calculateTotal()`, `deposit(amount)`, `findById(id)`.

```java
class BankAccount {
    private long balanceCents;
    
    // имя: deposit; параметры: (long); тип результата: void
    public void deposit(long cents) {   // побочный эффект: меняет состояние объекта
        if (cents <= 0) throw new IllegalArgumentException("cents > 0");
        balanceCents += cents;
    }
    // имя: getBalanceCents; параметры: (); тип результата: long
    public long getBalanceCents() { // чистый метод: не меняет состояние
        return balanceCents; 
    }
    
    // перегрузка: различается список параметров
    public static BankAccount of(long initialCents) {
        if (initialCents < 0) throw new IllegalArgumentException();
        BackAccount acc = new BankAccount();
        acc.balanceCents = initialCents;
        return acc;
    }
}
```

Побочные эффекты - всё, что выходит за вычисление результата: изменение полей, запись в БД/файл, сетевые вызовы, 
логирование, изменение аргументов по ссылке.

Чистые методы (без побочных эффектов) проще тестировать и комбинировать; старайтесь отделять вычисление (`calculate`) от 
действий (`save`..., `send`...).

Контракт метода: предусловия (что принимаем), постусловия (что гарантируем), возможные исключения. 
Фиксируйте это JavaDoc  и проверками.

Памятка:
- Параметры минимально необходимы, порядок логичен.
- Тип возвращаемого значения точный: не `Object`, если можно вернуть `int`/`Optional<T>`.
- Имена глагольные для действий, существительные/прилагательные - для запросов (`size()`, `isEmpty()`).
- Избегайте неожиданных побочных эффектов в "геттерах" и "проверках".

## Конструкторы, перегрузка конструкторов; ключевое слово this

- **Конструктор** - специальный метод создания объекта с именем класса и без типа результата. Инициализирует поля и 
проверяет инварианты. Если не объявлен ни один, компилятор добавит _пустой конструктор по умолчанию_; как только 
объявлен любой - "дефолтного" больше нет.
- **Перегрузка конструкторов** - несколько конструкторов с разными списками параметров. Удобно давать разные способы 
инициализации (минимальный/расширенный).
- `this`
    a. Ссылка на _текущий объект_ внутри его методов/конструкторов.
    b. Разрешает конфликт имен: `this.name = name`;
    c. Вызов другого конструктора в том же классе: `this(...)` (должен быть первой строкой).
    d. Нельзя одновременно вызвать `this(...)` и `super(...)` в одном конструкторе; один вызов - всегда первая строка. 
Если `super(...)` не указан, вызывается `super()` неявно.

```java
class User {
    private final String name;
    private final String email;
    private int age;
    
    // Базовый контруктор
    public User(String name, String email, int age) {
        if (name == null || name.isBlank()) throw new IllegalArgumentException("name");
        if (email == null || email.isBlank()) throw new IllegalArgumentException("email");
        if (age < 0) throw new IllegalArgumentException("age");
        this.name = name;       // this.field - поле объекта
        this.email = email;
        this.age = age;
    }
    
    // Перегрузка: минимальный набор данных
    public User(String name, String email) {
        this(name, email, 0);           // вызов другого конструктора (constructor chaining)
    }
    
    // Метод, использующий this как ссылку на текущий объект
    public User withAge(int newAge) {
        User u = new User(this.name, this.email, newAge);   // передаём текущее состояние явно
        return u;
    }
}
```

## Рекомендации

- Валидируйте аргументы в _конструкторе_ - защищайте инварианты с рождения объекта.
- Для длинных "лесенок" перегрузок рассмотрет _статические фабрики_ (`User.of(...)`) или _билдер_.
- Инициализируйте `final` поля в конструкторе или при объявлении.

## Быстро о final для полей и параметров

`final` у поля присваивание выполняется только один раз (при объявлении или в конструкторе).

Повторное присваивание запрещено:
- Примитивы: значение фиксируется навсегда.
- Ссылки: ссылки фиксируются, но внутреннее состояние объекта может менять, если он изменяемый.

Зачем ставить `final` у полей:
- Явная неизменяемость -> проще рассуждать и тестировать.
- Гарантии в многопоточности: правильно сконструированные `final`-поля "видны" другим потокам без доп. синхронизации 
после завершения конструктора.
- Котракт класса: инварианты задаются один раз и не "расползаются" по сеттерам.

`final` у параметров метода/конструктора: защищает от случайного переприсваивания параметра внутри тела метода. На 
логику вызова не влияет, но повышает читатемость.
- Локальные перменные в лямбах должны быть "эффективано final" (не изменяться после первого присваивания).

```java
import java.util.List;

class User {
    private final String name;          // фиксируется в конструкторе
    private final List<String> roles;   // ссылка фиксируется, содержимое - нет!

    public User(final String name, final List<String> roles) {
        if (name == null || name.isBlank()) throw new IllegalArgumentException("name");
        this.name = name;
        // защитная копия + неизменяемое представление
        this.roles = List.copyOf(roles);
    }
    
    public String getName() {
        return name;
    }
    
    public List<String> getRoles() {
        return roles;
    }   // уже неизменяемый список
}

class Main{
    // Параметры с final - нельзя переприсвоить внутри метода
    static int add(final int a, final int b) {
        a = 10; // ошибка компиляции
        return a + b;
    }
}
```

## Перегрузка методов

**Что такое перегрузка**
    Несколько методов с _одним_ именем и разными _списками параметров_ (типы/число/порядок).
    Возвращаемый тип в перегрузке роли не играет - "различаются только по return" **нельзя**.

**Как компилятор выбирает перегрузку (упрощённо)**

1. Ищет **точное совпадение типов** параметров.
2. Если нет - пытается **расширяющее преобразование примитива** (widening), напр. `int -> long`.
3. Если нет - пробуется **boxing/unboxing**, напр. `int <-> Integer`.
4. В крайнем случае - **varargs**(`T...`).

При нескольких подходящих - выбирается **наиболее специфичная** сигнатура; если однозначности нет - ошибка "ambiguous".

```java
class Main {
    static void f(int x) {}
    static void f(long x) {}
    static void f(Integer x) {}
    static void f(int... xs) {}

    public static void main(String[] args) {
        f(5);       // -> f(int) (точное совпадение)
        f(5L);      // -> f(long) (точное совпадение)
        f(new Integer(5));  // -> f(Integer)
        f((short)5);    // -> f(int) (widening short->int
        f(1, 2, 3);     // -> f(int...) (varargs)
    }
}
```

## Varargs(int... nums) и его ограничения

**Что это такое**
Varargs позволяет передавать "ноль или больше" аргументов одного типа. Внутри метода это **обычный массив** того же типа.

```java
class Main {
    static int sum(int xs) {        // xs == int[]
        int s = 0;
        for (int x : xs) s += x;
        return s;
    }

    public static void main(String[] args) {
        sum();                  // 0 аргументов -> ok (xs.length == 0)
        sum(1, 2, 3);           // произвольное число аргументов
        sum(new int[]{4, 5});   // можно передавать готовый массив
    }
}
```

**Правила объявления**
- Varargs-параметр **только один** и **всегда последний**: `void f(String label, int... xs)`.
- Для ссылочных типов запись: `String...`, `List<?>...`;для примитивов - конкретный примитив:` int...`, `long...` и т.д.

**Как выбирает перегрузка**
- Varargs имеет `самый низкий приоритет`: компилятор сначала ищет точное совпадение, затем widening/boxing, и лишь потом
`...` . Это снижает риск "съесть" вызовы, но всё же:

```java
class Main {
    static void g(Integer x) {}
    static void g(int... xs) {}

    public static void main(String[] args) {
        g(5);   // вызовется g(Integer) (boxing), а не varargs
    }
}
```

**Производительность**

- Каждый вызов с varargs создаеёт **временный массив**. В "горячем" коде предпочитайте перегрузки/ручные массивы.

**Неочевидности и ловушки**

- `null`: вызов `f((int[]) null)` - это "один аргумент: null-массив"; а `f(null)` компилятору часто неясен с 
перегрузками ссылочных типов -> потребуются явные приведения.

## Возвращаемые типы и ранний выход (return), void



































