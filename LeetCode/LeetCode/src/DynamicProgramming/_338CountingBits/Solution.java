package DynamicProgramming._338CountingBits;

import java.util.Arrays;

// 338. Подсчёт битов
// Для заданного целого числа n верните массив ans длиной n + 1 такой, что для каждого i (0 <= i <= n),
// ans[i] будет количество 1 в двоичном представлении i.
// Example 1:
//Input: n = 2
//Output: [0,1,1]
//Explanation:
//0 --> 0
//1 --> 1
//2 --> 10
//Example 2:
//Input: n = 5
//Output: [0,1,1,2,1,2]
//Explanation:
//0 --> 0
//1 --> 1
//2 --> 10
//3 --> 11
//4 --> 100
//5 --> 101
public class Solution {
    // time O(n*log(n)),
    public int[] countBits(int n) {
        // Создаем массив для хранения результатов длиной n+1
        int[] ans = new int[n + 1];
        // Базовый случай: число 0 содержит 0 единиц в двоичном представлении
        ans[0] = 0;
        // Заполняем массив для всех чисел от 1 до n
        for (int i = 1; i <= n; i++) {
            // Количество единиц в числе i равно:
            // Конвертируем текущее число i в двоичную строку
            String binary = Integer.toBinaryString(i);  // имеет сложность O(log(i))
             // Подсчитываем количество единиц в двоичном представлении
            int oneCount = countOnes(binary); // имеет сложность O(log(i))
            // Сохраняем результат в массив
            ans[i] = oneCount;
        }
        // Возвращаем заполненный массив результатов
        return ans;
    }
    // Вспомогательный метод для подсчета единиц в строке
    private int countOnes(String num) {
        // Инициализируем счетчик единиц
        int count = 0;
        // Проходим по каждому символу в двоичной строке
        for (int i = 0; i < num.length(); i++) {
            // Если текущий символ равен '1', увеличиваем счетчик
            if (num.charAt(i) == '1') {
                count++;
            }
        }
        return count; // Возвращаем общее количество единиц
    }
    // Проблемы производительности:
    //Лишнее преобразование числа в строку
    //Лишний проход по строке для подсчета единиц
    //Создание множества временных строковых объектов

    // Оптимальное решение: время O(n), память O(1)
    public int[] countBits1(int n) {
        // Создаем массив для хранения результатов длиной n+1
        int[] ans = new int[n + 1];
        // Базовый случай: число 0 содержит 0 единиц в двоичном представлении
        ans[0] = 0;
        // Заполняем массив для всех чисел от 1 до n
        for (int i = 1; i <= n; i++) {
            // Количество единиц в числе i равно:
            // - количеству единиц в числе i/2 (путем сдвига вправо на 1 бит)
            // - плюс младший бит числа i (0 для четных, 1 для нечетных)
            ans[i] = ans[i >> 1] + (i & 1);
            // эквивалентно делению на 2 + дает младший бит числа (0 для четных, 1 для нечетных)
        }
        return ans;
    }
    // Ключевая идея основана на следующих наблюдениях:
    // Для четного числа i количество единиц такое же, как у i/2
    // Для нечетного - на одну единицу больше, чем у i/2


    public static void main(String[] args) {
        int n1 = 2;
        int n2 = 5;
        System.out.println(Arrays.toString(new Solution().countBits(n1)));
        System.out.println(Arrays.toString(new Solution().countBits(n2)));
    }
}
