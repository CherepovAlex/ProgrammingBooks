package Trie._14LongestCommonPrefix;

// 14. Напишите функцию для поиска самого длинного общего префикса в массиве строк.
//Если общего префикса нет, верните пустую строку ""
// Пример 1:
//Ввод: strs = ["flower", "flow", "flight"]
//Вывод: "fl"
//Пример 2:
//Входные данные: strs = [«собака», «гоночный автомобиль», «автомобиль»]
//Выходные данные: ""
//Пояснение: Во входных строках нет общего префикса.
public class Solution {
    // time O(s), s - summa all of simbols in strs; space O(1)
    public String longestCommonPrefix(String[] strs) {
        // Проверка на пустой массив
        if (strs == null || strs.length == 0)
            return ""; // Возвращаем пустую строку если массив пуст

        // Проходим по всем символам первой строки (берём её как эталон)
        for (int i = 0; i < strs[0].length(); i++) {
            // Берём текущий символ из первой строки
            char ch = strs[0].charAt(i);
            // Проходим по всем остальным строкам в массиве (начиная со второй)
            for (int j = 1; j < strs.length; j++) {
                // Если текущий индекс выходит за длину строки ИЛИ сивол не совпадает
                if (i == strs[j].length() || strs[j].charAt(i) != ch) {
                    // Возвращаем подстроку от начала до текущего индекса (исключительно)
                    return strs[0].substring(0, i);
                }
            }
        }
        // Если прошли все символы первой строки и все совпало, возвращаем всю первую строку
        return strs[0];
    }
    // time O(S), S - сумма длин всех строк
    public String longestCommonPrefix2(String[] strs) {
        // Инициализируем переменную для хранения общего префикса
        String common = "";
        // Проверяем пустой ли массив
        if (strs.length == 0) return common;    // Если массив пуст, возвращаем пустую строку
        // Берём первую строку как начальный кандидат на общий префикс
        common = strs[0];
        // Проходим по всем строкам в массиве (начиная со второй)
        for (int i = 1; i < strs.length; i++) {
            // Пока текущая строка НЕ начинается с текущего общего префикса
            while (strs[i].indexOf(common) != 0) {
                // Укорачиваем общий префикс на один символ с конца
                common = common.substring(0, common.length() - 1);
                // Если общий префикс стал пустой строкой, прерываем выполнение
                if (common.isEmpty()) return "";
            }
        }
        return common;  // возвращаем найденный общий префикс
    }

    // binary search - метод с использованием бинарного поиска
    // time O(s*log n), n - length of most short str, space - O(1)
    public String longestCommonPrefix1(String[] strs) {
        // Проверка на пустой массив или null
        if (strs == null || strs.length == 0) return "";

        // Ищется максимальная длина mid, для которой подстрока первых mid символов является префиксом всех строк.
        // Находим минимальную длину среди всех строк
        int minLen = Integer.MAX_VALUE;
        // Проходим по всем строкам, чтобы найти самую короткую
        for (String str : strs) {
            minLen = Math.min(minLen, str.length());
        }

        // Устанавливаем границы для бинарного поиска
        int low = 1;        // минимально возможная длина префикса
        int high = minLen;  // максимально возможная длина префикса
        // Выполняем бинарный поиск
        while (low <= high) {
            // Находим среднюю длину для проверки
            int mid = (low + high) / 2;
            // Если для текущего mid префикс общий, ищется более длинный префикс (сдвигается low).
            // Проверяем, является ли подстрока длиной mid общим префиксом
            if (isCommonPrefix(strs, mid)) {
                // Если является - ищем более длинный префикс (сдвигаем нижнюю границу)
                low = mid + 1;
            } else {
                // Если не общий - ищется более короткий (сдвигается high).
                // Если не является - ищем более короткий префикс (сдвигаем верхнюю границу)
                high = mid - 1;
            }
        }
        // Возвращаем найденный общий префикс (используется среднее значение границ)
        return strs[0].substring(0, (low + high) / 2);
    }

    // проверяет, является ли подстрока первых len символов первой строки префиксом всех остальных строк
    private boolean isCommonPrefix(String[] strs, int len) {
        // Берём подстроку первой строки длиной len
        String prefix = strs[0].substring(0, len);
        // Проверяем все остальные строки
        for (int i = 1; i < strs.length; i++) {
            // Если строка не начинается с этого префикса - возвращаем false
            if (!strs[i].startsWith(prefix)) {
                return false;
            }
        }
        return true; // Все строки содержат этот префикс - возвращаем true
    }


    public static void main(String[] args) {
        // Создаем тестовый массив строк
        String[] strs = new String[]{"flower", "flow", "flight"};
        // Вызываем метод и выводим результат
        System.out.println(new Solution().longestCommonPrefix1(strs));
    }
}
