package Medium._153FindMinimumInRotatedSortedArray;

// Найдите минимум в отсортированном массиве
// Предположим, что массив длиной n отсортирован по возрастанию и поворачивается от 1 до n раз. Например, массив
// nums = [0,1,2,4,5,6,7] может стать таким:
// [4,5,6,7,0,1,2] если бы его повернули 4 раз.
// [0,1,2,4,5,6,7] если бы его повернули 7 раз.
// Обратите внимание, что поворот массива [a[0], a[1], a[2], ..., a[n-1]] на 1 шаг приводит к получению массива
// [a[n-1], a[0], a[1], a[2], ..., a[n-2]].
// Дан отсортированный повернутый массив nums из уникальных элементов. Верните минимальный элемент этого массива.
// Вы должны написать алгоритм, который выполняется за O(log n) time.
public class Solution {
    // time O(log n), space O(1)
    public int findMin(int[] nums) {
        // Инициализация указателей: left - начало массива, right - конец массива
        int left = 0;
        int right = nums.length - 1;

        // Пока указатели не встретятся (бинарный поиск
        while (left < right) {
            // Находим средний индекс между left и right
            int mid = left + (right - left) / 2;

            // Сравниваем элемент в середине с элементом в правой части
            if (nums[mid] > nums[right]) {
                // Если средний элемент больше правого, значит минимум находится в правой половине
                left = mid + 1;
            } else {
                // Если средний элемент меньше или равен правому, значит минимум находится в левой половине (и mid)
                right = mid;
            }
        }

        // Когда left == right, мы нашли минимальный элемент
        return nums[left];
    }

    public static void main(String[] args) {
        int[] nums = {3, 4, 5, 1, 2};
        System.out.println(new Solution().findMin(nums));
    }
}
