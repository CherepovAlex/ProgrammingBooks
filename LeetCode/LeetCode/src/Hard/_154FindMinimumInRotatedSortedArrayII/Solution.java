package Hard._154FindMinimumInRotatedSortedArrayII;

// Найдите минимум в отсортированном массиве II
//Предположим, что массив длиной n отсортирован по возрастанию и поворачивается от 1 до n раз. Например, массив
// nums = [0,1,4,4,5,6,7] может стать таким:
//[4,5,6,7,0,1,4] если бы его повернули 4 раз.
//[0,1,4,4,5,6,7] если бы его повернули 7 раз.
//Обратите внимание, что поворот массива [a[0], a[1], a[2], ..., a[n-1]] на 1 шаг приводит к получению массива
// [a[n-1], a[0], a[1], a[2], ..., a[n-2]].
//Дан отсортированный повернутый массив nums, который может содержать дубликаты. Верните минимальный элемент этого
// массива. Вы должны максимально сократить общее количество этапов работы.
// Example 1:
//Input: nums = [1,3,5]
//Output: 1
//Example 2:
//Input: nums = [2,2,2,0,1]
//Output: 0
public class Solution {
    // time O(log n) or O(n), space O(1)
    public int findMin(int[] nums) {
        // Левый указатель - начало массива
        int left = 0;
        // Правый указатель - конец массива
        int right = nums.length - 1;

        // Продолжаем поиск пока левый указатель меньше правого
        while (left < right) {
            // Находим средний индекс между left и right
            int mid = left + (right - left) / 2;
            // Если средний элемент больше правого, минимум находится в правой части
            if (nums[mid] > nums[right]) {
                left = mid + 1;
            }
            // Если средний элемент меньше правого, минимум находится в левой части (включая mid
            else if (nums[mid] < nums[right]) {
                right = mid;
            }
            // Если средний элемент равен правому, сдвигаем правую границу
            else {
                right--;
            }
        }
        // Когда left == right, мы нашли минимальный элемент
        return nums[left];
    }

    public static void main(String[] args) {
        int[] nums = {1, 3, 5};
        System.out.println(new Solution().findMin(nums));
    }
}
