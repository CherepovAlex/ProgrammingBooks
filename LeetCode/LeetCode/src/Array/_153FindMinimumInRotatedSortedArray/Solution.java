package Array._153FindMinimumInRotatedSortedArray;

// 153. Найдите минимум в отсортированном массиве.
// Предположим, что массив длиной n отсортирован по возрастанию и поворачивается от 1 до n раз.
// Например, массив nums = [0,1,2,4,5,6,7] может стать таким:
// [4,5,6,7,0,1,2] если бы его повернули 4 раз, или [0,1,2,4,5,6,7] если бы его повернули 7 раз.
// Обратите внимание, что поворот массива [a[0], a[1], a[2], ..., a[n-1]] на 1 шаг приводит к получению массива
// [a[n-1], a[0], a[1], a[2], ..., a[n-2]].
// Дан отсортированный повернутый массив nums из уникальных элементов. Верните минимальный элемент этого массива.
// Вы должны написать алгоритм, который выполняется за O(log n) time.
public class Solution {
    // time O(log n), space O(1)
    public int findMin(int[] nums) {
        // Инициализация левого указателя на начало массива
        int left = 0;
        // Инициализация правого указателя на конец массива
        int right = nums.length - 1;

        // Цикл бинарного поиска: продолжается, пока левый указатель меньше правого
        while (left < right) {
            // Вычисление среднего индекса для предотвращения переполнения
            int mid = left + (right - left) / 2;

            // Если средний элемент больше правого, значит точка поворота (минимум) справа от mid
            // Сдвигаем левую границу поиска на элемент после mid
            if (nums[mid] > nums[right]) {
                // Если средний элемент больше правого, значит минимум находится в правой половине
                left = mid + 1;
            } else {
                // Если средний элемент меньше или равен правому, значит минимум слева от mid или в mid
                // Сдвигаем правую границу поиска на mid (не mid-1, т.к. mid может быть минимумом)
                right = mid;
            }
        }

        // Когда left == right, мы нашли индекс минимального элемента
        return nums[left];
    }
    // Пояснение алгоритма:
    //Идея: В повернутом отсортированном массиве есть две отсортированные части, и минимальный элемент - это точка поворота
    //Ключевое сравнение: Сравнивая nums[mid] с nums[right], мы определяем, в какой половине находится минимум
    //Если nums[mid] > nums[right]: Минимум находится в правой половине (после mid)
    //Если nums[mid] ≤ nums[right]: Минимум находится в левой половине (включая mid)
    //Сложность: Каждая итерация уменьшает пространство поиска вдвое - O(log n)
    //Для примера [3,4,5,1,2]:
    //Первая итерация: mid=2 (значение 5), 5 > 2 → left = 3
    //Вторая итерация: left=3, right=4, mid=3 (значение 1), 1 < 2 → right = 3
    //left=3, right=3 → возвращаем nums[3] = 1

    public static void main(String[] args) {
        int[] nums = {3, 4, 5, 1, 2};
        System.out.println(new Solution().findMin(nums));
    }
}
