# Глава 3. Геттеры и сеттеры.

[Раздел 3.1. Использование сеттера или геттера для наложения определённых ограничений при доступе к переменным.](#раздел-31-использование-сеттера-или-геттера-для-наложения-определённых-ограничений-при-доступе-к-переменным)

[Раздел 3.2. Зачем использовать геттеры и сеттеры?](#раздел-32-зачем-использовать-геттеры-и-сеттеры)

[Раздел 3.3. Добавление геттеров и сеттеров?](#раздел-33-добавление-геттеров-и-сеттеров)

В этой главе рассматриваются геттеры и сеттеры - стандартный способ предоставления доступа к данным в классах Java.

## Раздел 3.1. Использование сеттера или геттера для наложения определённых ограничений при доступе к переменным.

Сеттеры и геттеры позволяют объекту содержать переменные с модификатором доступа `private`, доступ к которым и изменение которых может быть ограничено. Например,

```java
public class Person {
    private String name;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        if (name != null && name.length() > 2)
            this.name = name;
    }
}
```

Класс `Person` содержит единственную переменную: `name`. К этой переменной можно получить доступ с помощью метода `getName()` и изменить её с помощью метода `setName(String)`. Однако изменить имя можно только, если не выполняется условие: требуется, что новое имя имело длину более 2 символов и не было равно `null`. Использование метода-сеттера вместо объявления переменной `name` с модификаторо доступа `public` разрашает другим пользователям устанавливать значение `name` с определёнными ограничениями, что позволяет избежать присваивания переменной нежелательных значений. То же самое можно сделать и с методом `getter`:

```java
public String getName() {
    if (getName().length() > 16)
        return "Слишком длинное имя!";
    else
        return name;
}
```

В приведённом выше модифицированное методе `getName()` значение переменной `name` возвращается только в том случае, если длина имени меньше или равна 16. В противном случае возвращается сообщение `"Слишком длинное имя!"`. Это позволяет программисту создаваить переменные, которые дсотупны для чтения и изменения по своему усмотрению, не позволяя другим классам вносить нежелательные изменения в эти переменные.

[к оглавлению Глава 3](#глава-3-геттеры-и-сеттеры)

## Раздел 3.2. Зачем использовать геттеры и сеттеры?

Рассмотрим класс, содержащий объект с геттерами и сеттерами на языке Java:

```java
public class CountHolder {
    private int count = 0;
    
    public int getCount() { return count;}
    public void setCount(int c) { count = c;}
}
```


Мы не можем получить доступ к переменной `count`, поскольку у неё модификатор доступа `private`. Но мы можем получить доступ к методам `getCount` и `setCount`, поскольку у них модификатор доступа `public`. У кого-то может возникнуть вопрос: зачем нас вводить посредника? Почему бы просто не назначить переменной `count` модификатор доступа `public`?

```java
public class CountHolder {
    public int count = 0;
}
```

По своей функциональности эти два фрагмента кода абсолютно равнозначны. Разница между ними заключается в расширяемости. Рассмотрим, что говорит каждый из классов:
+ Первый: "У меня есть метод, который выдает значение `int`, и метод, который устанавливает это значение в другой `int`".
+ Второй: "У меня есть поле типа `int`, значение в котором вы можете изменять и получать по своему усмотрению".

На первый взгляд они похожи, но на самом деле первая реализация выглядит более защищённой: она позволяет взаимодействовать с содержимым класса только по **своим собственным** правилам. При этом мяч остаётся на вашей стороне поля, и вы сами выбираете, как именно будет происходить взаимодействие между переменными внутри вашего класса. Во втором случае внутренняя реализация направлена вовне, и теперь содержимое вашего класса не только подвержено влиянию внешних пользователей, но и, в случае с API, **необходимо будет постоянно** поддерживать эту реализацию (или, в противном случае, ваш API будет обратно несовместим, т.е. новая версия API будет несовместима с предыдущей).

Допустим, нам необходимо синхронизировать доступ для модификации и чтения переменной `count`. В первом случае это сделать довольно просто:
```java
public class CountHolder {
    private int count = 0;
    
    public synchronized int getCount() {return count;}
    public synchronized void setCount(int c) { count = c;}
}
```

Но во втором примере это уже практически невозможно сделать без перебора и модификации всех мест, где встречается ссылка на переменную `count`. Хуже того, если это элемент, который вы предоставляете в библиотеку для использования другими пользователями, у вас **не будет** возможности выполнить такую модификацию, и вы будете вынуждены принять сложное решение, о котором говорилось выше.

В связи с этим возникает вопрос: есть ли хоть какие-то положительные моменты в использовании переменных с модификатором доступа `public` (или, по крайней мере, отсутствуют ли отрицательные)?

Я не уверен. С одной стороны, можно найти примеры применения переменных `public`, которые выдержали испытание временем (например, переменная `out`, на которую ссылается `System.out`). С другой стороны, предоставление переменной модификатора доступа `public` не даёт никаких преимуществ, кроме потенциального уменьшения текста программы. Если вы планируете сделать переменную общедоступной, то должны оценивать ее с **особой тщательностью** по следующим критерям: 

1. Переменная не должна иметь никаких мыслимых причин для изменения в своей реализации. Здесь очень легко допустить критическую ошибку (и даже если вы уверены, что все сделали правильно, требования могут измениться), поэтому геттеры/сеттеры являются общепринятым подходом. Если вы собираетесь ввести переменную `public`, то этот момент действительно необходимо хорошенько продумать, особенно если она войдёт в состав библиотеки/фреймворка/API.
2. Чтобы получить хоть минимальный выигрыш от сокращения текста программы, переменная `public` должна использоваться достаточно часто. Я даже думаю, что здесь не следует всерьёз рассматривать избыточную трату времен на использование метода по сравнения с прямой ссылкой. По моим скромным оценкам, она слишком незначительна для 99,9% приложений.

Вероятно, есть и другие варианты, которые я не рассмотрел. Если вы сомневаетесь, всегда используйте геттеры/сеттеры.

[к оглавлению Глава 3](#глава-3-геттеры-и-сеттеры)

## Раздел 3.3. Добавление геттеров и сеттеров?

Инкапсуляция - это базовая концепция ООП. Она заключается в том, чтобы обернуть данные и код в единое целое. В данном случае хорошей практикой является объявление переменных как `private` с последующей реализацией доступа к ним через геттеры и сеттеры для их просмотра и/или модификации.

```java
public class Sample {
    private String name;
    private int age;
    
    public int getAge() {
        return age;
    }
    
    public void setAge(int age) {
        this.age = age;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
}
```

Эти переменные с модификатором доступа `private` не могут быть доступны непосредственного извне класса. Таким образом, они защищены от несанкционированного доступа. Но если вы хотите просмотреть или изменить их, вы можете использовать геттеры и сеттеры.

Прочитать текущее значение переменной `xxx` можно при помощи метода `getXxx()`, а установить значение переменной Xxx можно с помощью метода `setXxx`.

Методы имеют следующие соглашения об именовании (в примере переменная называется `variableName`):
+ для всех переменных, не имеющих тип `boolean`
```java
    getVariableName()       // Главное, чтобы имя переменной начиналось с прописной буквы
    setVariaableName(...)      // сеттер, имя переменной должно начинаться с прописной буквы
```
+ для все переменных типа `boolean`
```java
    isVariableName()        // геттер, имя переменной должно начинаться с прописной буквы
    setVariableName(...)    // сеттер, имя переменной должно начинаться с прописной буквы
```

Геттеры и сеттеры с модификатором доступа `public` являются часть концепции JavaBean определения свойств объектов.

[к оглавлению Глава 3](#глава-3-геттеры-и-сеттеры)