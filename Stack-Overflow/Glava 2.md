# Глава 2. Преобразование типов.

[Раздел 2.1. Приведение числовых примитивов.](#раздел-21-приведение-числовых-примитивов)

[Раздел 2.2. Основные числовые преобразования.](#раздел-22-основные-числовые-преобразования)

[Раздел 2.3. Приведение нечисловых примитивов.](#раздел-23-приведение-нечисловых-примитивов)

[Раздел 2.4. Приведение объектов.](#раздел-24-приведение-объектов)

[Раздел 2.5. Проверка возможности приведения объекта с помощью метода instanceof.](#раздел-25-проверка-возможности-приведения-объекта-с-помощью-метода-instanceof)

## Раздел 2.1. Приведение числовых примитивов.

Приведение числовых примитивов может осуществляться двумя способами. Неявное или автоматическое приведение происходит, когда исходный тип имеет меньший диапазон, чем целевой тип.<br>
```java
// Неявное приведение
byte byteVar = 42;
short shortVar = byteVar;
int intVar = shortVar;
long longVar = intVar;
float floatVar = longVar;
double doubleVar = floatVar;
```
Явное приведение необходимо делать в тех случаях, когда исходный тип имеет больший диапазон, чем целевой.
```java
// Явное приведение
double doubleVar = 42.0d;
float floatVar = (float) doubleVar;
long longVar = (long) floatVar;
int intVar = (int) longVar;
short shortVar = (short) intVar;
byte byteVar = (byte) shortVar;
```

При приведении примитивов с плавающей запятой (`float`, `double`) к примитивам целых чисел исходное число округляется в меньшую сторону.

[к оглавлению Глава 2](#глава-2-преобразование-типов)

## Раздел 2.2. Основные числовые преобразования.

```java
static void testNumericPromotion() {
    char char1 = 1, char2 = 2;
    short short1 = 1, short 2 = 2;
    int int1 = 1, int 2 = 2;
    float float1 = 1.0f, float2 = 2.0f;
    
    // char1 = char1 + char2;       // Ошибка: Невозможно преобразовать из int в char;
    // short1 = short1 + short2;    // Ошибка: Невозможно преобразовать из int в short;
    int1 = char1 + char2;           // char преобразуется в int.
    int1 = short1 + short2;         // short переводится в int.
    int1 = char1 + short2;          // и char, и short преобразуются в int.
    float1 = short1 + float2;       // short преобразуется в float
    int1 = int1 + int2;             // int не изменяется.
}
```
[к оглавлению Глава 2](#глава-2-преобразование-типов)

## Раздел 2.3. Приведение нечисловых примитивов.

Тип `boolean` не может быть приведён к/от любого другого примитивного типа.

Тип `char` может быть приведён к любому числовому типу с помощью сопоставления кодовых точек, определенных в системе кодирования Unicode. Кодовая точка - это значение в кодовом пространстве Unicode, то есть диапазон целых чисел от 0 до 0x10FFFF. В памяти `char` представляется как беззнаковое 16-битное целое значение (2 байта), поэтому приведение к типу `byte` (1 байт) приведёт к потере 8 битов (это безопасно для ASCII-символов). В служебных методах класса `Character` для передачи в/из значений кодовой точки используется `int` (4 байта), но для хранения кодовой точки Unicode вполне достаточно и значения типа `short` (2 байта).

```java
int badInt      = (int)     true;   // Ошибка компилятора: несовместимые типы
char char1      = (char)    65;     // A
byte byte1      = (byte)    'A';    // 65
short short1    = (short)   'A';    // 65
int int1        = (int)     'A';    // 65

char char2      = (char)    8253;   // ?
byte byte2      = (byte)    '?';    // 61 (усеченная кодовая точка в ASCII диапазоне)
short short2    = (short)   '?';    // 8253
int int2        = (int)     '?';    // 8253
```
[к оглавлению Глава 2](#глава-2-преобразование-типов)

## Раздел 2.4. Приведение объектов.

Как и в случае с примитивами, объекты могут быть приведены как явно (автоматически), так и неявно.

Неявное приведение происходит, когда исходный тип является классом-наследником (образованным при помощи ключевого слова extends от целевого) или классом-наследником интерфейса (образованным при помощи ключевого слова imlements от целевого) (приведение к суперклассу ил интерфейсу).

Явное приведение должно выполнять в обратных случаях, когда исходный тип является родителем для целевого типа (приведение к подтипу). Это может привести к возникновению исключения (ClassCastException), если приводимый объект не принадлежит целевому типу (или его подтипу).

```java
Float floatVar = new Float(42.0f);
Number n = floatVar;                // Неявное приведение (Float является имплементацией Number)
Float floatVar2 = (Float) n;        // Явное приведение
Double doubleVar = (Double) n;      // Вызывает исключение (объект не является Double)
```
[к оглавлению Глава 2](#глава-2-преобразование-типов)

## Раздел 2.5. Проверка возможности приведения объекта с помощью метода instanceof.

Java предоставляет метод **instanceof** для проверки принадлежности объекта к определённому типу или подклассу этого типа. Затем программа может выбрать, приводить или не приводить этот объект.

```java
Object obj = Calendar.getInstance();
long time = 0;

if (obj instanceof Calendar) {
    time = ((Calendar)obj).getTime();
}
if (obj instanceof Date) {
    time = ((Date)obj).getTime();    // Эта строка никогда не будет достигнута
}                                    // поскольку obj не является типом Date
```
[к оглавлению Глава 2](#глава-2-преобразование-типов)