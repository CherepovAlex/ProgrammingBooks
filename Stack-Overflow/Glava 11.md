# Глава 11. Строки

Строки (`java.lang.String`) - это фрагменты текста, хранящиеся в вашей программе. Строка не являются примитивным типом данных в Java, однако они очень часто встречаются в процессе написания программ на Java.

В языке Java строки относятся к неизменяемым типам данных, то есть их нельзя изменить. (Более подробное объяснение понятия неизменяемости можно найти по адресу http://stackoverflow.com/questions/279507/what-is-meant-by-immutable).

## Раздел 11.1 Сравнение строк

Для сравнения строк на равенство следует использовать методы `equals` или `equalsIgnoreCase` объекта `String`. Например, следующий фрагмент программы определяет, равны ли два экземпляра `String` по всем входящим в них символам:

```java
String firstString = "Test123";
String secondString = "Test" + 123;

if (firstString.equals(secondString)) {
    // Обе строки имеют одинаковое содержимое.
}
```

Вы можете запустить эту программу онлайн на сайте ideone.com, перейдя по ссылке (https://ideone.com/TjaYMR).

В данном примере будет проведено сравнение строк, не зависящее от того, в каком регистре набраны символы:

```java
String firstString = "Test123";
String secondString = "TEST123";

if (firstString.equalsIgnoreCase(secondString)) {
    // Обе строки равны, без учета регистра отдельных символов.
}
```

Вы можете запустить эту программу онлайн на сайте ideone.com, перейдя по ссылке (https://ideone.com/XxKmM1).

Обратите внимание, что метод `equalsIgnoreCase` не позволяет задать параметр `Locale`. Например, если сравнить два слова "Taki" и "TAKI" в английском языке, то они будут одинаковыми, но в турецком языке они будут разными (в турецком языке строчная буква I - l). В подобных случаях решением является преобразование обеих строк в нижний (или верхний) регистр с применением возможностей класса `Locale` и последующее сравнение строк с помощью метода `equals`.

```java
import java.util.Locale;

String firstString = "Taki";
String secondString = "TAKI";

System.out.println(firstString.equalsIgnoreCase(secondString));     // выводит true

Locale locale = Locale.forLanguageTag("tr - TR");

System.out.println(firstString.toLowerCase(locale).equals(
                   secondString.toLowerCase(locale)));  // выводит false
```

Вы можете запустить эту программу онлайн на сайте ideone.com, перейдя по ссылке (https://ideone.com/uWc348).

**Не используйте оператор == для сравнения строк**

Не следует использовать операторы `==` или `!=` для сравнения строк, если вы не можете гарантировать, что все строки не были интернированы (см. ниже). Эти операторы фактически проверяют ссылки, а поскольку несколько объектов `String` могут представить одну и ту же строку, это может привести к неправильному результату.

Вместо этого следует использовать метод `String.equals(Object)`, который будет сравнивать объекты `String` на основе их значений. Более подробное объяснение приведено в разделе "Ловушка: использовать `==` для сравнения строк".

**Сравнение строк в операторе switch**

_Версия >= Java SE 7_

Начиная с версии Java 1.7, в операторе **switch** можно сравнивать переменную `String` с литералами. При этом необходимо убедиться, что `String` не является значением `null`, иначе всегда будет возникать исключение `NullPointerException`. Значения сравниваются с помощью метода `String.equals`, т.е. с учетом регистра.

```java
String stringToSwitch = "A";

switch (stringToSwitch) {
    case "a":
        System.out.println("a");
        break;
    case "A":
        System.out.println("A");    // код идет здесь
        break;
    case "B":
        System.out.println("B");
        break;
    deafault:
        break;    
}
```

Вы можете запустить эту программу онлайн на сайте ideone.com, перейдя по ссылке (https://ideone.com/fbWBUR).

**Сравнение строк с константами**

При сравнении строки со строками-константами можно поместить константное значение в левую часть метода `equals`, чтобы не получить исключение `NullPointerException`, если другая строка равна значению `null`.

```java
"baz".equals(foo);
```

В то время как `foo.equals("baz")` вызовет исключение `NullPointerException`, если `foo` будет равно `null`, значение `"baz".equals(foo)` не вызовет исключение, а будет равно `false`.

_Версия >= Java SE 7_

Более удобной альтернативой использование метода `Objects.equals()`, которая проверяет оба параметра на равенство значению `null`:

```java
Objects.equals(foo, "baz").
```

_Примечание_: спорным является вопрос о том, хорошо ли вообще избегать исключений `NullPointerException`, или лучше позволить им произойти, а затем устранить первопричину, их вызывающую. И само собой разумеется, назвать стратегию избегания "лучшей практикой" не вполне правомерно.

**Упорядочивание строк**

Класс `String` реализует интерфейс `Comparable<String>` с содержащимся в нем методом `String.compareTo()` (как описано в начале этого примера). Это делает естественное упорядочивание объектов `String` чувствительным к регистру. Класс `String` предоставляет константу `CASE_INTENSITIVE_ORDER`, которая принадлежит интерфейсу `Comparator<String>`, и предназначена для сортировки строк без учета регистра.

**Сравнение с интернированными строками**

В спецификации языка Java (JLS 3.10.6) говорится следующее:

"Более того, строковый литерал всегда ссылается на один и тот же экземпляр класса `String`. Это объясняется тем, что строковые литералы или, в более общем случае, строки являющиеся константами, _интернируются_ так, чтобы разделять между собой ссылку на уникальный экземпляр, с помощью метода `String.intern`".

Это означает, что можно сравнивать ссылки на два строковых литерала с помощью оператора `==`. Более того, что это справедливо и для ссылок на объекты `String`, созданные с помощью метода `String.intern()`. Например:

```java
String strObj = new String("Hello!");
String str = "Hello!";

// Две ссылки на объект String указывают на две одинаковые строки
if (strObj.equals(str)) {
    System.out.println("Строки равны");
}

// Две строковые ссылки не указывают на один и тот же объект
if (strObj != str) {
    System.out.println("Строки не являются одним и тем же объектом");
}

// Если мы интернируем строку, которая равна заданному литералу, то в результате
// получим строку, имеющую ту же ссылку, что и литерал.
String internedStr = strObj.intern();

if (internedStr == str) {
    System.out.println("Интернированная строка и литерал являются одним и тем же объектом");
}
```

За кулисами механизм интернирования ведёт хеш-таблицу, содержащую все интернированные строки, которые все ещё _достижимы_. Когда вы вызываете функцию `intern()` для строки `String`, метод ищет объект в хеш-таблице:
+ Если строка найдена, то это значение возвращается как интернированная строка.
+ В противном случае копия строки добавляется в хеш-таблицу и эта строка возвращается в качестве интернированной строки.

Можно использовать интернирование для сравнения строк с помощью оператора `==`. Однако при этом возникают серьёзные проблемы; подробнее об этом см. в разделе "Ловушка - применение оператора `==` для интернированных строк - плохое решение". В большинстве случаев такая реализация не рекомендуется.

[к оглавлению Глава 11](#глава-11-строки)

## Раздел 11.2. Изменение регистра символов в строке

Тип `String` предоставляет два метода преобразования строк к верхнему и нижнему регистру:
+ `toUpperCase` для преобразования всех символов в строке к верхнему регистру.
+ `toLowerCase` для преобразования всех символов в строке к нижнему регистру.

Оба этих метода возвращают преобразованные строки в виде новых экземпляров `String`: исходные объекты `String` не изменяются, поскольку `String` в Java принадлежит к неизменяемому типу данных. Подробнее можно ознакомиться здесь: (http://stackoverflow.com/questions/1552301/immutability-of-strings-in-java)

```java
String string = "This is a Random String";
String upper = string.toUpperCase();
String lower = string.toLowerCase();

System.out.println(string); // выводит сообщение "This is a Random String"  
System.out.println(lower); // выводит сообщение "this is a random string"
System.out.println(upper); // выводит сообщение "THIS IS A RANDOM STRING"
```

На неалфавитные символы, такие как цифры и знаки препинания, эти методы не влияют. Следует отметить, что при определённых условиях эти методы могут некорректно работать с некоторыми символами Unicode.

_Примечание_: эти методы _чувствительны к объектам Locale (отвечающих за локализацию программы)_ и могут привести к неожиданным результатам, если используются для строк, которые должны интерпретироваться независимо от локализации. Примерами могут служить идентификаторы языков программирования, ключи протоколов и HTML-теги.

Например, `"TITLE".toLowerCase()` в турецкой локализации возвращает `"tltle"`, где `l` `(\u0131)` - латинский малый буквенный символ I без точки. Чтобы получить корректные результаты для строк, нечувствительных к локализации, передайте параметр `Locale.ROOT` в качестве параметра соответствующему методы преобразования регистра (например, `toLowerCase(Locale.ROOT)` или `toUpperCase(Locale.ROOT`)). 

Хотя использование параметра `Locale.ENGLISH` будет корректно для большинства случаев, способом, инвариантным к языку, является использование параметра `Locale.ROOT`.

Подробный список символов Unicode, для которых требуется специальная обработка, можно найти на сайте Консорциума Unicode (http://unicode.org/Public/UNIDATA/SpecialCasing.txt)

**Изменение регистра заданного символа в строке ASCII**

Для изменения регистра определённого символа в ASCII-строке можно использовать следующий алгоритм:

Шаги:

1. Объявите строку.
2. Введите строку.
3. Преобразуйте строку в массив символов.
4. Введите символ, по которому будет производиться поиск.
5. Осуществите поиск символа в массиве символов.
6. Если символ не найден, проверьте, является ли он строчным или прописным.
   + Если символ прописной, то к его коду ASCII следует прибавить 32.
   + Если используется нижний регистр, то из кода ASCII символа вычитается 32.
7. Замените исходный символ из массива символов на требуемый.
8. Преобразуйте массив символов обратно в строку.

Вуаля, регистр символов изменён. Ниже приведён фрагмент кода, реализующий данные алгоритм:

```java
import java.util.Scanner;

Scanner scanner = new Scanner(System.in);
System.out.println("Введите строку");
String s = scanner.next();
char[] a = s.toCharArray();
System.out.println("Введите искомый символ");
System.out.println(s);
String c = scanner.next();
char d = c.charAt(0);

for (int i = 0; i <= s.length(); i++) {
    if (a[i] == d) {
        if (d >= 'a' && d <= 'z') {
            d -= 32;
        } else if (d >= 'A' && d <= 'Z') {
            d += 32;
        }
        a[i] = d;
        break;
   }
}
s = String.valueOf(a);
System.out.println(s);
```

[к оглавлению Глава 11](#глава-11-строки)

## Раздел 11.3. Проверка вхождения строки в состав другой строки

Для проверки того, содержится ли конкретная строка `a` в строке `b` или нет, можно воспользоваться методом `String.contains()` со следующим синтаксисом:

```java
b.contains(a);  // Возвращается true, если a содержится в b, false - в противном случае
```

Метод `String.contains()` может быть использован для проверки того, входит ли в строку заданная последовательность символов. Метод проверяет вхождение строки `a` в строку `b` с учетом регистра.

```java
String str1 = "Hello World";
String str2 = "Hello"; String str3 = "helLo";

System.out.println(str1.contains(str2));    // выведет true
System.out.println(str1.contains(str3));    // выведет false
```

Вы можете запустить эту программу онлайн на сайте ideone.com, перейдя по ссылке (https://ideone.com/Tdef6b).

Чтобы найти точное место, с которого начинается вхождение одной строки в другую строку, используйте метод `String.indexOf()`:

```java
String s = "this is a long sentence";
int i = s.indexOf('i');     // первая буква 'i' в строке находится по индексу 2
int j = s.indexOf("long");  // индекс первого вхождения слова "long" в строку s равен 10
int k = s.indexOf('z');     // k равен -1, так как 'z' не было найдено в строке s
int h = s.indexOf("LoNg");  // h равно -1, так как слово "LoNg" не было найдено в строке s 
```

Вы можете запустить эту программу онлайн на сайте ideone.com, перейдя по ссылке (https://ideone.com/RHHcF0).

Метод `String.indexOf() возвращает индекс первого вхождения символа или строки в другую строку. Если символ или строка не входят в данную строку, метод возвращает значение `-1`. 

_Примечание_: метод `String.indexOf()` чувствителен к регистру. Пример поиска с игнорированием регистра:

```java
String str1 = "Hello World";
String str2 = "wOr";
str1.indexOf(str2);     //  -1
str1.toLowerCase().contains(str2.toLowerCase());    // true
str1.toLowerCasw().indexOf(str2.toLowerCase());     // 6
```

Вы можете запустить эту программу онлайн на сайте ideone.com, перейдя по ссылке (https://ideone.com/TQtcMf).

[к оглавлению Глава 11](#глава-11-строки)

## Раздел 11.4. Пул строк и область памяти Java Heap



[к оглавлению Глава 11](#глава-11-строки)

[Раздел 11.1. Сравнение строк](#раздел-111-сравнение-строк)

[Раздел 11.2. Изменение регистра символов в строке](#раздел-112-изменение-регистра-символов-в-строке)

[Раздел 11.3. Проверка вхождения строки в состав другой строки](#раздел-113-проверка-вхождения-строки-в-состав-другой-строки)

[Раздел 11.4. Пул строк и область памяти Java Heap](#раздел-114-пул-строк-и-область-памяти-java-heap)

















