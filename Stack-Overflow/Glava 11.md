# Глава 11. Строки

Строки (`java.lang.String`) - это фрагменты текста, хранящиеся в вашей программе. Строка не являются примитивным типом данных в Java, однако они очень часто встречаются в процессе написания программ на Java.

В языке Java строки относятся к неизменяемым типам данных, то есть их нельзя изменить. (Более подробное объяснение понятия неизменяемости можно найти по адресу http://stackoverflow.com/questions/279507/what-is-meant-by-immutable).

## Раздел 11.1 Сравнение строк

Для сравнения строк на равенство следует использовать методы `equals` или `equalsIgnoreCase` объекта `String`. Например, следующий фрагмент программы определяет, равны ли два экземпляра `String` по всем входящим в них символам:

```java
String firstString = "Test123";
String secondString = "Test" + 123;

if (firstString.equals(secondString)) {
    // Обе строки имеют одинаковое содержимое.
}
```

Вы можете запустить эту программу онлайн на сайте ideone.com, перейдя по ссылке (https://ideone.com/TjaYMR).

В данном примере будет проведено сравнение строк, не зависящее от того, в каком регистре набраны символы:

```java
String firstString = "Test123";
String secondString = "TEST123";

if (firstString.equalsIgnoreCase(secondString)) {
    // Обе строки равны, без учета регистра отдельных символов.
}
```

Вы можете запустить эту программу онлайн на сайте ideone.com, перейдя по ссылке (https://ideone.com/XxKmM1).

Обратите внимание, что метод `equalsIgnoreCase` не позволяет задать параметр `Locale`. Например, если сравнить два слова "Taki" и "TAKI" в английском языке, то они будут одинаковыми, но в турецком языке они будут разными (в турецком языке строчная буква I - l). В подобных случаях решением является преобразование обеих строк в нижний (или верхний) регистр с применением возможностей класса `Locale` и последующее сравнение строк с помощью метода `equals`.

```java
import java.util.Locale;

String firstString = "Taki";
String secondString = "TAKI";

System.out.println(firstString.equalsIgnoreCase(secondString));     // выводит true

Locale locale = Locale.forLanguageTag("tr - TR");

System.out.println(firstString.toLowerCase(locale).equals(
                   secondString.toLowerCase(locale)));  // выводит false
```

Вы можете запустить эту программу онлайн на сайте ideone.com, перейдя по ссылке (https://ideone.com/uWc348).

**Не используйте оператор == для сравнения строк**

Не следует использовать операторы `==` или `!=` для сравнения строк, если вы не можете гарантировать, что все строки не были интернированы (см. ниже). Эти операторы фактически проверяют ссылки, а поскольку несколько объектов `String` могут представить одну и ту же строку, это может привести к неправильному результату.

Вместо этого следует использовать метод `String.equals(Object)`, который будет сравнивать объекты `String` на основе их значений. Более подробное объяснение приведено в разделе "Ловушка: использовать `==` для сравнения строк".

**Сравнение строк в операторе switch**

_Версия >= Java SE 7_

Начиная с версии Java 1.7, в операторе **switch** можно сравнивать переменную `String` с литералами. При этом необходимо убедиться, что `String` не является значением `null`, иначе всегда будет возникать исключение `NullPointerException`. Значения сравниваются с помощью метода `String.equals`, т.е. с учетом регистра.

```java
String stringToSwitch = "A";

switch (stringToSwitch) {
    case "a":
        System.out.println("a");
        break;
    case "A":
        System.out.println("A");    // код идет здесь
        break;
    case "B":
        System.out.println("B");
        break;
    deafault:
        break;    
}
```

Вы можете запустить эту программу онлайн на сайте ideone.com, перейдя по ссылке (https://ideone.com/fbWBUR).

**Сравнение строк с константами**

При сравнении строки со строками-константами можно поместить константное значение в левую часть метода `equals`, чтобы не получить исключение `NullPointerException`, если другая строка равна значению `null`.

```java
"baz".equals(foo);
```

В то время как `foo.equals("baz")` вызовет исключение `NullPointerException`, если `foo` будет равно `null`, значение `"baz".equals(foo)` не вызовет исключение, а будет равно `false`.

_Версия >= Java SE 7_

Более удобной альтернативой использование метода `Objects.equals()`, которая проверяет оба параметра на равенство значению `null`:

```java
Objects.equals(foo, "baz").
```

_Примечание_: спорным является вопрос о том, хорошо ли вообще избегать исключений `NullPointerException`, или лучше позволить им произойти, а затем устранить первопричину, их вызывающую. И само собой разумеется, назвать стратегию избегания "лучшей практикой" не вполне правомерно.

**Упорядочивание строк**

Класс `String` реализует интерфейс `Comparable<String>` с содержащимся в нем методом `String.compareTo()` (как описано в начале этого примера). Это делает естественное упорядочивание объектов `String` чувствительным к регистру. Класс `String` предоставляет константу `CASE_INTENSITIVE_ORDER`, которая принадлежит интерфейсу `Comparator<String>`, и предназначена для сортировки строк без учета регистра.

**Сравнение с интернированными строками**

В спецификации языка Java (JLS 3.10.6) говорится следующее:

"Более того, строковый литерал всегда ссылается на один и тот же экземпляр класса `String`. Это объясняется тем, что строковые литералы или, в более общем случае, строки являющиеся константами, _интернируются_ так, чтобы разделять между собой ссылку на уникальный экземпляр, с помощью метода `String.intern`".

Это означает, что можно сравнивать ссылки на два строковых литерала с помощью оператора `==`. Более того, что это справедливо и для ссылок на объекты `String`, созданные с помощью метода `String.intern()`. Например:

```java
String strObj = new String("Hello!");
String str = "Hello!";

// Две ссылки на объект String указывают на две одинаковые строки
if (strObj.equals(str)) {
    System.out.println("Строки равны");
}

// Две строковые ссылки не указывают на один и тот же объект
if (strObj != str) {
    System.out.println("Строки не являются одним и тем же объектом");
}

// Если мы интернируем строку, которая равна заданному литералу, то в результате
// получим строку, имеющую ту же ссылку, что и литерал.
String internedStr = strObj.intern();

if (internedStr == str) {
    System.out.println("Интернированная строка и литерал являются одним и тем же объектом");
}
```

За кулисами механизм интернирования ведёт хеш-таблицу, содержащую все интернированные строки, которые все ещё _достижимы_. Когда вы вызываете функцию `intern()` для строки `String`, метод ищет объект в хеш-таблице:
+ Если строка найдена, то это значение возвращается как интернированная строка.
+ В противном случае копия строки добавляется в хеш-таблицу и эта строка возвращается в качестве интернированной строки.

Можно использовать интернирование для сравнения строк с помощью оператора `==`. Однако при этом возникают серьёзные проблемы; подробнее об этом см. в разделе "Ловушка - применение оператора `==` для интернированных строк - плохое решение". В большинстве случаев такая реализация не рекомендуется.

[к оглавлению Глава 11](#глава-11-строки)

## Раздел 11.2. Изменение регистра символов в строке

Тип `String` предоставляет два метода преобразования строк к верхнему и нижнему регистру:
+ `toUpperCase` для преобразования всех символов в строке к верхнему регистру.
+ `toLowerCase` для преобразования всех символов в строке к нижнему регистру.

Оба этих метода возвращают преобразованные строки в виде новых экземпляров `String`: исходные объекты `String` не изменяются, поскольку `String` в Java принадлежит к неизменяемому типу данных. Подробнее можно ознакомиться здесь: (http://stackoverflow.com/questions/1552301/immutability-of-strings-in-java)

```java
String string = "This is a Random String";
String upper = string.toUpperCase();
String lower = string.toLowerCase();

System.out.println(string); // выводит сообщение "This is a Random String"  
System.out.println(lower); // выводит сообщение "this is a random string"
System.out.println(upper); // выводит сообщение "THIS IS A RANDOM STRING"
```

На неалфавитные символы, такие как цифры и знаки препинания, эти методы не влияют. Следует отметить, что при определённых условиях эти методы могут некорректно работать с некоторыми символами Unicode.

_Примечание_: эти методы _чувствительны к объектам Locale (отвечающих за локализацию программы)_ и могут привести к неожиданным результатам, если используются для строк, которые должны интерпретироваться независимо от локализации. Примерами могут служить идентификаторы языков программирования, ключи протоколов и HTML-теги.

Например, `"TITLE".toLowerCase()` в турецкой локализации возвращает `"tltle"`, где `l` `(\u0131)` - латинский малый буквенный символ I без точки. Чтобы получить корректные результаты для строк, нечувствительных к локализации, передайте параметр `Locale.ROOT` в качестве параметра соответствующему методы преобразования регистра (например, `toLowerCase(Locale.ROOT)` или `toUpperCase(Locale.ROOT`)). 

Хотя использование параметра `Locale.ENGLISH` будет корректно для большинства случаев, способом, инвариантным к языку, является использование параметра `Locale.ROOT`.

Подробный список символов Unicode, для которых требуется специальная обработка, можно найти на сайте Консорциума Unicode (http://unicode.org/Public/UNIDATA/SpecialCasing.txt)

**Изменение регистра заданного символа в строке ASCII**

Для изменения регистра определённого символа в ASCII-строке можно использовать следующий алгоритм:

Шаги:

1. Объявите строку.
2. Введите строку.
3. Преобразуйте строку в массив символов.
4. Введите символ, по которому будет производиться поиск.
5. Осуществите поиск символа в массиве символов.
6. Если символ не найден, проверьте, является ли он строчным или прописным.
   + Если символ прописной, то к его коду ASCII следует прибавить 32.
   + Если используется нижний регистр, то из кода ASCII символа вычитается 32.
7. Замените исходный символ из массива символов на требуемый.
8. Преобразуйте массив символов обратно в строку.

Вуаля, регистр символов изменён. Ниже приведён фрагмент кода, реализующий данные алгоритм:

```java
import java.util.Scanner;

Scanner scanner = new Scanner(System.in);
System.out.println("Введите строку");
String s = scanner.next();
char[] a = s.toCharArray();
System.out.println("Введите искомый символ");
System.out.println(s);
String c = scanner.next();
char d = c.charAt(0);

for (int i = 0; i <= s.length(); i++) {
    if (a[i] == d) {
        if (d >= 'a' && d <= 'z') {
            d -= 32;
        } else if (d >= 'A' && d <= 'Z') {
            d += 32;
        }
        a[i] = d;
        break;
   }
}
s = String.valueOf(a);
System.out.println(s);
```

[к оглавлению Глава 11](#глава-11-строки)

## Раздел 11.3. Проверка вхождения строки в состав другой строки

Для проверки того, содержится ли конкретная строка `a` в строке `b` или нет, можно воспользоваться методом `String.contains()` со следующим синтаксисом:

```java
b.contains(a);  // Возвращается true, если a содержится в b, false - в противном случае
```

Метод `String.contains()` может быть использован для проверки того, входит ли в строку заданная последовательность символов. Метод проверяет вхождение строки `a` в строку `b` с учетом регистра.

```java
String str1 = "Hello World";
String str2 = "Hello"; String str3 = "helLo";

System.out.println(str1.contains(str2));    // выведет true
System.out.println(str1.contains(str3));    // выведет false
```

Вы можете запустить эту программу онлайн на сайте ideone.com, перейдя по ссылке (https://ideone.com/Tdef6b).

Чтобы найти точное место, с которого начинается вхождение одной строки в другую строку, используйте метод `String.indexOf()`:

```java
String s = "this is a long sentence";
int i = s.indexOf('i');     // первая буква 'i' в строке находится по индексу 2
int j = s.indexOf("long");  // индекс первого вхождения слова "long" в строку s равен 10
int k = s.indexOf('z');     // k равен -1, так как 'z' не было найдено в строке s
int h = s.indexOf("LoNg");  // h равно -1, так как слово "LoNg" не было найдено в строке s 
```

Вы можете запустить эту программу онлайн на сайте ideone.com, перейдя по ссылке (https://ideone.com/RHHcF0).

Метод `String.indexOf()` возвращает индекс первого вхождения символа или строки в другую строку. Если символ или строка не входят в данную строку, метод возвращает значение `-1`. 

_Примечание_: метод `String.indexOf()` чувствителен к регистру. Пример поиска с игнорированием регистра:

```java
String str1 = "Hello World";
String str2 = "wOr";
str1.indexOf(str2);     //  -1
str1.toLowerCase().contains(str2.toLowerCase());    // true
str1.toLowerCasw().indexOf(str2.toLowerCase());     // 6
```

Вы можете запустить эту программу онлайн на сайте ideone.com, перейдя по ссылке (https://ideone.com/TQtcMf).

[к оглавлению Глава 11](#глава-11-строки)

## Раздел 11.4. Пул строк и область памяти Java Heap

Как и многие другие объекты Java, все экземпляры `String` и даже литералы создаются в области памяти, которая получила название `Java Heap` - куча. Когда JVM находит литерал `String`  в куче, а также сохраняет ссылку на вновь созданный экземпляр `String` в пуле строк. Все остальные ссылки на тот же литерал `String` заменяются в куче ранее созданным экземпляром `String`.

Рассмотрим следующий пример:

```java
class String {
    public static void main(String[] args) {
        String a = "alpha";
        String b = "alpha";
        String c = new String("alpha");
        
        // Все три строки эквивалентны
       System.out.println(a.equals(b) && b.equals(c));
       
       // Несмотря на то, что только a и b ссылаются на один и тот же объект кучи
       System.out.println(a == b);
       System.out.println(a != c);
       System.out.println(b != c);
    }
}
```

В результате программа выдаст следующий результат:

```java
true
true
true
true
```

![img.png](img.png)

Когда мы используем двойные кавычки для создания строки, то в пуле строк сначала ищется строка с таким же значение и если она найдена, то просто возвращается ссылка на нее, иначе в пуле создаётся новая строка, а затем возвращается ссылка на новую строку.

Используя же оператор `new`, мы заставляем класс `String` создать новый объект `String` в пространстве кучи. Мы можем использовать метод `intern()`, чтобы поместить его в пул, или обратиться к другому объекту `String` из пула строка с тем де значением.

Сам пул строк также создаётся в куче.

_Версия < Java SE 7_

До появления Java 7 литералы `String` хранились в пуле констант, создаваемых во время выполнения программы, который в свою очередь находился в области памяти методов. Это область памяти называлась `PermGen` и имела фиксированный размер. Пул строк также находился в `PermGen`.

_Версия >= Java SE 7_

RFC: 6962931

В JDK 7 интернированные строки больше не хранятся в области памяти методов `PermGen`, а располагаются в основной части общей кучи Java (известно как младшая и старшая модель распределения памяти) вместе с другими объектами, созданными приложением. Это изменение привело к тому, что в основной части кучи Java стало находиться больше данных, а в пространстве `PermGen` - меньше, и поэтому может потребоваться перераспределение размеров кучи. Для большинства приложений это изменение привело лишь к относительно небольшой разнице в использовании кучи, но в больших приложениях, в которых в память подгружается много классов или активно используется метод `String.intern()`, эта разница была более существенной.

[к оглавлению Глава 11](#глава-11-строки)

## Раздел 11.5. Разделение строк на подстроки

Разделить строку, используя в качестве разделителя символ или регулярное выражение, можно с помощью метода `String.split()`, имеющего следующую сигнатуру:

```java
public String[] split(String regex)
```

Обратите внимание на то, что из результирующего массива строк удаляется разделительный символ или регулярное выражение, по которым происходило разделение исходной строки.

Пример использования в качестве разделителя символа `";"`:

```java
String lineFromCsvFile = "Mickey;Bolton;12345;121216";
String[] dataCells = lineFromCsvFile.split(";");
// Результат - dataCells = {"Mickey", "Bolton", "12345", "121216"};
```

Пример использования в качестве разделителя регулярного выражения:

```java
String lineFromInput = "What do you need for me?";
String[] words = lineFromInput("\\\s+");
// один или несколько пробельных символов
// Результат - слова = {"What", "do", "you", "need", "from", "me?"};
```

Можно даже напрямую разделить строковый литерал:

```java
String[] firstNames = "Mickey, Frank, Alicia, Tom".split(", ");
// Результат - firstNames = {"Mickey", "Frank", "Alicia", "Tom"};
```

_Внимание:_ Не забывайте, что параметр в методе всегда рассматривается как регулярное выражение.

```java
"aaa.bbb".split(".");   // В этом случае метод вернёт пустой массив
```

В предыдущем примере `"."` рассматривается как знак шаблона для регулярного выражения, который соответствует любому символу, а так как каждый символ является разделителем, то результатом будет пустой массив.

**Разделение на основе разделителя, являющегося метасимволом в регулярном выражении**

В регулярном выражении используется ряд специальных символов, которые иначе называют мета-символами. Это:

` < > - = ! ( ) [ ] { } \ ^ $ | ? * + .`

Чтобы разделить строку на основе одного из указанных выше разделителей, необходимо _экранировать_ их с помощью `\\`, либо использовать метод `Pattern.quote()`:
+ Использование метода `Pattern.quote()`:

```java
import java.util.regex.Pattern;

String s = "a|b|c";
String regex = Pattern.quote("|");
String[] arr = s.split(regex);
```

+ Экранирование специальных символов:

```java
String s = "a|b|c";
String[] arr = s.split("\\|");
```

**Удаление пробелов или пустых строк с помощью метода split**

Метод `split` (разделитель) по умолчанию удаляет из результирующего массива строк завершающие пробелы. Чтобы отключить этот механизм, необходимо воспользоваться перегруженной версией метода `split (delimeter, limit)`, задав при этом в качестве дополнительного параметра `limit` отрицательное значение, например, следующим образом:

```java
String[] split = data.split("\\|", -1);
```

Метод `split(regex)` без второго параметра возвращает результат выполнения `split(regex, 0)`.

Параметр `limit` определяет, какое количество раз шаблон `regex` будет применяться к исходной строке и, следовательно, влияет на длину результирующего массива.

Если параметр `limit` установить равным числу `n > 0`, то шаблон будет применён по крайней мере `n - 1` раз, и длина результирующего массива не превысит `n`, а последний элемент массива будет содержать часть входной строки, расположенную за последним найденным разделителем.

Если `n` отрицательно, то шаблон будет применён столько раз, сколько это возможно, и выходной массив может иметь любую длину.

Если `n` равно нулю, то шаблон будет применен столько раз, сколько это возможно, выходной массив может иметь любую длину, а пустые строки, расположенные в конце исходной строки, будут отброшены.

**Разделение строки с помощью методов класса StringTokenizer**

Кроме метода `split()` строки могут быть разделены с помощью методов класса `StringTokenizer`.

Методы класса `StringTokenizer` ещё более строги, чем метод `String.split()`, а также несколько сложнее в использовании. По сути, этот класс предназначен для извлечения лексем, разделённых фиксированным набором символов (заданных в виде строки). Каждый символ будет выступать в роли разделителя. Из-за этого ограничения он работает примерно в два раза быстрее, чем метод `String.split()`.

Набор символов по умолчанию - символ пробела и управляющие символы `(\t\n\r\f)`. В следующем примере отдельно будет выведено каждое слово исходной строки.

```java
import java.util.StringTokenizer;

String str = "tha lazy fox jumped over the brown fence";
StringTokenizer tokenizer = new StringTokenizer(str);
while (tokenizer.hasMoreTokens()) {
    System.out.println(tokenizer.nextToken());
}
```

В результате работы программы на экран будет выведено:
```bash
the
lazy
foz
jumped
over
the 
brown
fence
```

Для разделения исходной строки можно использовать различные наборы символов:

```java
import java.util.StringTokenizer;

String str = "jumped over";
// В данном случае в качестве разделителей будут использоваться символы 'u' и 'e'
StringTokenizer tokenizer = new StringTokenizer(str, "ue");
while (tokenizer.hasMoreTokens()) {
    System.out.println(tokenizer.nextToken());
}
```

В результате будет выведено:

```bash
j
mp
d ov
r
```

[к оглавлению Глава 11](#глава-11-строки)

## Раздел 11.6. Объединение строк с помощью разделителя

_Версия >= Java SE 8_

Массив строк может быть объединён с помощью статического метода `String.join()`:

```java
String[] elements = {"foo", "bar", "foobar"};
String singleString = String.join(" + ", elements);

System.out.println(singleString);   // Печатается "foo + bar + foobar"
```

Аналогично, для интерфейса `Iterable` существует перегруженный метод `String.join()`.

Для более тонкого контроля над объединением строк можно использовать класс `StringJoiner`:

```java
import java.util.StringJoiner;

StringJoiner sj = new StringJoiner(", ", "[", "]");
    // Последние два аргумента являются необязательными
    // они определяют префикс и суффикс для результирующей строки

sj.add("foo");
sj.add("bar");
sj.add("foobar");

System.out.println(sj);     // Выводит "[foo, bar, foobar]".
```

Для объединения потока строк можно использовать метод `Collectors.joining()`. Более подробно ознакомиться с ним можно, перейдя по адресу (https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#joining-java.lang.CharSequence-).

```java
import java.util.stream.Collectors;
import java.util.stream.Stream;

Stream<String> stringStream = Stream.of("foo", "bar", "foobar");
String joined = stringStream.collect(Collectors.joining(", "));
System.out.println(joined);     // Выводит "foo, bar, foobar".
```

В этом методе также есть возможность определить префикс и суффикс:

```java
import java.util.stream.Collectors;
import java.util.stream.Stream;

Stream<String> stringStream = Stream.of("foo", "bar", "foobar");
String joined = stringStream.collect(Collectors.joining(",", "{", "}"));
System.out.println(joined);     // Выводит "{foo, bar, foobar}".
```

[к оглавлению Глава 11](#глава-11-строки)

## Раздел 11.7. Конкатенация строк и класс StringBuilder

Конкатенацию строк в Java можно выполнить с помощью оператора `+`. Например:

```java
String s1 = "a";
String s2 = "b";
String s3 = "c";
String s = s1 + s2 + s3;    // abc
```

Обычно компилятор выполняет указанную конкатенацию с помощью методов, включающих в себя класс `StringBuilder` под капотом. При компиляции код будет выглядеть примерно так, как показано ниже:

```java
StringBuilder sb = new StringBuilder("a");
String s = sb.append("b").append("c").toString();
```

Класс `StringBuilder` имеет несколько перегруженных методов для добавления в результирующую строку различных типов данных, например, для добавления **int** вместо `String`. Например, следующая последовательность операторов:

```java
String s1 = "a";
String s2 = "b";
String s = s1 + s2 + 2; // ab2
```

соответствует следующему фрагменту кода:

```java
StringBuilder sb = new StringBuilder("a");
String s = sb.append("b").append(2).toString();
```

Приведённые примеры иллюстрируют, насколько проста операция конкатенации, которую можно эффективно применять в любом месте кода. В конкатенации участвует один экземпляр `StringBuilder`. В некоторых случаях конкатенация выполняет по накопительному принципу, например, в следующем цикле:

```java
String result = "";
for (int i = 0; i < array.length; i++) {
    result += extractElement(array[i]);
}
return result;
```

В таких случаях компилятор обычно не применяет оптимизацию, и на каждой итерации будет создаваться новый объект `StringBuilder`. Оптимизировать этот фрагмент можно путём явного преобразования кода. Основная цель оптимизации - использование единственного объекта `StringBuilder`:

```java
StringBuiilder result = new StringBuilder();
for (int i = 0; i < array.length; i++) {
    result.append(extractElement(array[i]));
}
return result.toString();
```

Объект `StringBuilder` инициализируется с зарезервированным пространством всего в 16 символов. Если вы заранее знаете, что будете создавать строки большого размера, то более эффективным решением будет инициализировать его с размером, достаточным для того, чтобы в ходе работы программы не пришлось изменять размер внутреннего буфера:

```java
StringBuilder buf = new StringBuilder(30);  // По умолчанию 16 символов
buf.append("0123456789");
buf.append("0123456789");   // Разбиваем на два действия, иначе это привело бы
                            // к изменению размера внутреннего буфера
String result = buf.toString();     // Получается копия строки, содержащая 20 элементов
```

В том случае, если вам необходимо создавать много строк, объект `StringBuilder` можно использовать повторно:

```java
StringBuilder buf = new StringBuilder(100);
for (int i = 0; i < 100; i++) {
    buf.setLength(0);   // Пустой буфер
    buf.append("Это строка ").append(i).append('\n');
    outputfile.write(buf.toString());
}
```

В ситуации, когда несколько потоков записывают данные в один и тот же буфер, но только в этой ситуации, используйте объект класса `StringBuffer`, который является синхронизированной версией `StringBuilder`. Но поскольку обычно в один буфер записывается только один поток, то более эффективным решением с точки зрения быстродействия будет использование объекта `StringBuilder` без синхронизации.

**Использование метода concat()**

```java
String string1 = "Hello";
String string2 = "world";
String string3 = string1.concat(string2);   // "Hello world"
```

Результатом работы программы станет новая строка, которая представляет собой строку `string1` с добавленной вслед за ней второй строкой `string2`. Метод `concat()` можно также использовать со строковыми литералами, например:

`"Меня зовут ".concat("Сергей")`;

[к оглавлению Глава 11](#глава-11-строки)

## Раздел 11.8. Подстроки

```java
String s = "this is an example";
String a = s.substring(11); // строка а теперь содержит подстроку, начинающуюся
                            // с индекса 11 и до конца строки ("example")
String b = s.substring(5, 10);  // в b теперь будет храниться подстрока, начинающаяся с 
                                // символа, размещённого по индексу 5 и заканчивающаяся 
                                // непосредственно перед символом с индексом 10 ("is an")
String b = s.substring(5, b.length() - 3);  // в b будет храниться подстрока,
                                            // начинающаяся с символа, расположенного в исходной
                                            // строке по индексу 5 и заканчивающаяся символом,
                                            // который расположен по индексу, равному длине исходной
                                            // строки минус 3 ("is an exam")
```

Подстроки также могут применяться для разделения исходной строки и добавления/замены символов в исходную строку. Например, вы столкнулись с китайской датой, содержащей китайские символы, но хотите сохранить её в виде строки типа `Date` в правильной форме.

```java
String datestring = "2015f!o11.li17B";
datestring = datestring.substring(0, 4) + "-" + datestring.substring(5, 7) + "-" +
datestring.substring(8, 10);
// Результат будет 2015-11-17
```

Таким образом, метод `substring` извлекает част строки `String`. Если метод вызывается только с одним параметром, то извлекаемый фрагмент начинается с индекса, задаваемого этим параметром и продолжается до конца исходной строки. При вызове метода с двумя параметрами первый из них определяет индекс начального символа извлекаемого фрагмента, а второй - индекс символа, расположенного сразу после конечного символа фрагмента (символ, находящийся непосредственно по индексу, не учитывается). Простой способ проверки - результат вычитания первого параметра из второго должен дать ожидаемую длину извлекаемой подстроки.

_Версия < Java SE 7_

В версиях JDK < 7u6 метод `sustring` создаёт объект `String`, который содержит тот же самый первоначальный массив символов **char[]**, что и в объекте `String` исходной строки, а внутренние поля типа `int offset` и `count` содержат соответственно индекс первого символа в массиве и количество символов в массиве. Такая реализация метода `subtring`, предполагающая совместно использование одного и того же участка памяти, может привести к перерасходу памяти, который можно предотвратить вызовом `new String(s.substring(...))` для принудительного создания копии строки, после чего старый массив **char[]** можно будет передать в мусор.

_Версия >= Java SE 7_

Начиная с JDK 7u6 метод `substring` всегда физически копирует весь массив **char[]**, лежащий в основе объекта `String`, что приближает вычислительную сложность к линейной по сравнению с предыдущей реализацией, у которой вычислительная сложность была **O(1)**, но при этом гарантирует отсутствие перерасхода памяти.

[к оглавлению Глава 11](#глава-11-строки)

## Раздел 11.9. Платформонезависимая реализация добавления символа перевода строки 

Поскольку символ перевода строки различается в зависимости от платформы (например, `\n` в Unix-подобных системах или `\r\n` в Windows), часто существует необходимость иметь к нему платформенно-независимый способ доступа. В Java он может быть получен из свойства системного класса `System`:

```java
System.getProperty("line.separator")
```

_Версия >= Java SE 7_

Поскольку символ перевода строки требуется очень часто, начиная с Java 7 существует метод быстрого доступа, возвращающий точно такой же результат, какой возвращает и приведённый выше код:

```java
System.lineSeparator()
```

_Примечание:_ поскольку маловероятно, что символ перевода строки изменится в процессе выполнения программы, целесообразно хранить его в статической переменной, которая по сути является константой, что позволит не извлекать его из свойства системного класса `System` каждый раз, когда это будет необходимо.

При использовании метода `String.format` используйте `%n`, а не `\n` или `\r\n` для обеспечения независимого от платформы вывод символа перевода строки.

```java
System.out.prinln(String.format('line 1: %s.%nline 2: %s%n', lines[0], lines[1]));
```

[к оглавлению Глава 11](#глава-11-строки)

## Раздел 11.10. Выполнение реверса строк

Существует несколько способов реализации реверса строки, чтобы символы в ней располагались в порядке, обратном первоначальному.

1. На основе использования объекта `StringBuilder/StringBuffer`:

```java
String code = "code";
System.out.println(code);

StringBuilder sb = new StringBuilder(code);
code = sb.reverse().toString();

System.out.println(code);
```

2. На основе использования массива символов:

```java
String code = "code";
System.out.println(code);

char[] array = code.toCharArray();
for (int index = 0, mirrorIndex = array.length - 1; index < mirrorIndex; index++, mirroredIndex--) {
    char temp = array[index];
    array[index] = array[mirroredIndex];
    array[mirroredIndex] = temp;
}

// print reversed
System.out.println(new String(array));
```

[к оглавлению Глава 11](#глава-11-строки)

## Раздел 11.11. Добавление метода toString() в объекты пользователя

Предположим, что вы определили следующий класс `Person`:

```java
public class Person {
    String name;
    int age;
    
    public Person (int age, String name) {
        this.age = age;
        this.name = name;
    }
}
```

При создании нового объекта `Person`:

```java
Person person = new Person(25, "Сергей");
```

и далее в коде вы используете следующий оператор для вывода информации о вашем объекте:

```java
System.out.println(person.toString());
```

Вы можете запустить эту программу онлайн на сайте ideone.com, перейдя по ссылке (https://ideone.com/tAl58G).

На экране вы получите результат, аналогичный приведённому ниже:

```java
Person@7ab89d
```

Это результат реализации метода `toString()`, определённого по умолчанию в классе `Object`, суперклассе класса `Person`. В документации к `Object.toString()` говорится:

   Метод `toString` класса `Object` возвращает строку, состоящую из имени класса, экземпляром которого является объект, знака `@` и беззнакового шестнадцатеричного представления хеш-кода объекта. Другими словами, этот метод возвращает строку, равную значению:

   ```java
   getClass().getName() + '@' + Integer.toHexString(hashCode())
   ```

Поэтому для получения осмысленного выводы необходимо переопределить метод `toString()` следующим образом:

```java
@Override
public String toString() {
    return "Меня зовут " + this.name + ", и мой возраст - " + this.age;
}
```

Теперь на выходе будет получен результат:

`Меня зовут Сергей, и мой возраст - 25 лет`

Вы также можете написать:

`System.out.println(person)`

Вы можете запустить эту программу онлайн на сайте ideone.com, перейдя по ссылке (https://ideone.com/51al3w).

Фактически `println()` неявно вызывает метод объекта `toString`.

[к оглавлению Глава 11](#глава-11-строки)

## Раздел 11.12. Удаление пробельных символов из начала и конца строки

Метод `trim()` возвращает новую строку `String`, в которой удалены ведущие и завершающие символы пробела.

```java
String s = new String(" Hello World!!! ");
String t = s.trim();    // t = "Hello World!!!"
```

Если применить метод `trim` к строке, в которой отсутствуют символы пробела для удаления, то такая строка будет возвращена в неизменном виде.

Обратите внимание, что метод `trim()` имеет своё собственное понятие символов пробела, которое отличается от понятия, используемого в методе `Character.isWhitespace()`:

+ Все управляющие символы ASCII с кодами от U+0000 до U+0020 считаются символами пробела и удаляются с помощью функции `trim()`. К ним относятся символы U+0020 'SPACE' (пробел), U+0009 'CHARACTER TABULATION' (символ табуляции), U+000A 'LINE FEED' (символ перевода листа) и U+000D 'CARRIAGE RETURN' (символ возврата каретки), а также символы типа U+0007 'BELL' (звуковой сигнал).
+ Символы пробела в Юникоде, такие как U+00A0 'NO-BREAK SPACE' или U+2003 'EM SPACE', методом `trim()` не распознаются.

[к оглавлению Глава 11](#глава-11-строки)

## Раздел 11.13. Оператор switch, нечувствительный к регистру

Сам оператор `switch` не может быть изменен как нечувствительный к регистру, но, в случае необходимости, может вести себя нечувствительно к регистру входной строки, используя методы `toLowerCase()` или `toUpperCase()`:

```java
switch (myString.toLowerCase()) {
    case "case1" :
        ...
    break;
    case "case2" :
        ...
    break;    
}
```

_Внимание:_
+ Параметр `Locale`, отвечающий за локализацию, может влиять на то, как происходят изменения для меток `case`!
+ Необходимо следить за тем, чтобы в метках не было заглавных символов - они никогда не будут выполнены!

[к оглавлению Глава 11](#глава-11-строки)

## Раздел 11.14. Замена частей строк

Существует два способа замены: по регулярному выражению или по точному совпадению.

_Примечание:_ исходный объект `String` не изменяется, возвращаемое значение содержит новую изменённую строку.

**Точное совпадение**

Заменить один символ другим символом:

```java
String replace(char oldChar, char newChar)
```

Возвращает новую строку, полученную в результате замены всех вхождений `oldChar` в данной строке на `newChar`.

```java
String s = "popcorn";
System.out.println(s.replace('p', 'W'));
```

Результат:
`WoWcorn`

**Заменить одну последовательность символов на другую последовательность символов:**

`String replace(CharSequence target, CharSequence replacement)`

Заменяет каждую подстроку исходной строки, совпадающую с целевой последовательностью символов `target`, на требуемую последовательность символов `replacement`.

```java
String s = "metal petal et al. ";
System.out.println(s.replaceFirst("etal", "etallica"));
```

Результат:

`metallica petallica et al.`

**Регулярное выражение**

_Примечание:_ для ссылки на группу используется символ $, например, $1.

**Заменить все совпадения**

`String replaceAll(String regex, String replacement)`

Заменяет каждую подстроку данной строки, соответствующую заданному регулярному выражению `regex`, на требуемую строку `replacement`.

```java
String s = " spiral metal petal et al. ";
System.out.println(s.replaceFirst("(\\w*etal)", "$1lica"));
```

Результат:

`spiral metallica petallica et al.`

**Заменить только первое совпадение:**
```java
String replaceFirst(String regex, String replacement)
```

Заменяет первую подстроку данной строки, соответствующую заданному регулярному выражению, на требуемую строки `replacement`

```java
String s = " spiral metal petal et al. ";
System.out.println(s.replaceAll("(\\w*etal)", "$1lica"));
```

Результат:

`spiral metallica petal et al.`

[к оглавлению Глава 11](#глава-11-строки)

## Раздел 11.15. Получение длины строки



[к оглавлению Глава 11](#глава-11-строки)

[Раздел 11.1. Сравнение строк](#раздел-111-сравнение-строк)

[Раздел 11.2. Изменение регистра символов в строке](#раздел-112-изменение-регистра-символов-в-строке)

[Раздел 11.3. Проверка вхождения строки в состав другой строки](#раздел-113-проверка-вхождения-строки-в-состав-другой-строки)

[Раздел 11.4. Пул строк и область памяти Java Heap](#раздел-114-пул-строк-и-область-памяти-java-heap)

[Раздел 11.5. Разделение строк на подстроки](#раздел-115-разделение-строк-на-подстроки)

[Раздел 11.6. Объединение строк с помощью разделителя](#раздел-116-объединение-строк-с-помощью-разделителя)

[Раздел 11.7. Конкатенация строк и класс StringBuilder](#раздел-117-конкатенация-строк-и-класс-stringbuilder)

[Раздел 11.8. Подстроки](#раздел-118-подстроки)

[Раздел 11.9. Платформонезависимая реализация добавления символа перевода строки ](#раздел-119-платформонезависимая-реализация-добавления-символа-перевода-строки-)

[Раздел 11.10. Выполнение реверса строк](#раздел-1110-выполнение-реверса-строк)

[Раздел 11.12. Удаление пробельных символов из начала и конца строки](#раздел-1112-удаление-пробельных-символов-из-начала-и-конца-строки)

[Раздел 11.13. Оператор switch, нечувствительный к регистру](#раздел-1113-оператор-switch-нечувствительный-к-регистру)

[Раздел 11.14. Замена частей строк](#раздел-1114-замена-частей-строк)

[Раздел 11.15. Получение длины строки](#раздел-1115-получение-длины-строки)