# Глава 11. Строки

Строки (`java.lang.String`) - это фрагменты текста, хранящиеся в вашей программе. Строка не являются примитивным типом данных в Java, однако они очень часто встречаются в процессе написания программ на Java.

В языке Java строки относятся к неизменяемым типам данных, то есть их нельзя изменить. (Более подробное объяснение понятия неизменяемости можно найти по адресу http://stackoverflow.com/questions/279507/what-is-meant-by-immutable).

## Раздел 11.1 Сравнение строк

Для сравнения строк на равенство следует использовать методы `equals` или `equalsIgnoreCase` объекта `String`. Например, следующий фрагмент программы определяет, равны ли два экземпляра `String` по всем входящим в них символам:

```java
String firstString = "Test123";
String secondString = "Test" + 123;

if (firstString.equals(secondString)) {
    // Обе строки имеют одинаковое содержимое.
}
```

Вы можете запустить эту программу онлайн на сайте ideone.com, перейдя по ссылке (https://ideone.com/TjaYMR).

В данном примере будет проведено сравнение строк, не зависящее от того, в каком регистре набраны символы:

```java
String firstString = "Test123";
String secondString = "TEST123";

if (firstString.equalsIgnoreCase(secondString)) {
    // Обе строки равны, без учета регистра отдельных символов.
}
```

Вы можете запустить эту программу онлайн на сайте ideone.com, перейдя по ссылке (https://ideone.com/XxKmM1).

Обратите внимание, что метод `equalsIgnoreCase` не позволяет задать параметр `Locale`. Например, если сравнить два слова "Taki" и "TAKI" в английском языке, то они будут одинаковыми, но в турецком языке они будут разными (в турецком языке строчная буква I - l). В подобных случаях решением является преобразование обеих строк в нижний (или верхний) регистр с применением возможностей класса `Locale` и последующее сравнение строк с помощью метода `equals`.

```java
import java.util.Locale;

String firstString = "Taki";
String secondString = "TAKI";

System.out.println(firstString.equalsIgnoreCase(secondString));     // выводит true

Locale locale = Locale.forLanguageTag("tr - TR");

System.out.println(firstString.toLowerCase(locale).equals(
                   secondString.toLowerCase(locale)));  // выводит false
```

Вы можете запустить эту программу онлайн на сайте ideone.com, перейдя по ссылке (https://ideone.com/uWc348).

**Не используйте оператор == для сравнения строк**

Не следует использовать операторы `==` или `!=` для сравнения строк, если вы не можете гарантировать, что все строки не были интернированы (см. ниже). Эти операторы фактически проверяют ссылки, а поскольку несколько объектов `String` могут представить одну и ту же строку, это может привести к неправильному результату.

Вместо этого следует использовать метод `String.equals(Object)`, который будет сравнивать объекты `String` на основе их значений. Более подробное объяснение приведено в разделе "Ловушка: использовать `==` для сравнения строк".

**Сравнение строк в операторе switch**

_Версия >= Java SE 7_

Начиная с версии Java 1.7, в операторе **switch** можно сравнивать переменную `String` с литералами. При этом необходимо убедиться, что `String` не является значением `null`, иначе всегда будет возникать исключение `NullPointerException`. Значения сравниваются с помощью метода `String.equals`, т.е. с учетом регистра.

```java
String stringToSwitch = "A";

switch (stringToSwitch) {
    case "a":
        System.out.println("a");
        break;
    case "A":
        System.out.println("A");    // код идет здесь
        break;
    case "B":
        System.out.println("B");
        break;
    deafault:
        break;    
}
```

Вы можете запустить эту программу онлайн на сайте ideone.com, перейдя по ссылке (https://ideone.com/fbWBUR).

**Сравнение строк с константами**

При сравнении строки со строками-константами можно поместить константное значение в левую часть метода `equals`, чтобы не получить исключение `NullPointerException`, если другая строка равна значению `null`.

```java
"baz".equals(foo);
```

В то время как `foo.equals("baz")` вызовет исключение `NullPointerException`, если `foo` будет равно `null`, значение `"baz".equals(foo)` не вызовет исключение, а будет равно `false`.

_Версия >= Java SE 7_

Более удобной альтернативой использование метода `Objects.equals()`, которая проверяет оба параметра на равенство значению `null`:

```java
Objects.equals(foo, "baz").
```

_Примечание_: спорным является вопрос о том, хорошо ли вообще избегать исключений `NullPointerException`, или лучше позволить им произойти, а затем устранить первопричину, их вызывающую. И само собой разумеется, назвать стратегию избегания "лучшей практикой" не вполне правомерно.

**Упорядочивание строк**

Класс `String` реализует интерфейс `Comparable<String>` с содержащимся в нем методом `String.compareTo()` (как описано в начале этого примера). Это делает естественное упорядочивание объектов `String` чувствительным к регистру. Класс `String` предоставляет константу `CASE_INTENSITIVE_ORDER`, которая принадлежит интерфейсу `Comparator<String>`, и предназначена для сортировки строк без учета регистра.

**Сравнение с интернированными строками**

В спецификации языка Java (JLS 3.10.6) говорится следующее:

"Более того, строковый литерал всегда ссылается на один и тот же экземпляр класса `String`. Это объясняется тем, что строковые литералы или, в более общем случае, строки являющиеся константами, _интернируются_ так, чтобы разделять между собой ссылку на уникальный экземпляр, с помощью метода `String.intern`".

Это означает, что можно сравнивать ссылки на два строковых литерала с помощью оператора `==`. Более того, что это справедливо и для ссылок на объекты `String`, созданные с помощью метода `String.intern()`. Например:

```java
String strObj = new String("Hello!");
String str = "Hello!";

// Две ссылки на объект String указывают на две одинаковые строки
if (strObj.equals(str)) {
    System.out.println("Строки равны");
}

// Две строковые ссылки не указывают на один и тот же объект
if (strObj != str) {
    System.out.println("Строки не являются одним и тем же объектом");
}

// Если мы интернируем строку, которая равна заданному литералу, то в результате
// получим строку, имеющую ту же ссылку, что и литерал.
String internedStr = strObj.intern();

if (internedStr == str) {
    System.out.println("Интернированная строка и литерал являются одним и тем же объектом");
}
```

За кулисами механизм интернирования ведёт хеш-таблицу, содержащую все интернированные строки, которые все ещё _достижимы_. Когда вы вызываете функцию `intern()` для строки `String`, метод ищет объект в хеш-таблице:
+ Если строка найдена, то это значение возвращается как интернированная строка.
+ В противном случае копия строки добавляется в хеш-таблицу и эта строка возвращается в качестве интернированной строки.

Можно использовать интернирование для сравнения строк с помощью оператора `==`. Однако при этом возникают серьёзные проблемы; подробнее об этом см. в разделе "Ловушка - применение оператора `==` для интернированных строк - плохое решение". В большинстве случаев такая реализация не рекомендуется.

[к оглавлению Глава 11](#глава-11-строки)

## Раздел 11.2. Изменение регистра символов в строке

Тип `String` предоставляет два метода преобразования строк к верхнему и нижнему регистру:
+ `toUpperCase` для преобразования всех символов в строке к верхнему регистру.
+ `toLowerCase` для преобразования всех символов в строке к нижнему регистру.

Оба этих метода возвращают преобразованные строки в виде новых экземпляров `String`: исходные объекты `String` не изменяются, поскольку `String` в Java принадлежит к неизменяемому типу данных. Подробнее можно ознакомиться здесь: (http://stackoverflow.com/questions/1552301/immutability-of-strings-in-java)

```java
String string = "This is a Random String";
String upper = string.toUpperCase();
String lower = string.toLowerCase();

System.out.println(string); // выводит сообщение "This is a Random String"  
System.out.println(lower); // выводит сообщение "this is a random string"
System.out.println(upper); // выводит сообщение "THIS IS A RANDOM STRING"
```

На неалфавитные символы, такие как цифры и знаки препинания, эти методы не влияют. Следует отметить, что при определённых условиях эти методы могут некорректно работать с некоторыми символами Unicode.

_Примечание_: эти методы _чувствительны к объектам Locale (отвечающих за локализацию программы)_ и могут привести к неожиданным результатам, если используются для строк, которые должны интерпретироваться независимо от локализации. Примерами могут служить идентификаторы языков программирования, ключи протоколов и HTML-теги.

Например, `"TITLE".toLowerCase()` в турецкой локализации возвращает `"tltle"`, где `l` `(\u0131)` - латинский малый буквенный символ I без точки. Чтобы получить корректные результаты для строк, нечувствительных к локализации, передайте параметр `Locale.ROOT` в качестве параметра соответствующему методы преобразования регистра (например, `toLowerCase(Locale.ROOT)` или `toUpperCase(Locale.ROOT`)). 

Хотя использование параметра `Locale.ENGLISH` будет корректно для большинства случаев, способом, инвариантным к языку, является использование параметра `Locale.ROOT`.

Подробный список символов Unicode, для которых требуется специальная обработка, можно найти на сайте Консорциума Unicode (http://unicode.org/Public/UNIDATA/SpecialCasing.txt)

**Изменение регистра заданного символа в строке ASCII**

Для изменения регистра определённого символа в ASCII-строке можно использовать следующий алгоритм:

Шаги:

1. 

[к оглавлению Глава 11](#глава-11-строки)

[Раздел 11.1. Сравнение строк](#раздел-111-сравнение-строк)

[Раздел 11.2. Изменение регистра символов в строке](#раздел-112-изменение-регистра-символов-в-строке)