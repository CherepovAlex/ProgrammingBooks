# Глава 8. Команда Java - 'java' и 'javaw'

## Раздел 8.1. Класс с точкой входа

Класс Java с точкой входа содержит метод `main` со следующей сигнатурой и модификаторами доступа:

```java
public static void main(String[] args) {}
```

**Примечание**: в силу особенностей работы с массивами это может быть и объявление (`String args[]`).

При запуске виртуальной машины команда `java` загружает указанные классы с точками входа и пытается найти в них метод `main`. В случае успеха аргументы из командной строки преобразуются в объекты `Java String` и собираются в массив. Если метод `main` вызывается подобным образом, то длина этого массива не должны быть равна нулю и этот массив не должен содержать пустых элементов `null`.

Правильно написанный метод класса с точкой входа должен отвечать следующим условиям:
+ Иметь имя `main` (с учетом регистра)
+ Иметь модификаторы доступа **public** и **static**.
+ Тип возвращаемого значение должен быть **void**.
+ Иметь хотя бы один аргумент - массив строк `String[]`. Аргумент должен обязательно присутствовать. Количество аргументов должно быть не больше одного.
+ С целью совместимости: не допускаются параметры других типов данных.
+ С точки зрения иерархии - это должен быть метод верхнего уровня (он не должен быть вложенным методом и не должен содержать вложенные методы). 

Принято объявлять класс с модификатором доступа **public**, но это требование не является обязательным. Начиная с Java 5, тип аргумента метода `main` может быть не массивом строк, а массивом элементов типа String varargs. Метода `main` может по желанию выбрасывать исключения, а его параметр может быть назван как угодно, но, как правило, ему присваивают имя `args`.

**Точка входа JavaFX**

Начиная с `Java 8` команда `java` может также непосредственно запускать приложение JavaFX. JavaFX документируется в теге JavaFX, но точка входа JavaFX должна отвечать следующим критериям:
+ Вести свои происхождение от класса `javafx.application.Application`.
+ Иметь модификатор доступа **public**, а не **abstract**.
+ Не должен иметь обобщенный тип данных (не является методом-дженериком) и не должен быть вложенным.
+ Иметь явный или неявный конструктор с модификатором доступа **public**, не поддерживающий передачу аргументов в командной строке.

[к оглавлению Глава 8](#глава-8-команда-java---java-и-javaw)

## Раздел 8.2. Устранение ошибок при использовании команды 'java'

В этом примере рассмотрены типичные ошибки при использовании команды 'java'.

**"Command not found" (рус. "Команда не найдена)**

Если вы получите сообщение об ошибке типа:

```bash
java: command not found
```

при попытке запуска на выполнение команды `java`, это означает, что в путях команды поиска оболочки отсутствует команда `java`. Причина может заключаться в следующем:
+ у вас вообще не установлены `Java JRE` или `JDK`,
+ вы не обновили переменную окружения `PATH` (или обновили некорректно) в файле инициализации вашей оболочки,
+ или вы указали в путях неверный файл инициализации для текущей командной оболочки.

Правильную последовательность установки `Java` см. в разделе "Установка Java".

**Could not find or load main class ("Не удалось найти или загрузить основной класс")**

Это сообщение об ошибке выдаётся командой `java`, если ей не удалось найти/загрузить указанный вами класс, содержащий точку входа. В общем случае это может произойти по трем причинам:
+ Вы указали несуществующий класс с точкой входа.
+ Класс существует, но вы указали его некорректно.
+ Класс существует, и вы правильно его указали, но `Java` не может его найти из-за неправильно заданного параметра `Classpath`.

Ниже приводится процедура диагностики и решения этой проблемы:

1. Необходимо выяснить полное имя класс с точкой входа.
+ Если у вас есть исходный код класса, то полное имя состоит из имени пакета и простого имени класса. Если класс `Main` объявлен в пакете `"com.example.myapp"`, то его полное имя будет `"com.example.myapp.Main"`.
+ Если у вас есть скомпилированный файл класса, вы можете найти имя класса, запустив команду javap и задав имя этого файла в качестве параметра.
+ Если файл класса находится в каталоге, то из имен каталога и подкаталогов можно вывести полное имя класса.
+ Если файл класса находится в JAR- или ZIP-файла, то полное имя класса можно определить по пути к файлу внутри JAR- или ZIP-файла.

2. Посмотрите на сообщение об ошибке, выданное командой `java`. В конце сообщения должно быть указано полное имя класса, которое java пытается использовать.
+ Убедитесь, что оно полностью совпадает с полным именем класса, содержащего точку входа.
+ Оно не должно заканчиваться на `".java"` или `".class"`.
+ Оно не должно содержать символов "косая черта" или любых других символов, которые не являются допустимыми для определения идентификаторов в языке `Java`.
+ Регистр имени должен точно соответствовать полное имени класса.

3. Если вы задаете правильное имя класса, убедитесь, что этот класс действительно находится в параметре `Classpath`:
+ Определите путь, к которому привязано имя класса; см. раздел "Сопоставление имен классов с именами путей".
+ Определите верно содержимое параметра `Classpath`; см. этот пример: "Различные способы указания пути к классу в параметре Classpath".
+ Просмотрите каждый из JAR- и ZIP-файлов, пути к которым заданы в `Classpath`, на предмет наличия в них класса с требуемым именем.
+ Просмотрите каждый каталог на предмет того, соответствует ли имя файла в пути реальному имени файла, содержащемуся в этом каталоге.

Если проверки путей классов вручную не помогла, можно к команде добавить опции `-Xdiag` и `-XShowSettings`. Первая выводит список всех загружаемых классов, а вторая - настройки, включающие текущие пути к классам для `JVM`.

Наконец, существуют и _малоизвестные_ причины возникновения этой проблемы:
+ Исполняемый JAR-файл с атрибутом **Main-Class**, указывающим на существующий класс.
+ Исполняемый JAR-файл с неверным атрибутом `Class-Path`.
+ Если вы перепутаете опции перед именем класса, команда `java` может попытаться интерпретировать одну из них в качестве имени класса.
+ Если кто-то проигнорировал правила стиля `Java` и использовал идентификаторы пакетов или классов, отличающиеся только регистром букв, а вы работаете на платформе, в которой регистр буев в именах файлов считается несущественным.
+ Проблемы с омоглифами в именах классов в коде или в командной строке. Например, указано по ошибке "а" в русской раскладке клавиатуры вместе латинской.

**"Main method not found in class"** (**"В данном классе не найден метод main"**)

Эта проблема возникает, когда команда `java` находит и загружает указанный вами класс, но затем не может найти метод `main`, служащий точкой входа в ваше приложение.

Существует три возможных объяснения:
+ Если вы пытаетесь запустить исполняемый JAR-файл, то в манифесте JAR имеется некорректный атрибут "Main-Class", указывающий на класс, который не является допустимым для класса с точкой входа.
+ Вы сообщили команде `java` класс, который не является классом, содержащим точку входа.
+ Неверно указан класс, содержащий точку входа; подробнее см. раздел "Класс, содержащие точку входа".

**Другие ресурсы**
+ Что означает сообщение "Не удалось найти или загрузить основной класс"? (http://stackoverflow.com/questions/18093928/what-does-could-not-find-or-load-main-class-mean )
+ http://docs.oracle.com/javase/tutorial/getStarted/problems/index.html

[к оглавлению Глава 8](#глава-8-команда-java---java-и-javaw)

## Раздел 8.3. Запуск Java-приложения с зависимостями от библиотек

Это продолжение примеров по теме "класс, содержащий метод main" и "исполняемый JAR-файл".

Как правило, типичные Java-приложения состоят из кода, написанного специально для конкретного приложения, и кода, включенного из различных библиотек, реализованных либо вами, либо сторонними разработчиками. Последние принято называть зависимостями от библиотек, и они обычно упаковываются в виде JAR-файлов.

`Java` - динамически связываемый язык. Когда вы запускаете Java-приложение с зависимостями от библиотек, JVM должна знать, где находятся эти зависимости, чтобы подгружать классы по мере необходимости. В общем случае существует два способа решения этой задачи:
+ Приложение и его зависимости могут быть переупакованы в один JAR-файл, содержащий все необходимые классы и ресурсы.
+ Для JVM может быть указано, где найти зависимые JAR-файлы, через параметр `Classpath` среды выполнения.

Для исполняемого JAR-файла путь к классу во время выполнения задаётся атрибутом манифеста "Class-Path". В противном случае необходимо указать путь к классу, запускающему приложение, с помощью опции `-cp` или переменной окружение `CLASSPATH`.

Например, предположим, что у нас есть Java-приложение в файле "myApp.jar", у которого класс, содержащий точку входа, имеет имя `com.example.myApp`. Предположим также, что это приложение зависит от библиотечных JAR-файлов "lib/library1.jar" и "lib/library2.jar". Тогда мы можем запустить приложение в командной строке с помощью команды `java` следующим образом:

```bash
 $ # 1-й способ (предпочтительный)
 $ java -cp myApp.jar:lib/library1.jar:lib/library2.jar com.example.MyApp
 
 $ # 2-й способ
 $ export CLASSPATH=myApp.jar:lib/library1.jar:library2.jar
 $ java com.example.MyApp
```

(В Windows в качестве разделителя для пути к классу используется ;, а не :, и (локальный) параметр CLASSPATH задаётся командой `set`, а не `export`).

И хоть это вполне устраивает Java-разработчика, но это не очень удобно для пользователя. Поэтому, чтобы скрыть детали, о которых пользователю знать не следует, принято писать простой сценарий для командной оболочки (или файл `.bat` для Windows). Например, если поместить следующий сценарий командной оболочки в файл с именем "myApp, сделать его исполняемым и поместить в каталог по пути поиска команд:

```bash
#!/bin/bash
# Скрипт обертки 'myApp'

export DIR=/usr/libexec/myApp
export CLASSPATH=$DIR/myApp.jar:$DIR/lib/library1.jar:$DIR/lib/library2.jar
java com.example.MyApp
```

то его можно запустит следующим образом:
```bash
$ myApp arg1 arg2
```

Любое количество аргументов командной строки будет передано Java-приложению через расширение `"$@"`. (Аналогично можно поступить и с .bat файлом Windows, хотя синтаксис будет несколько отличаться).

[к оглавлению Глава 8](#глава-8-команда-java---java-и-javaw)

## Раздел 8.4. Опции для команды java

Команда `java` поддерживает широкий набор опций:
+ Все опции начинаются с одиночного дефиса или знака минус (-): традиционно в среде GNU/Linux использование -- для "длинных" опций не поддерживается.
+ Для успешного распознавания опции должны находиться перед аргументом **`<classname>`** или файлом `-jar <jarfile>`. Любые аргументы после них будут рассматриваться именно как аргументы, передаваемые запускаемому Java-приложению.
+ Опции, не начинающиеся с `-X` или `-XX`, являются стандартными. Вы можете рассчитывать на то, что все реализации Java будут поддерживать любую стандартную опцию.
+ Опции, начинающиеся с `-X`, являются нестандартными опциями и могут быть изъяты при переходе из одной версии Java в другую.
+ Опции, начинающиеся с `-XX`, являются расширенными и также могут быть изъяты при переходе из одной версии Java в другую.

**Установка свойств системы с помощью параметра -D**

Параметр `-D<свойство>=<значение>` используется для установки свойства в системном объекте `Properties`. Этот параметр можно повторять несколько раз для установки различных свойств.

**Параметры памяти, стека и сборщика мусора**

Основные возможности управления размерами кучи и стека описаны в разделе "Установка размеров кучи, PermGen и стека". 

**Включение и отключение утверждений (assertions)**

Опции `-ea` и `-da` соответственно включают и отключают проверку утверждений в Java:
+ По умолчанию все проверки утверждений отключены.
+ Опция `-ea`: <имя пакета>... позволяет проверить все утверждения.
+ Параметр `-ea`:<имя пакета>... включает проверку утверждений в указанном пакете и всех подпакетах.
+ Команда `-ea`:<classname>... включает проверку утверждений в указанном классе.
+ Опция `da` отключает проверку всех утверждений.
+ Параметр `-da`:<имя пакета>... отключает проверку утверждений в указанном пакете и всех подпакетах.
+ Команда `-da`:<classname>... отключает проверку утверждений в указанном классе.
+ Опция `-esa` включает проверку всех системных классов.
+ Опция `-dsa` отключает проверку всех системных классов.

Опции можно комбинировать. Например.

```bash
$ # Включить проверку всех утверждений в несистемных классах
$ java -ea -dsa MyApp

$ # Включить утверждения для всех классов пакета, кроме одного
$ java -ea:com.wombat.fruitbat... -da:com.wombat.fruitbat.Brickbat MyApp
```

Обратите внимание, что включение проверки утверждений может привести к изменению поведения Java-программы:
+ Это может привести к замедлению работы приложения в целом.
+ Это может привести к тому, что определенные методы будут выполнять дольше, что может изменить синхронизацию потоков в многопоточном приложении.
+ Это может привести к возникновению случайных причинно-следственных связей, которые могут привести к аномалиям в поведении памяти.
+ Неправильно реализованный оператор **`assert`** может привести к нежелательным побочным эффектам.

**Выбор типа виртуальной машины**

Опции `-client` и `-server` позволяют выбирать между двумя различными формами HotSpot VM:
+ "Клиентская" форма настроена на работу с пользовательскими приложениями и обеспечивает более быстрый запуск.
+ "Серверная" форма настроена на длительную работу приложений. Она дольше снимает статистику во время "прогрева" JVM, что позволяет JIT-компилятору лучше оптимизировать код.

По умолчанию, если позволяют возможности платформы, JVM будет работать в 64-разрядном режиме. Опции `-d32` и `-d34` позволяют явно выбрать режим работы.

[к оглавлению Глава 8](#глава-8-команда-java---java-и-javaw)

## Раздел 8.5. Пробелы и другие специальные символы в аргументах.

Прежде всего,

[к оглавлению Глава 8](#глава-8-команда-java---java-и-javaw)

[Раздел 8.1. Класс с точкой входа](#раздел-81-класс-с-точкой-входа)

[Раздел 8.2. Устранение ошибок при использовании команды 'java](#раздел-82-устранение-ошибок-при-использовании-команды-java)

[Раздел 8.3. Запуск Java-приложения с зависимостями от библитек](#раздел-83-запуск-java-приложения-с-зависимостями-от-библиотек)

[Раздел 8.4. Опции для команды java](#раздел-84-опции-для-команды-java)

[Раздел 8.5. Пробелы и другие специальные символы в аргументах](#раздел-85-пробелы-и-другие-специальные-символы-в-аргументах)