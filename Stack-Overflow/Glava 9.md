# Глава 9. Литералы

Java-литерал - это синтаксическая единица (т.е. то, что можно найти в исходном коде Java-программы), которая представляет собой какое-то конкретное значение. Примерами являются `1, 0.333F, false, &#39; X&#39;` и `"Hello world\n`.

## Раздел 9.1. Использование подчеркивания для улучшения читабельности

Начина с Java 7 появилась возможность использовать одно или несколько подчеркиваний (_) для разделения групп цифр в литерале примитивного числа с целью улучшения их читабельности.

Например, эти два объявления полностью эквивалентны:

_Версия>=Java SE 7_
```java
int i1 = 123456;
int i2 = 123_456;
System.out.println(i1 == i2); // true 
```

Это применимо ко всем литералам примитивных чисел, как показано ниже:

_Версия>=Java SE 7_
```java
byte color = 1_2_3;
short yearsAnnoDomini = 2_016;
int SocialSecurityNumber = 999_99_9999;
long CreditCardNumber = 1234_5678_9012_3456L;
float piFourDecimals = 3.14_15F;
double piTenDecimals = 3.14_15_92_65_35;
```

Это также работает для чисел в двоичном, восьмеричном и шестнадцатеричном базисах:

_Версия>=Java SE 7_
```java
short binary = 0b0_1_0_1;
int octal = 07_7_7_7_7_7_7_7_0;
long hexBytes = 0xFF_EC_DE_5E;
```

Существует несколько правил использования символов подчеркивания, которые запрещают их размещение в следующим местах:
+ В начале или в конце числа (например, _123 или 123_ недопустимы).
+ Если символ подчеркивания примыкает к десятичной точке в литерале числа с плавающей запятой (например, недопустимы такие ситуации: 1._23 или 1_.23).
+ Перед суффиксом `F` или `L` (например, неДопустимы запись 1.23_F или 9999999_L).
+ В позициях, где ожидается строка цифра (например, запись 0_xFFFF недопустима).

[к оглавлению Глава 9](#глава-9-литералы)

## Раздел 9.2. Шестнадцатеричные, восьмеричные и двоичные литералы

Шестнадцатеричное число - это значение по основанию 16. В нем 16 цифр, 0-9 и буквы A-F (регистр не имеет значения). A-F соответствует числам 10-15.

Восьмеричное число - это значение по основанию 8, в котором используются цифры 0-7.

Двоичное число - это значение по основанию 2, в котором используются цифры 0 и 1. Все представленные ниже числа дают одно и то же значение - 110:

```java
int dec = 110;          // без префикса --> десятичный литерал
int bin = 0b1101110;    // префикс '0b' --> двоичный литерал
int oct = 0156;         // префикс '0'  --> восьмеричный литерал
int hex = 0x6E;         // префикс '0x' --> шестнадцатеричный литерал
```

Отметим, что синтаксис двоичных литералов был введён начиная с Java 7.

Восьмеричный литерал легко может стать ловушкой для семантических ошибок. Если к десятичному литералу добавить ведущий '0', то можно получить неверное значение:

```java
int a = 0110;       // Вместо 100, a = 64
```

[к оглавлению Глава 9](#глава-9-литералы)

## Раздел 9.3. Логические литералы (типа boolean)

Логические литералы являются самыми простыми литералами в языке программирования Java. Два возможных логических значения представляются литералами `true` и `false`. Они чувствительны к регистру. Например:

```java
boolan flag = true;     // использование литерала 'true'
flag = false;           // использование литерала 'false'
```

[к оглавлению Глава 9](#глава-9-литералы)

## Раздел 9.4. Строковые литералы

Строковые литералы обеспечивают наиболее удобный способ представления строковых объектов в исходном коде языка Java. Строковый литерал состоит из:
+ Открывающего символа двойные кавычки (").
+ Набора символов от нуля и т.д., кроме символа "двойные кавычки" и символа перевода строки (Экранирующий символ косой черты (\) изменяет значение последующих символов; см. раздел "Управляющие последовательности в литералах").
+ Закрывающего символа двойные кавычки.

Пример:

```java
"Hello world"       // Литерал, обозначающий 11-символьную строку String
""                  // Литерал, обозначающий пустую строку (строку нулевой длины)
"\""                // Литерал, обозначающий строку, состоящий из одного символа двойной кавычки
"1\t2\t3\n"         // Еще один литерал, содержащий управляющие последовательности
```

Обратите внимание, что один строковый литерал не может занимать несколько строк исходного кода. Ошибка компиляции появится, если ввести символ перевода строка (или символ конца исходного файла) перед закрывающей двойной кавычкой. Пример:

```java
"Мир Джелло     // Ощибка компиляции (в конце строки!)
```

**Длинные строки**
Если вам необходимо в тексте программы работать со строкой, длина которой превышает ширину экрана, то для удобства работы лучше всего разбить её на несколько литералов и соединить их с помощью оператора конкатенации (+). Например:

```java
String typingPractice = "Быстрый коричневый Лис" +
                        "перепрыгнув через" + 
                        "ленивую собаку";
```

Выражение, подобное приведённому выше, состоящее из строковых литералов и символа "+", удовлетворяет правилам создания строковой константы. Это означает, что данные выражение будет разобрано компилятором и представлено во время выполнения единым объектом типа `String`.

**Интернирование строковых литералов**
Когда файл класса, содержащий строковые литералы, загружается в JVM, соответствующие объекты типа `String` интернируются системой во время выполнения. Это означает, что строковый литерал, используемый в нескольких классах, занимает столько же места, как если бы он использовался только в одном классе.

Более подробную информацию об интернировании и пули строк см. в примере "Пул строк и хранение кучи" в теме "Строки"

[к оглавлению Глава 9](#глава-9-литералы)

## Раздел 9.5. Литерал Null

Литерал Null (записывается как **null**) представляет единственное значение типа null. Приведём несколько примеров

```java
MyClass object = null;
MyClass[] objects = new MyClass[]{new MyClass(), null, new MyClass()};

myMethod(null);

if (objects != null) {
    // Сделайте что-нибудь
        }
```

Тип null является довольно необычным. Он не имеет имени, поэтому его нельзя выразить в исходном коде Java. (И он также не имеет представления во время выполнения).

Единственное назначение типа null - быть типом **null**. Он совместим по присваиванию со всеми ссылочными типами и может быть приведён к любому ссылочному типу. (В последнем случае приведение не влечёт за собой проверку типа во время выполнения программы).

Наконец, **null** обладает тем свойством, что результат операции `null instanceof <SomeReferenceType>` будет всегда **false**, независимо от того, какой тип указан в `<SomeReferenceType>`.

[к оглавлению Глава 9](#глава-9-литералы)

## Раздел 9.6. Управляющие последовательности в литералах

Строковые и символьные литералы предоставляют механизм экранирования, позволяющий отображать коды символов, которые в противном случае были бы недопустимы для отображения в данном литерале. Управляющая последовательность состоит их экранирующего символа обратной косой черты (\), за которым следует один или несколько других символов. Одни и те же управляющие последовательности подходят как для символьных, так и для строковых литералов.

Полный набор управляющих последовательностей выглядит следующим образом:
|**Управляющая последовательность**|**Описание**|
|:-------------------------------------------|:-------------------------------------------------------------------------|
|`\\`|Обозначает символ обратной косой черты (\)|
|`\'`|Обозначает символ одинарной кавычки (')|
|`\"`|Обозначает символ двойной кавычки (")|
|`\n`|Обозначает символ перевода строки (LF)|
|`\r`|Обозначает символ возврата каретки (CR)|
|`\t`|Обозначает символ прогона страницы к началу следующей страницы (HT)|
|`\f`|Обозначает символ прогона страницы к началу следующей страницы (FF)|
|`\b`|Обозначает символ Backspace (BS)|
|`\<octal>`|Обозначает код символа в диапазоне от 0 до 255.|

В приведённом выше примере **<octal>** состоит из одной, двух или трёх восьмеричных цифр ('0'-'7'), которые представляют число от 0 до 255 (десятичное).

Обратите внимание, что обратная косая черта, за которой следует любой другой символ, не входящий в приведённый выше перечень, является недопустимой управляющей последовательностью. Недопустимые управляющие последовательности рассматриваются спецификацией языка Java (JLS-Java® Language Specification) как ошибки компиляции.

Более подробно о недопустимых управляющих последовательностях для литералов символов и строк, а также о JLS можно почитать, перейдя по ссылке: https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.6

**Экранирование в Unicode**

Помимо описанных выше строковых и символьных экранирующих последовательностей, в Java имеется более общий механизм экранирования Unicode, определённый в пункте 3.3 JLS (JLS 3.3. Экранирование Unicode) https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.3

Экранирование Unicode имеет следующий синтаксис:

```bash
'\' 'u' <шестнадцатеричная цифра> < шестнадцатеричная цифра>
<шестнадцатеричная цифра> < шестнадцатеричная цифра>
```

где <шестнадцатеричная цифра > - одно из значений '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F'.

Управляющая последовательность в Unicode сопоставляется компилятором Java символу (строго говоря, 16-битной кодовой единице Unicode) и может использоваться в любом месте исходного кода, где сопоставленные символ является допустимым. Он обычно используется с символьных и строковых литералах, когда в виде литерала необходимо представить символ, не являющийся символом ASCII.

[к оглавлению Глава 9](#глава-9-литералы)

## Раздел 9.7. Символьные литералы

Символьные литералы обеспечивают наиболее удобный способ представления сивольных значений в исходном коде Java. Символьный литерал состоит из:
+ Открывающий символ одинарной кавычки (`'`).
+ Представление символа. Это может быть любой символ, за исключением символа одиночной кавычки или символа перевода строки. Это также может быть управляющая последовательность, которая начинается с символа обратной косой черты (`\`); см. раздел "Управляющая последовательность в литералах".
+ Закрывающий символ одинарной кавычки (`'`).

Например:

```java
char a = 'a';
char doubleQuote = '"';
char singleQuote = '\"';
```

Символ перевода строки в символьном литерале приведёт к ошибке компиляции:

```java
char newline = '
// ошибка компиляции в предыдущей строке
char Newline = '\n'; // Исправление
```

[к оглавлению Глава 9](#глава-9-литералы)

## Раздел 9.8. Целочисленные десятичные литералы

Целочисленные литералы можно использовать там, где требуется значение типа **byte, short, int, long** или **char**. (В данном примере рассматриваются числа в десятичной системе счисления. В других примерах рассматриваются литералы в восьмеричной, шестнадцатеричной и двоичной системах счисления, а также использование знаков подчеркивания для улучшения читаемости).

**Обычные целочисленные литералы**

Наиболее простой и распространённой формой целочисленного литерала является целочисленный литерал, представляющий десятичные числа. Например:
||||
|:---------|:----------------------------------|:-------------------|
|0|//Десятичное число ноль|(тип "int)|
|1|//Десятичное число один|(тип "int)|
|42|//Десятичное число сорок два|(тип "int)|


Необходимо соблюдать осторожность с ведущими нулями. Ведущий нуль приводит к тому, что целочисленный литерал интерпретируется как восьмеричное число, а не десятичное.
|||
|:---------|:----------------------------------------------------------------------|
|077|//Это литерал на самом деле означает 7 x 8 + 7 ... или 63 в десятичное форме!|

Целочисленные литералы являются беззнаковыми. Если вы увидите что-то вроде `-10` или `+10`, то это выражения, использующие унарный оператор `-` и унарный оператор `+`.

Диапазон целочисленных литералов десятичных чисел имеет тип данных **int** и должен попадать в диапазон от нуля до 2^31 или до 2 147 483 648.

Обратите внимание, что значение 2^31 на 1 больше, чем значение `Integer.MAX_VALUE`. Литералы от 0 до 2147483647 могут использоваться где угодно, но использование литерала 2147483648 без предшествующего унарного опрератора - вызовет ошибку компиляции. (Иначе говоря, этот литерал зарезервирован для выражения значения `Integer.MAX_VALUE`).

```java
int max = 2147483647;   // Верно
int min = -2147483648;   // Верно
int tooBig = 2147483648;   // Ошибка
```

**Целочисленные литералы типа long**
Литералы типа `long` можно представить путем добавления к числу суффикса `L`. Например:

```java
0L              // десятичное число ноль            (тип 'long')
1L              // десятичное число один            (тип 'long')
2147483648L     // Значение Integer.MAX_VALUE + 1

long big = 2147483648;      // Ошибка
long big2 = 2147483648L;    // Верно
```

Заметим, что литералы `int` и `long` различаются между собой и в других моментах. Например:

```java
int i = 2147483647;
long l = i + 1;         // Выдаст отрицательное значение, поскольку операция сложения
                        // выполняется с использованием 32-битной арифметики, что
                        // приводит к переполнению
long l2 = i + 1L;       // Выдаёт (интуитивно) правильное значение
```

Ссылки: JLS 3.10.1 - Целочисленные литералы.

[к оглавлению Глава 9](#глава-9-литералы)

## Раздел 9.9. Литералы с плавающей точкой



[Раздел 9.1. Использование подчеркивания для улучшения читабельности](#раздел-91-использование-подчеркивания-для-улучшения-читабельности)

[Раздел 9.2. Шестнадцатеричные, восьмеричные и двоичные литералы](#раздел-92-шестнадцатеричные-восьмеричные-и-двоичные-литералы)

[Раздел 9.3. Логические литералы (типа boolean)](#раздел-93-логические-литералы-типа-boolean)

[Раздел 9.4. Строковые литералы](#раздел-94-строковые-литералы)

[Раздел 9.5. Литерал Null](#раздел-95-литерал-null)

[Раздел 9.6. Управляющие последовательности в литералах](#раздел-96-управляющие-последовательности-в-литералах))

[Раздел 9.7. Символьные литералы](#раздел-97-символьные-литералы)

[Раздел 9.8. Целочисленные десятичные литералы](#раздел-98-целочисленные-десятичные-литералы)

[Раздел 9.9. Литералы с плавающей точкой](#раздел-99-литералы-с-плавающей-точкой)