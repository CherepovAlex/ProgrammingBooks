# Глава 9. Литералы

[Раздел 9.1. Использование подчеркивания для улучшения читабельности](#раздел-91-использование-подчеркивания-для-улучшения-читабельности)

[Раздел 9.2. Шестнадцатеричные, восьмеричные и двоичные литералы](#раздел-92-шестнадцатеричные-восьмеричные-и-двоичные-литералы)

[Раздел 9.3. Логические литералы (типа boolean)](#раздел-93-логические-литералы-типа-boolean)

[Раздел 9.4. Строковые литералы](#раздел-94-строковые-литералы)

[Раздел 9.5. Литерал Null](#раздел-95-литерал-null)

[Раздел 9.6. Управляющие последовательности в литералах](#раздел-96-управляющие-последовательности-в-литералах))

[Раздел 9.7. Символьные литералы](#раздел-97-символьные-литералы)

[Раздел 9.8. Целочисленные десятичные литералы](#раздел-98-целочисленные-десятичные-литералы)

[Раздел 9.9. Литералы с плавающей точкой](#раздел-99-литералы-с-плавающей-точкой)

Java-литерал - это синтаксическая единица (т.е. то, что можно найти в исходном коде Java-программы), которая представляет собой какое-то конкретное значение. Примерами являются `1, 0.333F, false, &#39; X&#39;` и `"Hello world\n`.

## Раздел 9.1. Использование подчеркивания для улучшения читабельности

Начиная с Java 7 появилась возможность использовать одно или несколько подчеркиваний (_) для разделения групп цифр в литерале примитивного числа с целью улучшения их читабельности.

Например, эти два объявления полностью эквивалентны:

_Версия>=Java SE 7_
```java
int i1 = 123456;
int i2 = 123_456;
System.out.println(i1 == i2); // true 
```

Это применимо ко всем литералам примитивных чисел, как показано ниже:

_Версия>=Java SE 7_
```java
byte color = 1_2_3;
short yearsAnnoDomini = 2_016;
int SocialSecurityNumber = 999_99_9999;
long CreditCardNumber = 1234_5678_9012_3456L;
float piFourDecimals = 3.14_15F;
double piTenDecimals = 3.14_15_92_65_35;
```

Это также работает для чисел в двоичном, восьмеричном и шестнадцатеричном базисах:

_Версия>=Java SE 7_
```java
short binary = 0b0_1_0_1;
int octal = 07_7_7_7_7_7_7_7_0;
long hexBytes = 0xFF_EC_DE_5E;
```

Существует несколько правил использования символов подчеркивания, которые запрещают их размещение в следующим местах:
+ В начале или в конце числа (например, _123 или 123_ недопустимы).
+ Если символ подчеркивания примыкает к десятичной точке в литерале числа с плавающей запятой (например, недопустимы такие ситуации: 1._23 или 1_.23).
+ Перед суффиксом `F` или `L` (например, неДопустимы запись 1.23_F или 9999999_L).
+ В позициях, где ожидается строка цифра (например, запись 0_xFFFF недопустима).

[к оглавлению Глава 9](#глава-9-литералы)

## Раздел 9.2. Шестнадцатеричные, восьмеричные и двоичные литералы

Шестнадцатеричное число - это значение по основанию 16. В нем 16 цифр, 0-9 и буквы A-F (регистр не имеет значения). A-F соответствует числам 10-15.

Восьмеричное число - это значение по основанию 8, в котором используются цифры 0-7.

Двоичное число - это значение по основанию 2, в котором используются цифры 0 и 1. Все представленные ниже числа дают одно и то же значение - 110:

```java
int dec = 110;          // без префикса --> десятичный литерал
int bin = 0b1101110;    // префикс '0b' --> двоичный литерал
int oct = 0156;         // префикс '0'  --> восьмеричный литерал
int hex = 0x6E;         // префикс '0x' --> шестнадцатеричный литерал
```

Отметим, что синтаксис двоичных литералов был введён начиная с Java 7.

Восьмеричный литерал легко может стать ловушкой для семантических ошибок. Если к десятичному литералу добавить ведущий '0', то можно получить неверное значение:

```java
int a = 0110;       // Вместо 100, a = 64
```

[к оглавлению Глава 9](#глава-9-литералы)

## Раздел 9.3. Логические литералы (типа boolean)

Логические литералы являются самыми простыми литералами в языке программирования Java. Два возможных логических значения представляются литералами `true` и `false`. Они чувствительны к регистру. Например:

```java
boolan flag = true;     // использование литерала 'true'
flag = false;           // использование литерала 'false'
```

[к оглавлению Глава 9](#глава-9-литералы)

## Раздел 9.4. Строковые литералы

Строковые литералы обеспечивают наиболее удобный способ представления строковых объектов в исходном коде языка Java. Строковый литерал состоит из:
+ Открывающего символа двойные кавычки (").
+ Набора символов от нуля и т.д., кроме символа "двойные кавычки" и символа перевода строки (Экранирующий символ косой черты (\) изменяет значение последующих символов; см. раздел "Управляющие последовательности в литералах").
+ Закрывающего символа двойные кавычки.

Пример:

```java
"Hello world"       // Литерал, обозначающий 11-символьную строку String
""                  // Литерал, обозначающий пустую строку (строку нулевой длины)
"\""                // Литерал, обозначающий строку, состоящий из одного символа двойной кавычки
"1\t2\t3\n"         // Еще один литерал, содержащий управляющие последовательности
```

Обратите внимание, что один строковый литерал не может занимать несколько строк исходного кода. Ошибка компиляции появится, если ввести символ перевода строка (или символ конца исходного файла) перед закрывающей двойной кавычкой. Пример:

```java
"Мир Джелло     // Ощибка компиляции (в конце строки!)
```

**Длинные строки**
Если вам необходимо в тексте программы работать со строкой, длина которой превышает ширину экрана, то для удобства работы лучше всего разбить её на несколько литералов и соединить их с помощью оператора конкатенации (+). Например:

```java
String typingPractice = "Быстрый коричневый Лис" +
                        "перепрыгнув через" + 
                        "ленивую собаку";
```

Выражение, подобное приведённому выше, состоящее из строковых литералов и символа "+", удовлетворяет правилам создания строковой константы. Это означает, что данные выражение будет разобрано компилятором и представлено во время выполнения единым объектом типа `String`.

**Интернирование строковых литералов**
Когда файл класса, содержащий строковые литералы, загружается в JVM, соответствующие объекты типа `String` интернируются системой во время выполнения. Это означает, что строковый литерал, используемый в нескольких классах, занимает столько же места, как если бы он использовался только в одном классе.

Более подробную информацию об интернировании и пули строк см. в примере "Пул строк и хранение кучи" в теме "Строки"

[к оглавлению Глава 9](#глава-9-литералы)

## Раздел 9.5. Литерал Null

Литерал Null (записывается как **null**) представляет единственное значение типа null. Приведём несколько примеров

```java
MyClass object = null;
MyClass[] objects = new MyClass[]{new MyClass(), null, new MyClass()};

myMethod(null);

if (objects != null) {
    // Сделайте что-нибудь
        }
```

Тип null является довольно необычным. Он не имеет имени, поэтому его нельзя выразить в исходном коде Java. (И он также не имеет представления во время выполнения).

Единственное назначение типа null - быть типом **null**. Он совместим по присваиванию со всеми ссылочными типами и может быть приведён к любому ссылочному типу. (В последнем случае приведение не влечёт за собой проверку типа во время выполнения программы).

Наконец, **null** обладает тем свойством, что результат операции `null instanceof <SomeReferenceType>` будет всегда **false**, независимо от того, какой тип указан в `<SomeReferenceType>`.

[к оглавлению Глава 9](#глава-9-литералы)

## Раздел 9.6. Управляющие последовательности в литералах

Строковые и символьные литералы предоставляют механизм экранирования, позволяющий отображать коды символов, которые в противном случае были бы недопустимы для отображения в данном литерале. Управляющая последовательность состоит их экранирующего символа обратной косой черты (\), за которым следует один или несколько других символов. Одни и те же управляющие последовательности подходят как для символьных, так и для строковых литералов.

Полный набор управляющих последовательностей выглядит следующим образом:
|**Управляющая последовательность**|**Описание**|
|:-------------------------------------------|:-------------------------------------------------------------------------|
|`\\`|Обозначает символ обратной косой черты (\)|
|`\'`|Обозначает символ одинарной кавычки (')|
|`\"`|Обозначает символ двойной кавычки (")|
|`\n`|Обозначает символ перевода строки (LF)|
|`\r`|Обозначает символ возврата каретки (CR)|
|`\t`|Обозначает символ прогона страницы к началу следующей страницы (HT)|
|`\f`|Обозначает символ прогона страницы к началу следующей страницы (FF)|
|`\b`|Обозначает символ Backspace (BS)|
|`\<octal>`|Обозначает код символа в диапазоне от 0 до 255.|

В приведённом выше примере **<octal>** состоит из одной, двух или трёх восьмеричных цифр ('0'-'7'), которые представляют число от 0 до 255 (десятичное).

Обратите внимание, что обратная косая черта, за которой следует любой другой символ, не входящий в приведённый выше перечень, является недопустимой управляющей последовательностью. Недопустимые управляющие последовательности рассматриваются спецификацией языка Java (JLS-Java® Language Specification) как ошибки компиляции.

Более подробно о недопустимых управляющих последовательностях для литералов символов и строк, а также о JLS можно почитать, перейдя по ссылке: https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.6

**Экранирование в Unicode**

Помимо описанных выше строковых и символьных экранирующих последовательностей, в Java имеется более общий механизм экранирования Unicode, определённый в пункте 3.3 JLS (JLS 3.3. Экранирование Unicode) https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.3

Экранирование Unicode имеет следующий синтаксис:

```bash
'\' 'u' <шестнадцатеричная цифра> < шестнадцатеричная цифра>
<шестнадцатеричная цифра> < шестнадцатеричная цифра>
```

где <шестнадцатеричная цифра > - одно из значений '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F'.

Управляющая последовательность в Unicode сопоставляется компилятором Java символу (строго говоря, 16-битной кодовой единице Unicode) и может использоваться в любом месте исходного кода, где сопоставленные символ является допустимым. Он обычно используется с символьных и строковых литералах, когда в виде литерала необходимо представить символ, не являющийся символом ASCII.

[к оглавлению Глава 9](#глава-9-литералы)

## Раздел 9.7. Символьные литералы

Символьные литералы обеспечивают наиболее удобный способ представления сивольных значений в исходном коде Java. Символьный литерал состоит из:
+ Открывающий символ одинарной кавычки (`'`).
+ Представление символа. Это может быть любой символ, за исключением символа одиночной кавычки или символа перевода строки. Это также может быть управляющая последовательность, которая начинается с символа обратной косой черты (`\`); см. раздел "Управляющая последовательность в литералах".
+ Закрывающий символ одинарной кавычки (`'`).

Например:

```java
char a = 'a';
char doubleQuote = '"';
char singleQuote = '\"';
```

Символ перевода строки в символьном литерале приведёт к ошибке компиляции:

```java
char newline = '
// ошибка компиляции в предыдущей строке
char Newline = '\n'; // Исправление
```

[к оглавлению Глава 9](#глава-9-литералы)

## Раздел 9.8. Целочисленные десятичные литералы

Целочисленные литералы можно использовать там, где требуется значение типа **byte, short, int, long** или **char**. (В данном примере рассматриваются числа в десятичной системе счисления. В других примерах рассматриваются литералы в восьмеричной, шестнадцатеричной и двоичной системах счисления, а также использование знаков подчеркивания для улучшения читаемости).

**Обычные целочисленные литералы**

Наиболее простой и распространённой формой целочисленного литерала является целочисленный литерал, представляющий десятичные числа. Например:

```java
0       //Десятичное число ноль         (тип "int)
1       //Десятичное число один         (тип "int)
42      //Десятичное число сорок два    (тип "int)
```

Необходимо соблюдать осторожность с ведущими нулями. Ведущий нуль приводит к тому, что целочисленный литерал интерпретируется как восьмеричное число, а не десятичное.

```java
077    //Это литерал на самом деле означает 7 x 8 + 7 ... или 63 в десятичное форме!
```

Целочисленные литералы являются беззнаковыми. Если вы увидите что-то вроде `-10` или `+10`, то это выражения, использующие унарный оператор `-` и унарный оператор `+`.

Диапазон целочисленных литералов десятичных чисел имеет тип данных **int** и должен попадать в диапазон от нуля до 2^31 или до 2 147 483 648.

Обратите внимание, что значение 2^31 на 1 больше, чем значение `Integer.MAX_VALUE`. Литералы от 0 до 2147483647 могут использоваться где угодно, но использование литерала 2147483648 без предшествующего унарного опрератора - вызовет ошибку компиляции. (Иначе говоря, этот литерал зарезервирован для выражения значения `Integer.MAX_VALUE`).

```java
int max = 2147483647;   // Верно
int min = -2147483648;   // Верно
int tooBig = 2147483648;   // Ошибка
```

**Целочисленные литералы типа long**
Литералы типа `long` можно представить путем добавления к числу суффикса `L`. Например:

```java
0L              // десятичное число ноль            (тип 'long')
1L              // десятичное число один            (тип 'long')
2147483648L     // Значение Integer.MAX_VALUE + 1

long big = 2147483648;      // Ошибка
long big2 = 2147483648L;    // Верно
```

Заметим, что литералы `int` и `long` различаются между собой и в других моментах. Например:

```java
int i = 2147483647;
long l = i + 1;         // Выдаст отрицательное значение, поскольку операция сложения
                        // выполняется с использованием 32-битной арифметики, что
                        // приводит к переполнению
long l2 = i + 1L;       // Выдаёт (интуитивно) правильное значение
```

Ссылки: JLS 3.10.1 - Целочисленные литералы.

[к оглавлению Глава 9](#глава-9-литералы)

## Раздел 9.9. Литералы с плавающей точкой

Литералы с плавающей точкой представляют значения, которые можно использовать там, где требуется значение типа `float` или `double`. Существует три вида литералов с плавающей запятой.

+ Простая десятичная форма.
+ Экспоненциальная десятичная форма.
+ Шестнадцатеричная формы.

(Правила синтаксиса JLS объединяют обе десятичные формы в одну. Для удобства объяснения мы рассматриваем их отдельно).

Для литералов `float` и `double` существуют отдельные типы литералов, представляемые с помощью суффиксов. Для представления различных форм используются буквы. Эти буквы нечувствительны к регистру.

**Простая десятичная форма**

Простейшая форма литерала с плавающей точкой состоит из одной или нескольких десятичных цифр, десятичной точки (.) и необязательного суффикса (f, F, d или D). Необязательный суффикс позволяет указать, что литерал является значение типа `float` (f или F) или `double` (d или D). По умолчанию (если суффикс не указан) используется значение `double`.

Например

```java
0.0     // соответствует нулю
.0      // также соответствует нулю
0.      // также соответствует нулю
3.14159 // соответствует числу Pi с точностью (примерно!) до 5-го знака после запятой.
1.0F    // литерал `float` 
1.0D    // литерал 'double'. (если суффикс не указан, 'double' используется по умолчанию)
```

**Экспоненциальная десятичная форма**

Экспоненциальная десятичная форма состоит из простой десятичной дроби с экспонентой, которая вводится символом `E` или `e`, после которого следует целое число со знаком. Экспоненциальная часть - это краткое обозначение умножения десятичного представления числа на степень числа 10, как показано на примерах ниже. Также имеется необязательный суффикс, позволяющий различить литералы `float` и `double`. Вот несколько примеров:

```java
1.0E1               // соответствует 1,0 х 10^1 ... или 10,0 (в двойном размере)
1E-1D               // соответствует 1,0 х 10^(-1) ... или 0,1 (в двойном размере)
1.0e10f             // соответствует 1,0 х 10^(10) ... или 10000000000 (float)
```
Размер литерала ограничивается представлением данных типа (`float` или `double`). Ошибка компиляции возникает в случае, если в результате применения умножения в соответствии с показателем степени получается либо слишком большое, либо слишком маленькое значение.

**Шестнадцатеричная форма**

Начиная с Java 6 появилась возможность выражать литералы с плавающей точкой в шестнадцатеричной форме. Шестнадцатеричная форма имеет синтаксис, аналогичный синтаксису простой и экспоненциальной десятичной формам, со следующими отличиями:

+ Каждый шестнадцатеричный литерал с плавающей запятой начинается с нуля (0), после которого следует символ `x` или `X`.
+ В состав цифр числа (но не в экспоненту!) входят также шестнадцатеричные цифры от `a` до `f` и их эквиваленты в верхнем регистре.
+ Экспонента является _обязательной_ и вводится буквой `p` (или `P`) вместе `e` или `E`. Экспоненты представляет собой показатель степени, который является степенью числа 2, а не степенью числа 10.

Приведём несколько примеров:

```java
0x0.0p0f        // это ноль, выраженный в шестнадцатеричной форме (`float`)
0xff.0p19       // это 255,0 x 2^19 (`double`)
```
**Совет**: поскольку шестнадцатеричная форма с плавающей точкой незнакома большинству Java-программистам, рекомендуется использовать её в том случае, если это действительно необходимо.

**Подчеркивания**

Начиная с Java 7, во всех трёх формах представления литералов с плавающей запятой в строках цифр разрешено использовать символы подчеркивания. Это относится и к части, представляющей "экспоненту". См. раздел "Использование символов подчеркивания для улучшения читабельности".

**Особые случаи**

Если литерал с плавающей запятой обозначает число, которое слишком велико или слишком мало для выбранного представления, то есть если число выйдет за пределы +INF или -INF, или число невозможно представить без потери значимости (ситуация, когда результат операции с плавающей запятой становится настолько близким к нулю, что порядок числа выходит за пределы разрядной сетки), эт приведёт к ошибке компиляции. Однако допускается представление в виде литерала ненулевого денормализованного числа.

Синтаксис литералов с плавающей запятой не предусматривает представлений числа в виде литералов для специальных значений IEEE 754, таких как INF и NAN. Если вам необходимо использовать их в своей программе, то рекомендуется использовать константы, определённые в классах `java.lang.Float` и `java.lang.Double`; например, `Float.NaN`, `Float.NEGATIVE_INFINITY` и `Float.POSITIVE_INFINITY`.

[к оглавлению Глава 9](#глава-9-литералы)