# Глава 22. Побитовые операции

## Раздел 22.1. Проверка, установка, сброс и переключение отдельных битов. Использование значения типа long в качестве битовой маски

Предположим, что мы хотим модифицировать бит `n` целочисленного примитива `i` (байт, short, char, int или long).

```java
(i & 1 << n) != 0   // проверяет, установлен ли бит 'n'
i |= 1 << n;        // устанавливает бит 'n' в 1
i &= ~(1 << n);     // устанавливает бит 'n' в 0
i ^= 1 << n;        // переключает значение бита 'n' на противоположное
```

Использование значений типа `long/int/short/byte` в качестве битовой маски:

```java
public class BitMaskExample {
    private static final long FIRST_BIT = 1L << 0;
    private static final long SECOND_BIT = 1L << 1;
    private static final long THIRD_BIT = 1L << 2;
    private static final long FOURTH_BIT = 1L << 3;
    private static final long FIFTH_BIT = 1L << 4;
    private static final long BIT_55 = 1L << 54;

    public static void main(String[] args) {
        checkBitMask(FIRST_BIT | THIRD_BIT | FIFTH_BIT | BIT_55);
    }
    
    private static void checkBitMask(long bitmask) {
        System.out.println("ПЕРВЫЙ_БИТ: " + ((bitmask & FIRST_BIT) != 0));
        System.out.println("ВТОРОЙ_БИТ: " + ((bitmask & SECOND_BIT) != 0));
        System.out.println("ТРЕТИЙ_БИТ: " + ((bitmask & THIRD_BIT) != 0));
        System.out.println("ЧЕТВЕРТЫЙ_БИТ: " + ((bitmask & FOURTH_BIT) != 0));
        System.out.println("ПЯТЫЙ_БИТ: " + ((bitmask & FIFTH_BIT) != 0));
        System.out.println("БИТ_55: " + ((bitmask & BIT_55) != 0));
    }
}
```

Программа выведет на экран

 ПЕРВЫЙ_БИТ: **true**
 ВТОРОЙ_БИТ: **false**
 ТРЕТИЙ_БИТ: **true**
 ЧЕТВЕРТЫЙ_БИТ: **false**
 ПЯТЫЙ_БИТ: **true**
 БИТ_55: **true**

Это полностью соответствует той маске, которую мы передали в качестве параметра методу checkBitMask: 
`FIRST_BIT | THIRD_BIT | FIFTH_BIT | BIT_55 // ПЕРВЫЙ_БИТ | ТРЕТИЙ_БИТ | ПЯТЫЙ_БИТ | БИТ_55`

[к оглавлению Глава 22](#глава-22-побитовые-операции)

## Раздел 22.2. Класс java.util.BitSet

Начиная с версии 1.7 в Java существует класс `java.util.BitSet`, предоставляющий простой и удобный интерфейс для 
проведения побитовых операций: 

```java
final BitSet bitSet = new BitSet(8);    // по умолчанию все биты сброшены, создается новый BitSet

IntStream.range(0, 8).filter(i -> i % 2 == 0).forEach(bitSet::set);    // {0, 2, 4 ,6} поток включает лампочку с номером i

bitSet.set(3);  // {0, 2, 3, 4, 6} лампочку номер 3 — включить"

bitSet.set(3, false);   // {0, 2, 4, 6} лампочку номер 3 — установить в состояние false (выключить)

final  boolean b = bitSet.get(3);   // b = false проверить, горит ли лампочка номер 3

bitSet.flip(6); //  {0, 2, 4} переключить лампочку номер 6

bitSet.set(100);    // {0, 2, 4, 100} - расширяется автоматически
```

`BitSet` реализует свойства `Clonable` и `Serializable`, а под капотом все значение битов хранятся в поле, которое 
представляет собой массив `long[] words`, размер которого автоматически увеличивается.

Также поддерживается набор логических побитовых операций, таких как `and`, `or`, `xor` и `andNot` (_и-не_):

```java
bitSet.and(new BitSet(8));
bitSet.or(new BitSet(8));
bitSet.xor(new BitSet(8));
bitSet.andNot(bew BitSet(8));
```

[к оглавлению Глава 22](#глава-22-побитовые-операции)

## Раздел 22.3. Как проверить, является ли значение степенью числа 2

Если целое число `x` является степенью числа `2`, то в нем установлен только _один_ бит, и если выполнить операцию 
`x - 1`, то в числе будут установлены все последующие биты. Например: двоичный код `4` - это `100`, а двоичный код 
`4 - 1 = 3` - `011`, что удовлетворяет вышеуказанному условию. Ноль не является степенью `2` и должен проверять явным 
образом. 

```java
boolean isPowerOfTwo(int x) {
    return (x != 0) && ((x & (x - 1)) == 0);
}
```

**Применение такой проверки для сдвига влево и сдвига вправо.**

Предположим, что на есть три вида разрешений - **READ**, **WRITE** и **EXECUTE** (разрешения на **ЧТЕНИЕ**, **ЗАПИСЬ** 
и **ВЫПОЛНЕНИЕ**). Каждое разрешение может находиться в диапазоне от 0 до 7. (Предположим, что система счисления 4-х 
битная). 

`RESOURCE = READ WRITE EXECUTE (12-битное число)
RESOURCE = 0100 0110 0101 = 4 6 5 (12-битное число)`

- Как мы можем _выделить младшие 3 разряда_ из 12-битного числа, что затем узнать, установлено разрешение 
**EXECUTE или нет**?

`0100 0110 0101
0000 0000 0111 (&)
0000 0000 0101 = 5`

- Итак, теперь мы можем узнать, установлено ли разрешение на выполнение (**EXECUTE**) для **RESOURCE** или нет. Теперь 
решим задачу с выделением из 12-ти битного числа RESOURCE 3-х разрядов, которые определяют разрешение на чтение 
- (**READ**). Как это можно сделать?

`0100 0110 0101
0111 0000 0000 (&)
0100 0000 0000 = 1024`

До сих пор все было верно? Но появился один нюанс. Значение для разрешения чтения (READ) скрыто где-то в числе 1024. 
Не волнуйтесь, именно для этого у нас есть операторы сдвига. Мы видим, что биты, отвечающие за заршение READ, находятся 
на 8 разрядов левее, чем нам надо, поэтому если применить оператор двига, то они окажутся в самом правом углу. Давайте
поробуем это сделать:

`0100 0000 0000 >> 8 => 0000 0000 0100`

поскольку это положительное число, то старшие разряды заменяются на 0. Поэтому, если знак не важен, то используйте 
оператор беззнакового сдвига вправо).

Теперь, наконец, у нас действительно есть значение разрашения **READ**, которое равно 4. 

Теперь, допустим, нам даны разрешения READ, WRITE, EXECUTE и нам необходимо их установить для ресурса RESOURCE. Как мы
можем это сделать?

Пусть нам даные разрешения в двоичном виде. (По-прежнему предполагается, что все числа представлены четырьмя битами.)

`READ = 0001
WRITE = 0100
EXECUTE = 0110`

Если вы думаете, что мы просто сделаем: `READ | WRITE | EXECUTE`, вы окажетесь отчасти правы, но не совсем. Смотрите, 
что произойдёт, если мы выполним ИЛИ со всеми этими значениями

`READ | WRITE | EXECUTE = 0001 | 0100 | 0110 => 0111`

Но на самом деле нам необходимо получить разрешения, представленные в виде `0001 0100 0110`.

Какой информацией мы располагаем, чтобы сделать это? Разрешение **READ** отстоит на 8 бит от начала слова, **WRITE** - 
в 4 битах, а **EXECUTE** - на своём месте, там, где нам и надо. Разрешения **RESOURCE** представлены числом с количество 
разрядов, равным 12 (в нашем примере). В разных системах количество бит в числе будет отличаться.

`(READ << 8) | (WRITE << 4) | (EXECUTE)
0000 0000 0001 << 8 (READ)
0001 0000 0000 (сдвиг влево на 8 бит)
0000 0000 0100 << 4 (WRITE)
0000 0100 0000 (сдвиг влево на 4 бита)
0000 0000 0001 (EXECUTE)`

Теперь, если сложить результаты вышеприведённого сдвига, то получится что-то вроде:

`0001 0000 0000 (READ)
0000 0100 0000 (WRITE)
0000 0000 0001 (EXECUTE)
0001 0100 0001 (PERMISSIONS)`

[к оглавлению Глава 22](#глава-22-побитовые-операции)

## Раздел 22.4. Знаковый и беззнаковый сдвиг

В Java все числовые примитивы являются знаковыми. Например, `int` всегда представляет значения из диапазона 
[-2^31-1, 2^31], используя первый бит для обозначение знака (-1 для отрицательного зачения, 0 для положительного).

Базовые операторы сдвига >> и << являются знаковыми операторами. Они сохраняют знак значения.

Однако часто программисты использую числа для хранения _беззнаковых значений_. Для int это означает смещение диапазона 
на [0, 2^32 - 1], чтобы иметь вдвое больше значение, чем в случае int со знаком.

Для опытных пользователей бит для знака не имеет никакого значения. Поэтому в Java появился оператор сдвига влево >>>,
игнорирующий этот бит.

              начальное значение:                    4 (                               100)
     знаковый сдвиг влево: 4 << 1                    8 (                              1000)
    знаковый сдвиг вправо: 4 >> 1                    2 (                                10)
`Беззнаковый сдвиг вправо: 4 >>> 1                    2 (                                10)`
            
               начальное значение:                   -4 (   11111111111111111111111111111100)
     знаковый сдвиг влево: -4 << 1                   -8 (   11111111111111111111111111111000)
    знаковый сдвиг вправо: -4 >> 1                   -2 (   11111111111111111111111111111110)
`Беззнаковый сдвиг вправо: -4>>> 1           2147483646 (    1111111111111111111111111111110)`

Почему нет оператора <<< ?

Это следует из предполагаемого определения сдвига вправо. Так как он заполняет освободившиеся места слева, то не нужно
принимать решение относительного знакового разраяда. Как следствие, нет необходимости в двух разных операторах.

Более подробный ответ см. по ссылке  https://www.quora.com/Why-is-there-no-unsigned-left-shift-operator-in-Java

[к оглавлению Глава 22](#глава-22-побитовые-операции)

## Раздел 22.5. Вычисление степень числа 2



[к оглавлению Глава 22](#глава-22-побитовые-операции)

[Раздел 22.1. Проверка, установка, сброс и переключение отдельных битов. Использование значения типа long в качестве битовой маски](#раздел-221-проверка-установка-сброс-и-переключение-отдельных-битов-использование-значения-типа-long-в-качестве-битовой-маски)

[Раздел 22.2. Класс java.util.BitSet](#раздел-222-класс-javautilbitset)

[Раздел 22.4. Знаковый и беззнаковый сдвиг](#раздел-224-знаковый-и-беззнаковый-сдвиг)

[Раздел 22.5. Вычисление степень числа 2](#раздел-225-вычисление-степень-числа-2)



























