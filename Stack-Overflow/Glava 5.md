# Глава 5. Компилятор Java - 'javac'

[Раздел 5.1. Команда `javac` - начало работы](#раздел-51-команда-javac---начало-работы)

[Раздел 5.2. Компиляция для другой версии Java](#раздел-52-компиляция-для-другой-версии-java)

## Раздел 5.1. Команда `javac` - начало работы

**Простой пример**

Предположим, что файл "HelloWorld.java" содержит следующую программу на языке Java:
```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello world!");
    }
}
```

Скомпилировать приведённый выше файл можно с помощью следующей команды:

```bash
$ javac HelloWorld.java
```

В результате создаётся файл с именем "HelloWorld.class", который мы можем запустить на выполнение следующим образом:

```bash
$ java HelloWorld
Hello world!
```

Отметим здесь следующие ключевые моменты:
1. Имя исходного файла "HelloWorld.java" должно совпадать с именем класса в исходном файле... которым является HelloWorld. Если они не совпадают, то будет выдана ошибка компиляции.
2. Имя файла байт-кода "HelloWorld.class" соответствует имени класса. Если переименовать файл "HelloWorld.class", то при попытке его запуска возникнет ошибка.
3. При запуске Java-приложения с помощью загрузчик java указывается имя класса, а не имя файла, содержащего байт-код.

**Пример с пакетами**

В большинстве программ на языке Java, получившим практическое применение, используются пакеты для организации пространства имен классов и снижения раски случайного столкновения имен классов.

Если бы мы хотели объявить класс HelloWorld в пакете с именем com.example, то текст программы "HelloWorld.java" выглядел бы следующим образом:

```java
package com.example;

public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello world!");
    }
}
```

Этот файл с текстом программы должен храниться в дереве каталогов, структура которого соответствует имени пакета.
```java
.       # текущий каталог (для данного примера)
|
----com
    |
    ---- example
         |
         ----HelloWorld.java
```

Мы можем компилировать приведённый выше файл с помощью команды:
```bash
$ javac com/example/HelloWorld.java
```

В результате получается файл с именем "com/example/HelloWorld.class", т.е. после компиляции структура файла должна выглять следующим образом:

```java
.       # текущий каталог (для данного примера)
|
----com
    |
    ---- example
         |
         ----HelloWorld.java
         ----HelloWorld.class
```

Затем мы можем запустить приложение следующим образом:

```bash
$ javac com.example.HelloWorld
Hello world!
```

Здесь следует отметить следующие моменты:
1. Структура каталогов должна соответствовать структуре имен пакетов.
2. При запуске класса необходимо указывать полное имя класса, т.е. "com.example.HelloWorld", а не просто "HelloWorld".
3. Не обязательно компилировать и запускать программу на языке Java из текущего каталога. Мы просто сделали здесь это для примера.

**Компиляция нескольких файлов одновременно с помощью 'javac'.**

Если ваше приложение состоят из нескольких файлов исходного кода (а большинство из них так и есть!), вы можете компилировать их по одному. В качестве альтернативы можно скомпилировать несколько файлов одновременно, перечислив их пути:

```bash
$ java Foo.java Bar.java
```

или использовав символы подстановки для имен файлов в командной строке

```bash
$ javac *.javac
$ javac com/example/*.javac
$ javac */**/*.java # Работает в Zsh или при включенной globstar в вашей оболочке
```

В результате будет скомпилированы все исходные файлы Java, расположенные соответственно в текущем каталоге, в каталоге "com/example" и рекурсивно во всех дочерних каталогах. Третья альтернатива - предоставить список имен исходных файлов (и опций компилятора) в виде специального файла. Например:

```bash
$ javac @sourcefiles
```

При этом файл sourcefiles содержит следующие строки:

```bash
Foo.java
Bar.java
com/example/HelloWorld.java
```

_Примечание_: компиляция кода подобным образом целесообразна для небольших проектов, выполняемых одним человеком, и для разовых программ. В противном случае целесообразно выбрать и и спользовать средство сборки Java. В качестве альтернативы большинство программистов используют IDE, поддерживающие язык Java (например, NetBeans, Eclipse, Intellj IDEA), которые предлагают встроенный компилятор и поэтапную сборку "проектов".

**Часто используемые опции компилятора 'javac'**

Вот несколько опций для команды `javac`, которые могут быть вам полезны:
+ Опция `-d` задаёт целевой каталог для записи файлов ".class"
+ Опция `-sourcepath` задаёт путь поиска исходников программ на языке Java.
+ Опция `-cp` или `-classpath` задаёт путь поиска внешних и ранее скомпилированных классов. Более подробную информацию о classpath и о том, как его указывать см. в разделе Classpath в оглавлении.
+ Опция `-version` выводит информацию о classpath и о том, как его указывать, см. в разделе "Classpath".

Более полный справочник по команде javac расположен на странице руководства Oracle по javac по адресу http://docs.oracle.com/javase/8/docs/technotes/tools/windows/javac.html

[к оглавлению Глава 5](#глава-5-компилятор-java---javac)

## Раздел 5.2. Компиляция для другой версии Java

Язык программирования Java (и его среда выполнения JRE) претерпел множество изменений с момента своего первого выхода в свет. Эти изменения включают:

+ Изменения в синтаксисе и семантике языка программирования Java.
+ Изменения в API, предоставляемых стандартными библиотеками классов Java.
+ Изменения в наборе инструкций Java (байт-код) и формат файлов классов.

За очень редким исключением (например, ключевое слово `enum`, изменения в некоторых "внутренних" классах и т.д.), эти изменения обратно совместимы.

+ Java-программа, скомпилированная с использованием старой версии инструментария Java, будет работать на платформе Java более новой версии без перекомпиляции.
+ Java-программа, написанная на старой версии Java, будет успешно компилироваться новым компилятором Java.

**Компиляция старого программного Java-кода с помощью нового компилятора**

Если необходимо (перекомпилировать) старый Java-код на более новой платформе Java для дальнейшей работы на новой платформе, то, как правило, для компиляции не нужно задавать никаких специальных опций. В некоторых случаях (например, если в качестве идентификатора используется `enum`), можно использовать опцию `-source`, чтобы отключить новый синтаксис. Например, для следующего класса:

```java
public class OldSyntax {
    private static int enum;    // недопустимо в Java 5 и более поздних версиях
}
```

для компиляции класса с помощью компилятора Java 5 (или более поздней версии) необходимо выполнить следующую команду:

```bash
$ javac -source 1.4 OldSyntax.java
```

**Компиляция для запуска на старой платформе**

Если вам необходимо скомпилировать программу на языке Java для работы на более старых Java-платформах, то самый простой подход - установить JDK для самой старой платформы, а именно ту версию, которую необходимо поддерживать, и затем в своих сборках использовать компилятор этого JDK.

Можно скомпилировать код и более новым компилятором Java, но здесь есть свои сложности. Прежде всего необходимо выполнить несколько важных предварительных условий:

+ Компилируемый код не должен использовать конструкции языка Java, которые не были доступны в той версии Java, на которую вы ориентируетесь.
+ Код не должен зависеть от стандартных Java-классов, полей, методов и т.д., которые ыли недоступны в старых платформах.
+ Сторонние библиотеки, от которых зависит код, также должны быть собраны для старшей платформы, используя опцию `-target`. Например, команда

```bash
$ javac -targer 1.4 SomeClass.java
```

скомпилирует приведённый выше класс с помощью байт-кода, совместимого с JVM Java 1.4 или более поздней версии. (Фактически опция `-source` подразумевает совместимую с ней опцию `-target`, поэтому `javac -source 1.4 ...` будет иметь тот же эффект. Взаимосвязь между `-source` и `-target` описана в документации Oracle).

При этом, если просто использовать `-target` или `-source`, то компиляция всё равно будет воспроизводиться на основе стандартных библиотек классов, предоставляемых текущим JDK_компилятором. Если не соблюдать осторожность, то можно получить классы с правильной версией байт-кода, но с зависимостями от недоступных API. Решением является использование опции `-bootclasspath`. Например, по команде:

```bash
$ javac -target 1.4 --bootclasspath path/to/java1.4/rt.jar SomeClass.java
```

текст программы будет компилироваться с альтернативным набором библиотек времени выполнения. Если компилируемый класс имеет (случайные) зависимости от более новых библиотек, то это приведёт к ошибкам компиляции.

[к оглавлению Глава 5](#глава-5-компилятор-java---javac)
