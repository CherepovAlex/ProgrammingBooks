Разбор работы программы
Программа перемещает все элементы массива, равные заданному значению val, в конец массива, сохраняя относительный порядок остальных элементов.

Исходные данные
java
int[] nums = {3, 2, 2, 3};
int val = 3;
Логика работы метода moveValToEnd
1. Инициализация
java
int write = 0;
Создается переменная write, которая будет указывать позицию, куда нужно записывать следующий элемент, не равный val.

2. Первый проход по массиву (for-each цикл)
java
for (int num : nums) {
    if (num != val) {
        nums[write++] = num;
    }
    System.out.println(Arrays.toString(nums));
}
Пошаговое выполнение:

Первая итерация (num = 3)

num == val (3 == 3) → условие if не выполняется

Массив остается [3, 2, 2, 3]

write остается 0

Вторая итерация (num = 2)

num != val (2 != 3) → выполняется if

nums[0] = 2 → массив становится [2, 2, 2, 3]

write увеличивается до 1

Третья итерация (num = 2)

num != val (2 != 3) → выполняется if

nums[1] = 2 → массив становится [2, 2, 2, 3]

write увеличивается до 2

Четвертая итерация (num = 3)

num == val (3 == 3) → условие if не выполняется

Массив остается [2, 2, 2, 3]

write остается 2

После этого цикла массив выглядит как [2, 2, 2, 3], а write = 2.

3. Заполнение оставшихся позиций значением val
java
while (write < nums.length) {
    nums[write++] = val;
}
nums.length = 4, write = 2

Итерации:

nums[2] = 3 → массив [2, 2, 3, 3], write = 3

nums[3] = 3 → массив [2, 2, 3, 3], write = 4

Цикл завершается, так как write больше не меньше nums.length

Итоговый результат
Массив преобразуется из [3, 2, 2, 3] в [2, 2, 3, 3].

Ключевые моменты алгоритма
Два этапа работы:

Первый этап: перезапись массива, пропуская элементы равные val

Второй этап: заполнение оставшихся позиций значением val

Индекс write:

Указывает, куда будет записан следующий элемент, не равный val

После первого цикла показывает, сколько элементов не равны val

Стабильность:

Относительный порядок элементов, не равных val, сохраняется

Сложность:

Алгоритм работает за O(n) времени (один полный проход по массиву + частичный)

Использует O(1) дополнительной памяти (только переменная write)

Этот подход эффективен и часто используется для подобных задач модификации массивов на месте.