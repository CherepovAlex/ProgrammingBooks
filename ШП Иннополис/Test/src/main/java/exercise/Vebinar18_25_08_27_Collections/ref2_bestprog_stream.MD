# Потоки данных. Stream API. Общая информация

## 1. Прикладной потоковый интерфейс Stream API. Характерные особенности

Начиная с версии JDK 8 в языке Java были введены средства работы с потоками данных, которые получили название прикладной потоковый интерфейс API (**Stream Application Programming Interface**). 
Работа со средствами **Stream API** базируется на использовании _лямбда-выражений_.

Характерными особенностями этого интерфейса является использование различных операций над потоками данных. 
К этим операциям можно отнести:
+ поиск данных;
+ модификация данных;
+ фильтрование потока данных для получения нового потока;
+ сортировка данных;
+ другие разнообразные манипуляции над данными.

Операции над потоками данных выполняются на основе формирования соответствующих запросов. 
Интерфейс Stream API хорошо подходит для обработки больших массивов данных с применением механизмов распараллеливания.

## 2. Поток данных. Определение

Под понятием «поток данных» подразумевается канал передачи данных. 
Для потока данных определяется понятие источника данных. 
Источниками данных могут быть массив, коллекция, список и тому подобное. 
Поток данных оперирует этими источниками. 
Поток данных еще можно определить как последовательность объектов.

В самом потоке данные не сохраняются, а только перемещаются при их обработке (фильтровании, сортировке и т.д.). 
При обработке потока данных источник данных не изменяется. 
Это означает, что при сортировке данных создается новый отсортированный поток данных, а начальный источник остается несортированным.

## 3. Интерфейсы из пакета java.util.stream

### 3.1. Интерфейс BaseStream. Методы

Средства работы с потоками данных _Stream API_ являются составляющей пакета `java.util.stream`. 
Данный пакет содержит набор потоковых _интерфейсов_, образующих иерархию.

Базовым поточным интерфейсом является `BaseStream`, который имеет следующее объявление

```java
interface BaseStream<T, S extends BaseStream<T, S>>
```

здесь:
+ `T` – тип элементов в потоке данных;
+ `S` – тип потока данных, который расширяет интерфейс `BaseStream`.

В интерфейсе `BaseStream` объявляется ряд методов, перечисленных ниже.

1. Закрыть поток данных

`void close()`

Метод _закрывает_ вызывающий поток данных. Обязательно нужно закрывать потоки данных, связанные с файлами.

2. Определить, является ли параллельным поток данных

`boolean isParallel()`

Метод возвращает `true`, если поток данных есть параллельным.

3. Получить итератор для потока данных

`Iterator<T> iterator()`

здесь: 
+ `T` – тип элементов потока данных.

Метод получает итератор для потока данных и возвращает _ссылку_ на него. Метод является _конечной_ операцией.

4. Задать обработчик события закрытия потока.

`S onClose(Runnable handler)`

здесь:
+ `S` – тип новосозданного потока данных;
+ `handler` – метод, содержащий код, который должен выполниться при закрытии потока.

Метод `onClose()` возвращает _новый_ поток данных с заданным обработчиком события закрытия. 
Указанный обработчик вызывается при _закрытии_ потока данных. Метод является _промежуточной_ операцией.

5. Вернуть паралельный поток данных

`S parallel()`

здесь:
+ `S` – тип новосозданного параллельного потока данных.

Метод возвращает _параллельный_ поток данных основываясь на вызывающем потоке данных. 
Если вызывающий поток данных является _параллельным_, то он и возвращается. Это _промежуточная_ операция.

6. Вернуть последовательный поток данных

`S sequential()`

здесь:
+ `S` – тип новосозданного последовательного потока данных.

Метод возвращает _последовательный_ поток данных на основе вызывающего потока данных. 
Если вызывающий поток данных уже является _последовательным_, то этот поток и возвращается.

Метод является _промежуточной_ операцией.

7. Получить итератор-разделитель

`Spliterator<T> spliterator()`

здесь:
+ `T` – тип элементов потока данных.

Метод получает итератор-разделитель для потока данных и возвращает _ссылку_ на него. Метод является _конечной_ операцией.

8. Вернуть неупорядоченный поток данных

`S unordered()`

здесь:
+ `S` – тип результирующего неупорядоченного потока данных.

Метод возвращает _неупорядоченный_ поток данных на основе вызывающего потока данных. 
Если вызывающий поток данных уже есть _неупорядоченным_, то именно он и возвращается. Метод является _промежуточной_ операцией.

### 3.2. Интерфейс Stream. Обзор методов

От базового интерфейса `BaseStream` унаследованы несколько интерфейсов. 
Наиболее употребительным из них является обобщенный интерфейс `Stream<T>`, который имеет следующее объявление

`interface Stream<T>`

здесь:
+ `T` – тип элементов в потоке данных.

В интерфейсе `Stream<T>` определяется ряд методов, которые можно использовать при _обработке_ потоков данных. Эти методы описываются далее.

1. Накопить элементы в контейнере

`<R, A> R collect(Collector<? super T, A, R> collector)`

здесь:
+ `R` – тип контейнера, в котором накапливаются элементы;
+ `T` – тип елемента из вызывающего потока данных;
+ `A` – внутренний накопительный тип;
+ `collector` – функция накопления, которая представлена лямбда-выражением. Функция определяет _порядок_ выполнения процесса накопления.

Метод реализует операцию изменяемого сведения. Метод _накапливает_ элементы в изменяющемся контейнере и возвращает этот контейнер.

Метод `collect()` является _конечной_ операцией.

2. Получить количество элементов в потоке

`long count()`

Метод `count() ` является _конечной_ операцией.

3. Выработать новый поток данных по заданному фильтру

`Stream<T> filter(Predicate<? super T> predicate)`

тут:
+ `T` – тип элементов потока данных;
+ `predicate` – условие, по которому формируется новый поток данных.

Метод `filter()` является _промежуточной_ операцией.

4. Выполнить действие над каждым элементом потока данных

`void forEach(Consumer<? super T> action)`

здесь:
+ action — ссылка на стандартный функциональный интерфейс `Consumer<T>`.  
В интерфейсе `Consumer<T>` реализован метод, который выполняет _некоторое действие_ над элементом типа `T`.  
Это действие будет применяться к каждому элементу потока данных. 

Метод `forEach()` является _конечной_ операцией.

5. Применить указанную функцию отображения для обобщенного типа `R`

`<R> Stream<R> map(Function<? super T, ? extends R> map_function)`

тут:
+ `map_function` – функция _отображения_, которая применяется к элементам из вызывающего потока данных. 
Результатом работы функции есть _новый_ поток данных, который содержит эти элементы.

Это _промежуточная_ операция.

6. Применить функцию отображения для потока типа `DoubleStream`

`DoubleStream mapToDouble(ToDoubleFunctin <? super T> map_function)`

здесь:
+ `map_function` — функция отображения, которая применяется к элементам вызывающего потока данных. 
Результатом работы функции `mapToDouble()` является _новый_ поток данных типа `DoubleStream`. 
Тип элементов в потоке устанавливается `Double`. Это _промежуточная_ операция.

7. Применить функцию отображения для потока типа `IntStream`

`IntStream mapToInt(ToIntFunctin <? super T> map_function)`

здесь:
+ `map_function` — функция отображения, которая применяется к _элементам_ вызывающего потока данных.

Результатом работы функции `mapToInt()` является _новый_ поток данных типа `IntStream`. 
Тип элементов в потоке устанавливается `Integer`. Это _промежуточная_ операция.

8. Применить функцию отображения для потока типа `LongStream`

`LongStream mapToLong(ToLongFunctin <? super T> map_function)`

здесь:
+ `map_function` — функция отображения, которая применяется к _элементам_ вызывающего потока данных.

На основе заданной функции отображения создается _новый_ поток данных типа `LongStream` содержащий эти элементы. Это _промежуточная_ операция.

9. Поиск минимального значения в потоке данных типа `T`

`Optional<T> min(Comparator<? super T> comparator)`

здесь: 
+ `comparator` — ссылка на метод, в котором описывается _код сравнения_ двух элементов типа `T`. 
По коду этого метода определяется элемент с _минимальным_ значением в потоке данных.

Метод `min()` является _конечной_ операцией.

10. Поиск максимального значения в потоке данных типа `T`

`Optional<T> max(Comparator<? super T> comparator)`

здесь: 
+ `comparator` — ссылка на метод, в котором описывается _код сравнения_ двух элементов типа `T`. 
+ На основе кода этого метода определяется элемент с _максимальным_ значением в потоке данных.

Метод `max()` есть _конечной_ операцией. 

11. Реализовать сведение для элементов в вызывающем потоке данных

`T reduce (T identityVal, BinaryOperator<T> storage)`

здесь: 
+ `identityVal` — значение идентичности, которое используется в сочетании с функцией `storage`, для получения _такого же_ элемента без изменений;
+ `storage` — функция, которая оперирует двумя значениями типа `T` и возвращает результат. 

Метод `reduce()` является _конечной_ операцией.

12. Сортировка потока данных

`Stream<T> sorted()`

Метод `sorted()` предназначен для _сортировки_ потока данных в _естественном_ порядке (по возрастанию элементов). 
Если нужно _изменить_ порядок сортировки элементов, то нужно реализовать стандартный функциональный интерфейс `Comparator<T>` и передать лямбда-выражение в данный метод. 
Это _конечная_ операция.

13. Создать массив из элементов в вызывающем потоке данных

`Object[] toArray()`

Метод `toArray()` используется для _преобразования_ потока данных в _массив_ типа `Object[]`. 
Метод позволяет оперировать _любыми_ типами (`Integer`, `Double`, `Float` и т.д.).
