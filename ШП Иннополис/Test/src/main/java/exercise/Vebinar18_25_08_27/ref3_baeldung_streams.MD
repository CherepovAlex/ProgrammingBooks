# Учебное пособие по Java Stream API

## 1. Общий обзор

В этом подробном руководстве мы рассмотрим практическое применение Java Streams, начиная с их появления в Java 8 и
заканчивая последними улучшениями в Java 9.

Чтобы понять этот материал, читателям необходимо иметь базовые знания о Java 8 (лямбда-выражения, `Optional`, ссылки на
методы) и **Stream API**.

## 2. Создание потока

Существует множество способов создать экземпляр потока из различных источников.
После создания экземпляр не будет изменять свой источник, что позволяет создавать несколько экземпляров из одного
источника.

### 2.1. Пустой поток

В случае создания пустого потока мы должны использовать метод **`empty()`**.

`Stream<String> streamEmpty = Stream.empty();`

При создании мы часто используем метод `empty()` , чтобы не возвращать `null` для потоков без элементов:

```java
public Stream<String> streamOf(List<String> list) {
    return list == null || list.isEmpty() ? Stream.empty() : list.stream();
}
```

### 2.2. Поток коллекции

Мы также можем создать поток любого типа `Collection` (`Collection`, `List`, `Set`):

```java
Collection<String> collection = Arrays.asList("a", "b", "c");
Stream<String> streamOfCollection = collection.stream();
```

### 2.3. Поток массива

Массив также может быть источником потока:

```java
Stream<String> streamOfArray = Stream.of("a", "b", "c");
```

Мы также можем создать поток на основе существующего массива или его части:

```java
String[] arr = new String[]{"a", "b", "c"};
Stream<String> streamOfArrayFull = Arrays.stream(arr);       // весь
Stream<String> streamOfArrayPart = Arrays.stream(arr, 1, 3); // часть
```

### 2.4. Stream.builder()

**в правой части выражения должен быть дополнительно указан нужный тип,при использовании конструктора** в противном
случае метод `build()` создаст экземпляр `Stream<Object>`:

```java
Stream<String> streamBuilder = Stream.<String>builder().add("a").add("b").add("c").build();
```

### 2.5. Stream.generate()

Метод **`generate()`** принимает `Supplier<T>` для генерации элементов.
Поскольку результирующий поток бесконечен, разработчик должен указать желаемый размер, иначе метод `generate()` будет
работать до тех пор, пока не будет достигнут предел памяти:

```java
Stream<String> streamGenerated = Stream.generate(() -> "element").limit(10);
```

Приведённый выше код создаёт _последовательность_ из десяти строк со значением «_элемент_».

### 2.6. Stream.iterate()

Другой _способ_ создания бесконечного потока — использование метода `iterate()`:

```java
Stream<Integer> streamIterated = Stream.iterate(40, n -> n + 2).limit(20);
```

Первым элементом результирующего потока является первый параметр метода `iterate()` (т.е. `40`).
При создании каждого последующего элемента указанная функция применяется к предыдущему элементу.
В приведённом выше примере вторым элементом будет `42`.

### 2.7. Поток примитивов

В _Java 8_ появилась возможность создавать потоки из трёх примитивных типов: `int`, `long` и `double`.
Поскольку `Stream<T>` — это _универсальный_ интерфейс, а примитивные типы нельзя использовать в качестве параметра типа
в универсальных классах, были созданы три новых специальных интерфейса: `IntStream`, `LongStream`, `DoubleStream`.

Использование новых интерфейсов позволяет избежать ненужного автоупаковывания, что повышает производительность:

```java
IntStream intStream = IntStream.range(1, 3);
LongStream longStream = LongStream.rangeClosed(1, 3);
```

Метод **`range(int startInclusive, int endExclusive)`** создаёт _упорядоченный_ поток от первого до второго параметра.
Он увеличивает значение последующих элементов на `1`.
Результат _не включает_ последний параметр, это просто верхняя граница последовательности.

Метод **`rangeClosed(int startInclusive, int endInclusive)`**  делает то же самое, но с одним отличием: второй элемент
_включается_ в диапазон.
Мы можем использовать эти два метода для создания любого из трёх типов потоков примитивов.

Начиная с _Java 8_, класс `Random` предоставляет широкий спектр методов для создания потоков примитивов.
Например, следующий код создаёт `DoubleStream`, состоящий из трёх элементов:

```java
Random random = new Random();
DoubleStream doubleStream = random.doubles(3);
```

### 2.8. Поток String

Мы также можем использовать `String` в качестве источника для создания потока с помощью метода `chars()` класса
`String`.
Поскольку в JDK нет интерфейса для `CharStream`, мы используем `IntStream` для представления потока символов.

```java
IntStream streamOfChars = "abc".chars();
```

В следующем примере `String` разбивается на _подстроки_ в соответствии с указанным _RegEx_:

```java
Stream<String> streamOfString = Pattern.compile(", ").splitAsStream("a, b, c");
```

### 2.9. Поток файлов

Кроме того, класс _Java NIO Files_ позволяет нам создать `Stream<String>` текстового файла с помощью метода `lines()`.
Каждая строка текста становится элементом потока:

```java
Path path = Paths.get("C:\\file.txt");
Stream<String> streamOfStrings = Files.lines(path);
Stream<String> streamWithCharset = Files.lines(path, Charset.forName("UTF-8"));
```

`Charset` можно указать в качестве аргумента метода` lines()`.

## 3. Ссылка на поток

Мы можем создать _экземпляр_ потока и получить к нему доступ, пока вызываются только _промежуточные_ операции. 
Выполнение _терминальной_ операции делает поток _недоступным_.

Чтобы продемонстрировать это, давайте на время забудем о том, что лучше всего объединять последовательность операций в цепочку. 
Несмотря на излишнюю многословность, технически следующий код корректен:

```java
Stream<String> stream = Stream.of("a", "b", "c").filter(element -> element.contains("b"));
Optional<String> anyElement = stream.findAny();
```

Однако попытка повторно использовать ту же ссылку после вызова терминальной операции приведёт к возникновению `IllegalStateException`:

```java
Optional<String> firstElement = stream.findFirst();
```

Поскольку `IllegalStateException` является `RuntimeException`, компилятор не будет сигнализировать о проблеме. 
Поэтому очень важно помнить, что **Java 8 потоки нельзя использовать повторно**.

Такое поведение логично. 
Мы разработали потоки для применения конечной последовательности операций к источнику элементов в функциональном стиле, а не для хранения элементов.

Чтобы предыдущий код работал правильно, необходимо внести некоторые изменения:

```java
List<String> elements =
  Stream.of("a", "b", "c").filter(element -> element.contains("b"))
    .collect(Collectors.toList());
Optional<String> anyElement = elements.stream().findAny();
Optional<String> firstElement = elements.stream().findFirst();
```

## 4. Потоковый трубопровод

Чтобы выполнить последовательность операций над элементами источника данных и объединить их результаты, нам понадобятся три части: 
+ источник
+ промежуточные операции
+ терминальная операция.

Промежуточные операции возвращают _новый_ изменённый поток. 
Например, чтобы создать новый поток из существующего без нескольких элементов, нужно использовать метод `skip()`:

```java
Stream<String> onceModifiedStream = Stream.of("abcd", "bbcd", "cbcd").skip(1);
```

Если нам нужно внести несколько изменений, мы можем объединить промежуточные операции в цепочку. 
Предположим, нам также нужно заменить каждый элемент текущего `Stream<String>` подстрокой из первых нескольких символов. 
Это можно сделать, объединив в цепочку методы `skip()` и `map()`:

```java
Stream<String> twiceModifiedStream =
  stream.skip(1).map(element -> element.substring(0, 3));
```

Как мы видим, метод `map()` принимает в качестве параметра _лямбда-выражение_.

Поток сам по себе бесполезен; пользователя интересует результат терминальной операции, который может представлять собой значение какого-либо типа или действие, применяемое к каждому элементу потока.  
**Мы можем использовать только одну терминальную операцию для каждого потока.**

Правильный и наиболее удобный способ использования потоков — это **потоковый конвейер, представляющий собой цепочку из источника потока, промежуточных операций и конечной операции**:

```java
List<String> list = Arrays.asList("abc1", "abc2", "abc3");
long size = list.stream().skip(1)
  .map(element -> element.substring(0, 3)).sorted().count();
```

## 5. Отложенное обращение
 
**Промежуточные операции выполняются лениво.** 
Это означает, что **они будут вызваны только в том случае, если это необходимо для выполнения конечной операции**.

Например, давайте вызовем метод `wasCalled()`, который при каждом вызове увеличивает внутренний счётчик:

```java
private long counter;
 
private void wasCalled() {
    counter++;
}
```

Теперь давайте вызовем метод `wasCalled()` из операции `filter()`:

```java
List<String> list = Arrays.asList(“abc1”, “abc2”, “abc3”);
counter = 0;
Stream<String> stream = list.stream().filter(element -> {
    wasCalled();
    return element.contains("2");
});
```

Поскольку у нас есть источник с тремя элементами, мы можем предположить, что метод `filter()` будет вызван _три_ раза, а значение переменной _counter_ будет равно `3`.  
Однако при выполнении этого кода значение `counter` не меняется и остаётся равным _нулю_, то есть метод `filter() `не был вызван ни разу. 
Причина в отсутствии терминальной операции. 

Давайте немного перепишем этот код, добавив операцию `map()` и терминальную операцию `findFirst()`. 
Мы также добавим возможность отслеживать порядок вызовов методов с помощью логирования.

```java
Optional<String> stream = list.stream().filter(element -> {
    log.info("filter() was called");
    return element.contains("2");
}).map(element -> {
    log.info("map() was called");
    return element.toUpperCase();
}).findFirst();
```

В итоговом журнале видно, что мы _дважды_ вызвали метод `filter()` и _один_ раз — метод `map()`. 
Это связано с тем, что конвейер работает вертикально. 
В нашем примере _первый_ элемент потока не соответствовал предикату фильтра. 
Затем мы вызвали метод `filter()` для _второго_ элемента, который прошёл проверку. 
Не вызывая метод `filter()` для третьего элемента, мы перешли по конвейеру к методу `map()`.

Операция `findFirst()` удовлетворяет условию только по одному элементу. 
Таким образом, в этом конкретном примере отложенный вызов позволил нам избежать одного вызова метода `filter()`.

## 6. Порядок исполнения

С точки зрения производительности **правильный порядок является одним из наиболее важных аспектов объединения операций в потоковый конвейер**:

```java
long size = list.stream().map(element -> {
    wasCalled();
    return element.substring(0, 3);
}).skip(2).count();
```

Выполнение этого кода увеличит значение счётчика на _три_.
Это означает, что мы вызвали метод `map()` потока три раза, но значение _size_ равно единице. 
Таким образом, в результирующем потоке будет только _один_ элемент, и мы без всякой причины выполнили дорогостоящие операции `map()` _два раза из трёх_.

Если мы изменим порядок методов `skip()` и `map()` , то `counter` увеличится только на _единицу_. 
Таким образом, мы вызовем метод `map()` _только один раз_:

```java
long size = list.stream().skip(2).map(element -> {
    wasCalled();
    return element.substring(0, 3);
}).count();
```

Это подводит нас к следующему правилу: **промежуточные операции, которые уменьшают размер потока, должны выполняться до операций, применяемых к каждому элементу**. 
Поэтому такие методы, как `skip()`, `filter()`, и `distinct()` должны находиться в верхней части нашего потокового конвейера.

## 7. Сокращение потока

В _API_ есть множество _терминальных_ операций, которые преобразуют поток в тип или примитив: `count()`, `max()`, `min()`, и `sum()`. 
Однако эти операции работают в соответствии с предопределённой реализацией. 
Так что же **делать, если разработчику нужно настроить механизм сокращения Stream**? Для этого есть два метода: `reduce()` и `collect()`.

### 7.1. Метод reduce()

Существует _три варианта_ этого метода, которые отличаются сигнатурами и возвращаемыми типами. Они могут иметь следующие параметры:
+ **identity**  — начальное значение для аккумулятора или значение по умолчанию, если поток пуст и накапливать нечего
+ **accumulator**  — функция, определяющая логику объединения элементов. 
Поскольку аккумуля́тор создаёт новое значение на каждом этапе сокращения, количество новых значений равно размеру потока, и полезным является только последнее значение. 
Это не очень хорошо сказывается на производительности.
+ **combiner** — функция, объединяющая результаты работы аккумулятора. 
+ 
Мы вызываем **combiner** только в параллельном режиме, чтобы _объединить_ результаты работы аккумуляторов из разных потоков.

Теперь давайте рассмотрим эти _три метода_ в действии:

```java
OptionalInt reduced = IntStream.range(1, 4).reduce((a, b) -> a + b);
```

_reduced_ = 6 (1 + 2 + 3)

```java
int reducedTwoParams = IntStream.range(1, 4).reduce(10, (a, b) -> a + b);
```

_reducedTwoParams_ = 16 (10 + 1 + 2 + 3)

```java
int reducedParams = Stream.of(1, 2, 3)
  .reduce(10, (a, b) -> a + b, (a, b) -> {
     log.info("combiner was called");
     return a + b;
  });
```

Результат будет таким же, как в предыдущем примере (16), и вход в систему не потребуется, то есть combiner не будет вызван. 
Чтобы **combiner** работал, поток должен быть параллельным:

```java
int reducedParallel = Arrays.asList(1, 2, 3).parallelStream()
    .reduce(10, (a, b) -> a + b, (a, b) -> {
       log.info("combiner was called");
       return a + b;
    });
```

Результат здесь другой (_36_), и объединитель вызывался дважды. 
Здесь сокращение работает по следующему алгоритму: аккумулятор запускался три раза, добавляя каждый элемент потока к _идентичности_. 
Эти действия выполняются параллельно. 
В результате получается (_10 + 1 = 11; 10 + 2 = 12; 10 + 3 = 13_;). 
Теперь объединитель может объединить эти три результата. Для этого нужно выполнить две итерации (_12 + 13 = 25; 25 + 11 = 36_).

### 7.2. Функция collect()

Сокращение потока также может быть выполнено с помощью другой терминальной операции — метода `collect()`. 
Он принимает аргумент типа _Collector_, который определяет механизм сокращения. 
Для наиболее распространённых операций уже созданы предопределённые коллекторы. 
Доступ к ним можно получить с помощью типа _Collectors_.

В этом разделе мы будем использовать следующий _список_ в качестве источника для всех потоков:

```java
List<Product> productList = Arrays.asList(new Product(23, "potatoes"),
  new Product(14, "orange"), new Product(13, "lemon"),
  new Product(23, "bread"), new Product(13, "sugar"));
```

**Преобразование потока в _коллекцию_ (коллекцию, список или множество)**:

```java
List<String> collectorCollection = productList.stream().map(Product::getName).collect(Collectors.toList());
```

**Преобразование в _String_**:

```java
String listToString = productList.stream().map(Product::getName)
  .collect(Collectors.joining(", ", "[", "]"));
```

Метод `joining()` может иметь от одного до трёх параметров (разделитель, префикс, суффикс). 
Самое удобное в использовании `joining()` — это то, что разработчику не нужно проверять, достиг ли поток конца, чтобы применить суффикс, а не разделитель. 
_Collector_ позаботится об этом.

**Вычисление среднего значения всех числовых элементов потока**:

```java
double averagePrice = productList.stream()
  .collect(Collectors.averagingInt(Product::getPrice));
```

**Обработка суммы всех числовых элементов потока**:

```java
int summingPrice = productList.stream()
  .collect(Collectors.summingInt(Product::getPrice));
```

Методы `averagingXX()`, `summingXX()` и `summarizingXX()` могут работать с примитивами (`int`, `long`, `double`) и их классами-оболочками (`Integer`, `Long`, `Double`). 
Ещё одна мощная функция этих методов — _отображение_. 
Благодаря этому разработчику не нужно использовать дополнительную операцию `map()` перед методом `collect()`.

**Сбор статистической информации об элементах потока**:

```java
IntSummaryStatistics statistics = productList.stream()
  .collect(Collectors.summarizingInt(Product::getPrice));
```

Используя полученный экземпляр типа _IntSummaryStatistics_, разработчик может создать статистический отчёт, применив метод `toString()`. 
Результатом будет `String`, общая для всех “_IntSummaryStatistics{count=5, sum=86, min=13, average=17,200000, max=23}_.”

Также легко извлечь из этого объекта отдельные значения _количества_, _суммы_, _минимума_, _среднего значения_ и _максимума_, применив методы `getCount()`, `getSum()`, `getMin()`, `getAverage()`, и `getMax()`. 
Все эти значения можно извлечь из одного конвейера.

**Группировка элементов потока в соответствии с заданной функцией:**

```java
Map<Integer, List<Product>> collectorMapOfLists = productList.stream()
  .collect(Collectors.groupingBy(Product::getPrice));
```

В приведённом выше примере поток был сведён к _Map_, который группирует все товары по цене.

**Разделение элементов потока на группы в соответствии с некоторым предикатом:**

```java
Map<Boolean, List<Product>> mapPartioned = productList.stream()
  .collect(Collectors.partitioningBy(element -> element.getPrice() > 15));
```

**Заставляем коллектора выполнить дополнительную трансформацию:**

```java
Set<Product> unmodifiableSet = productList.stream()
  .collect(Collectors.collectingAndThen(Collectors.toSet(),
  Collections::unmodifiableSet));
```

В данном конкретном случае сборщик данных преобразовал поток в **Set**, а затем создал на его основе неизменяемый **Set**.

**Пользовательский коллектор**:

Если по какой-то причине необходимо создать **пользовательский коллектор**, проще всего и быстрее всего сделать это с помощью метода _of()_ типа _Collector_. 

```java
Collector<Product, ?, LinkedList<Product>> toLinkedList =
  Collector.of(LinkedList::new, LinkedList::add, 
    (first, second) -> { 
       first.addAll(second); 
       return first; 
    });

LinkedList<Product> linkedListOfPersons =
  productList.stream().collect(toLinkedList);
```

В этом примере экземпляр _Коллектора_ был преобразован в LinkedList<Person>.

## 8. Параллельные потоки

До _Java 8_ распараллеливание было сложной задачей. 
Появление _ExecutorService_ и _ForkJoin_ немного упростило жизнь разработчикам, но всё равно приходилось помнить, как создать конкретный исполнитель, как его запустить и так далее. 
В _Java 8_ появился способ реализации параллелизма _в функциональном стиле_.

_API_ позволяет создавать _параллельные_ потоки, которые выполняют операции в _параллельном_ режиме. 
Если источником потока является _коллекция_ или _массив_, это можно сделать с помощью метода `parallelStream()`:

```java
Stream<Product> streamOfCollection = productList.parallelStream();
boolean isParallel = streamOfCollection.isParallel();
boolean bigPrice = streamOfCollection
  .map(product -> product.getPrice() * 12)
  .anyMatch(price -> price > 200);
```

Если источником потока является не коллекция или массив, следует использовать метод `parallel()` .

```java
IntStream intStreamParallel = IntStream.range(1, 150).parallel();
boolean isParallel = intStreamParallel.isParallel();
```

Под капотом Stream API автоматически использует фреймворк `ForkJoin` для _параллельного_ выполнения операций. 
По умолчанию используется общий пул потоков, и нет возможности (по крайней мере, на данный момент) назначить для него какой-либо пользовательский пул потоков. 
_Эту проблему можно решить с помощью пользовательского набора параллельных сборщиков._

При использовании потоков в параллельном режиме избегайте блокирующих операций. 
Также лучше использовать параллельный режим, когда для выполнения задач требуется примерно одинаковое количество времени. 
Если одна задача выполняется намного дольше другой, это может замедлить работу всего приложения.

Поток в параллельном режиме можно преобразовать обратно в последовательный режим с помощью метода `sequential()`:

```java
IntStream intStreamSequential = intStreamParallel.sequential();
boolean isParallel = intStreamSequential.isParallel();
```

## 9. Улучшения Stream API в Java 9

В _Java 9_ появилось несколько заметных улучшений в _Stream API_, которые делают работу с потоками ещё более выразительной и эффективной. 
В этом разделе мы рассмотрим методы `takeWhile()`, `dropWhile()`, `iterate()` и `ofNullable()` и узнаем, как они упрощают выполнение различных операций по сравнению с _Java 8_.

### 9.1. takeWhile() и dropWhile()

Новые методы `takeWhile()` и `dropWhile()` используют _предикат_ для указания условия _включения_ или _исключения_ элементов из потока. 
Эти методы особенно полезны для упорядоченных потоков, поскольку позволяют обрабатывать элементы на основе условия, применяемого последовательно.

**С помощью `takeWhile()` мы можем собирать элементы с начала потока до тех пор, пока не перестанет выполняться заданное условие.** 
Как только элемент перестаёт соответствовать этому условию, `takeWhile()` прекращает сбор дальнейших элементов.

```java
Stream<String> stream = Stream.iterate("", s -> s + "s")
  .takeWhile(s -> s.length() < 10);
```

Здесь `takeWhile()` применяет предикат “`s -> s.length() < 10`“, что означает, что он будет добавлять элементы в поток до тех пор, пока длина строки не превысит `10`. 
Сбор элементов _прекращается_, как только элемент перестаёт соответствовать условию.

**В отличие от этого, dropWhile() отбрасывает элементы в начале потока до тех пор, пока они удовлетворяют заданному предикату**. 
Отбрасывание элементов _прекращается_ в тот момент, когда элемент перестаёт удовлетворять условию, после чего в поток включаются оставшиеся элементы:

```java
Stream<String> stream = Stream.of("a", "aa", "aaa", "aaaaa")
  .dropWhile(s -> s.length() < 5);
```

В этом случае `dropWhile()` будет пропускать элементы до тех пор, пока не встретит строку длиной 5 или более символов, после чего перестанет пропускать элементы.

### 9.2. Расширенный итератор()

**В Java 9 добавлен вариант метода iterate(), который позволяет указать условие, при котором поток перестанет генерировать элементы, что фактически создаёт конечный поток.** 
Эта расширенная функция `iterate()` при необходимости может указать условие остановки:

```java
Stream.iterate(0, i -> i < 10, i -> i + 1)
  .forEach(System.out::println);
```

В этом примере _генерируются_ числа от 0 до 9, а условие остановки напрямую интегрировано в сам метод `iterate()`, что делает его проще и понятнее, чем бесконечные потоки в _Java 8_.

### 9.3. ofNullable() для необязательных элементов

Часто нам может понадобиться создать _поток с одним элементом_, который может быть `null`. 
Метод `ofNullable()` в `Java 9` решает эту проблему, возвращая пустой поток, если предоставленный элемент равен `null`, что позволяет избежать сложной условной логики:

```java
collection.stream()
  .flatMap(s -> Stream.ofNullable(map.get(s)))
  .collect(Collectors.toList());
```

Этот метод `ofNullable()` устраняет необходимость в тернарных выражениях или проверках на `null`, упрощая код, в котором требуется условное добавление элемента.

## 10. Заключение

_Stream API_ — это мощный, но простой для понимания набор инструментов для обработки последовательности элементов. 
При правильном использовании он позволяет сократить объём шаблонного кода, сделать программы более читабельными и повысить производительность приложения.

В большинстве примеров кода, представленных в этой статье, мы не использовали потоки (не применяли метод `close()` или терминальную операцию). 
В реальном приложении **не оставляйте созданный поток без использования**, **так как это приведёт к утечке памяти**.
