# Концепции объектно-ориентированного программирования в Java

# 1. Общий обзор

В этой статье мы рассмотрим концепции объектно-ориентированного программирования (ООП) в Java. 
Мы обсудим классы, объекты, абстракцию, инкапсуляцию, наследование и полиморфизм.

# 2. Классы

**Классы** — это отправная точка для всех объектов, и мы можем рассматривать их как шаблон для создания объектов. 
Класс обычно содержит поля-члены, методы-члены и специальный метод-конструктор.

Мы будем использовать конструктор для создания объектов класса:

```java
public class Car {

    // member fields
    private String type;
    private String model;
    private String color;
    private int speed;

    // constructor
    public Car(String type, String model, String color) {
        this.type = type;
        this.model = model;
        this.color = color;
    }

    // member methods
    public int increaseSpeed(int increment) {
        this.speed = this.speed + increment;
        return this.speed;
    }

    // ...
}
```

Обратите внимание, что у класса может быть несколько конструкторов.

## 3. Объекты

Объекты создаются на основе классов и называются экземплярами класса. Мы создаём объекты на основе классов с помощью их конструкторов:

```java
Car veyron = new Car("Bugatti", "Veyron", "crimson");
Car corvette = new Car("Chevrolet", "Corvette", "black");
```

## 4. Абстракция

**Абстракция** — это сокрытие сложностей реализации и предоставление более простых интерфейсов.

Если говорить об обычном компьютере, то мы видим только его внешний интерфейс, который необходим для взаимодействия с ним, в то время как внутренние микросхемы и схемы скрыты от пользователя.

В объектно-ориентированном программировании абстракция означает сокрытие сложных деталей реализации программы и предоставление только API, необходимого для использования реализации. 
В Java мы достигаем абстракции с помощью интерфейсов и абстрактных классов.

## 5. Инкапсуляция

**Инкапсуляция** — это сокрытие состояния или внутреннего представления объекта от потребителя API и предоставление общедоступных методов, привязанных к объекту, для доступа на чтение и запись. 
Это позволяет скрывать определённую информацию и контролировать доступ к внутренней реализации.

Например, поля-члены класса скрыты от других классов, и доступ к ним можно получить только с помощью методов-членов. 
Один из способов сделать это — сделать все поля данных приватными и доступными только с помощью _публичных_ методов-членов:

```java
public class Car {

    // ...
    private int speed;

    public int getSpeed() {
        return color;
    }

    public void setSpeed(int speed) {
        this.speed = speed;
    }
    // ...
```
Здесь поле _speed_ инкапсулировано с помощью модификатора доступа _private_ и доступно только через методы _public getSpeed()_ и _setSpeed()_. 

## 6. Наследование

**Наследование — это механизм, который позволяет одному классу приобретать все свойства другого класса путём наследования.**  
Наследуемый класс мы называем дочерним, а наследующий — суперклассом или родительским классом.

В Java мы делаем это путём расширения родительского класса. Таким образом, дочерний класс получает все свойства родительского класса.

```java
public class Car extends Vehicle { 
    //...
}
```

Когда мы расширяем класс, мы формируем отношение _IS-A_. 
**Автомобиль IS-A Транспортное средство.** 
Таким образом, он обладает всеми характеристиками _Транспортного средства_. 

Мы можем задаться вопросом: **зачем нам нужно наследование**? 
Чтобы ответить на этот вопрос, давайте рассмотрим производителя транспортных средств, который выпускает различные типы транспортных средств, такие как легковые автомобили, автобусы, трамваи и грузовики.

Чтобы упростить работу, мы можем объединить общие функции и свойства всех типов транспортных средств в модуль (класс в случае с Java). 
А отдельные типы могут наследовать эти свойства и использовать их повторно.

```java
public class Vehicle {
    private int wheels;
    private String model;
    public void start() {
        // the process of starting the vehicle
    }
    
    public void stop() {
        // process to stop the vehicle
    }
    
    public void honk() { 
        // produces a default honk 
    }
    
}
```

Тип транспортного средства _Автомобиль_ теперь наследуется от родительского класса _Транспортное средство_:

```java
public class Car extends Vehicle {
    private int numberOfGears;

    public void openDoors() {
        // process to open the doors
    }
}
```

Java поддерживает одиночное и многоуровневое наследование. Это означает, что класс не может напрямую наследоваться от нескольких классов, но может использовать иерархию:

```java
public class ArmoredCar extends Car {
    private boolean bulletProofWindows;
    
    public void remoteStartCar() {
        // this vehicle can be started by using a remote control
    }
}
```

Здесь _ArmouredCar_ расширяет _Car_, а _Car_ расширяет _Vehicle_. Таким образом, _ArmouredCar_ наследует свойства как от _Car_, так и от _Vehicle_.

Хотя мы наследуем от родительского класса, разработчик может также переопределить реализацию метода родительского класса. 
**Это называется переопределением метода.** 

В приведённом выше примере с классом _Vehicle_ есть метод _honk()_. 
Класс _Car_, расширяющий класс _Vehicle_, может переопределить этот метод и реализовать его так, как ему нужно для подачи звукового сигнала:

```java
public class Car extends Vehicle {  
    //...

    @Override
    public void honk() { 
        // produces car-specific honk 
    }
 }
```

Обратите внимание, что это также называется полиморфизмом во время выполнения, как объясняется в следующем разделе. 

## 7. Полиморфизм
 
**Полиморфизм** — это способность объектно-ориентированного языка обрабатывать данные по-разному в зависимости от типа входных данных. 
В Java одно и то же имя метода может иметь разные сигнатуры и выполнять разные функции.

```java
public class TextFile extends GenericFile {
    //...
 
    public String read() {
        return this.getContent()
          .toString();
    }
 
    public String read(int limit) {
        return this.getContent()
          .toString()
          .substring(0, limit);
    }
 
    public String read(int start, int stop) {
        return this.getContent()
          .toString()
          .substring(start, stop);
    }
}
```

В этом примере мы видим, что метод read() имеет три разные формы с разными функциями. 
Этот тип полиморфизма является статическим или полиморфизмом времени компиляции и также называется перегрузкой метода.

Существует также полиморфизм во время выполнения или динамический полиморфизм, при котором дочерний класс переопределяет метод родительского класса:

```java
public class GenericFile {
    private String name;
 
    //...
 
    public String getFileInfo() {
        return "Generic File Impl";
    }
}
```

Дочерний класс может расширять класс `GenericFile` и переопределять метод `getFileInfo()` :

```java
public class ImageFile extends GenericFile {
    private int height;
    private int width;
 
    //... getters and setters
     
    public String getFileInfo() {
        return "Image File Impl";
    }
}
```

## 8. Заключение

В этой статье мы рассмотрели основные принципы ООП на примере Java.