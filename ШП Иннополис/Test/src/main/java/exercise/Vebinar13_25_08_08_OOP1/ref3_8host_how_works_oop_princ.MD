# Как работают принципы ООП в Java: примеры

Принципы и понятия объектно-ориентированного программирования (ООП, или OOPS, Object-Oriented Programming Concepts)
очень важны.
Не разбираясь в понятиях ООП, вы не сможете проектировать системы в модели объектно-ориентированного программирования.

## Модель объектно-ориентированного программирования

Модель объектно-ориентированного программирования построена вокруг понятия объекта.
**Объект** – это экземпляр класса.
Он содержит свойства и функции.
По сути они похожи на объекты реального мира: как, например, машина, дом, ноутбук и т. д.
У них есть свои свойства и определенные методы для выполнения действий.
Что такое класс?
Класс определяет схему объектов.
Он определяет свойства и функции объектов.
К примеру, книга — это класс, а конкретно ваша книга — его экземпляр.

## Принципы ООП

Основными принципами ООП являются:

1. Абстракция
2. Инкапсуляция
3. Полиморфизм
4. Наследование
5. Ассоциация и агрегация
6. Композиция

Теперь по порядку рассмотрим эти понятия объектно-ориентированного программирования.
Чтобы вы лучше поняли, как реализовать концепции ООП, мы будем использовать фрагменты кода на языке программирования
Java.

## Абстракция

Абстракция — это скрытие внутренних деталей и описание вещей простыми терминами.
Возьмем, к примеру, метод, который складывает два целых числа.
Внутренняя обработка метода скрыта от внешнего мира.
Достичь абстракци в ООП можно несколькими способами, например, через инкапсуляцию и наследование.
Отличным примером абстракции является программа на Java: язык программирования сам заботится о преобразовании простых
операторов в машинный язык и скрывает детали внутренней реализации от внешнего мира.

## Инкапсуляция

Инкапсуляция — это метод, используемый для реализации абстракции в ООП.
Она ограничивает доступ к членам и методам класса.
Для инкапсуляции в ООП применяются ключи модификаторов доступа.
Например, в языке java инкапсуляция достигается с помощью ключевых слов `private`, `protected` и `public`.

## Полиморфизм

Полиморфизм указывает, что в разных ситуациях объект ведет себя по-разному.
Существует два типа полиморфизма – полиморфизм во время компиляции и во время выполнения.
Полиморфизм во время компиляции достигается перегрузкой метода.

Для примера рассмотрим такой класс:

```java
public class Circle {

    public void draw() {
        System.out.println("Drawing circle with default color Black and diameter 1 cm.");
    }

    public void draw(int diameter) {
        System.out.println("Drawing circle with default color Black and diameter" + diameter + " cm.");
    }

    public void draw(int diameter, String color) {
        System.out.println("Drawing circle with color" + color + " and diameter" + diameter + " cm.");
    }
}
```

Все методы `draw`, которые встречаются в этом коде, ведут себя по-разному.
Это пример перегрузки метода, потому что имена методов одинаковы, а аргументы разные.
Поскольку компилятор сможет определить метод вызова во время компиляции, данный метод называется **полиморфизмом** _во
время компиляции_.
Полиморфизм во времени выполнения реализуется, когда между объектами есть отношения наследования _«IS-A»_.
Также этот подход называется _переопределением метода_, поскольку подкласс должен переопределить метод суперкласса.
Фактический класс определяется во время выполнения с точки зрения суперкласса.
Компилятор не может решать, какой метод класса будет вызван.
Это решение принимается во время выполнения, отсюда и название – «полиморфизм во время выполнения» или «динамическая
диспетчеризация методов».

```java
package com.journaldev.test;

public interface Shape {

    public void draw();
}
```

```java
package com.journaldev.test;

public class Circle implements Shape {

    @Override
    public void draw() {
        System.out.println("Drwaing circle");
    }

}
```

```java
package com.journaldev.test;

public class Square implements Shape {

    @Override
    public void draw() {
        System.out.println("Drawing Square");
    }

}
```

Тут `Shape` — это суперкласс, у которого есть два подкласса, `Circle` и `Square`. 
Ниже приведен пример полиморфизма во время выполнения.

```java
Shape sh = new Circle();
sh.draw();

Shape sh1 = getShape(); //some third party logic to determine shape
sh1.draw();
```

В этих примерах компилятор Java не знает фактического класса реализации Shape, который будет использоваться во время
выполнения.

## Наследование

_Наследование_ — это понятие объектно-ориентированного программирования, которое указывает, что один объект основан на другом объекте, вытекает из него. 
Проще говоря, наследование — это механизм повторного использования кода. 
Наследуемый объект называется _суперклассом_, а объект, который наследует суперкласс, называется _подклассом_. 
В java для реализации наследования используется ключевое слово extends. Давайте посмотрим на следующий пример наследования в java.

```java
package com.journaldev.java.examples1;

class SuperClassA {

    public void foo() {
        System.out.println("SuperClassA");
    }
}

class SubClassB extends SuperClassA {
    public void bar() {
        System.out.println("SubClassB");
    }
}

public class Test {
    public static void main(String args[]) {
        SubClassB a = new SubClassB();
        a.foo();
        a.bar();
    }
}
```

## Ассоциация

Такое поняте ООП, как _ассоциация_, определяет связи между объектами, а также разнообразие самих объектов. 
Предположим, что у нас есть объекты “Учитель” и “Ученик”: множество учеников может общаться с одним учителем, и, конечно, один ученик также может общаться с несколькими учителями.

## Агрегация

_Агрегация_ – это особый тип ассоциации. 
Это понятие подразумевает, что все объекты имеют свой собственный жизненный цикл, но со взаимосвязью _«HAS-A»_ – то есть один дочерний объект может принадлежать одному родительскому. 
Каждый раз, когда вы встречаете взаимосвязь _«HAS-A»_ между объектами, знайте – это называется _агрегацией_.

## Композиция

_Композиция_ – специальная “ограничительная” форма агрегации. В композиции содержащийся в отношении «HAS-A» объект не может существовать сам по себе. 
Представим, например, комнату, которая находится в доме. 
Одна комната не может быть частью двух разных домов. Конечно, если вы удалите дом, комната тоже будет удалена. 
