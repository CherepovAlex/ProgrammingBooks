# Приведение типов объектов в Java

## 1. Общий обзор

Система типов Java состоит из двух видов типов: примитивных и ссылочных.

Здесь сосредоточимся на приведении типов, чтобы лучше понять, как Java работает с типами.

## 2. Примитив и эталон

Хотя преобразование примитивных типов и приведение ссылочных переменных могут показаться похожими, это совершенно разные понятия.

В обоих случаях мы «превращаем» один тип в другой. 
Но если говорить упрощённо, то примитивная переменная содержит своё значение, и преобразование примитивной переменной означает необратимое изменение её значения:

```java
double myDouble = 1.1;
int myInt = (int) myDouble;
        
assertNotEquals(myDouble, myInt);
```

После преобразования в приведённом выше примере переменная `myInt` становится равной` 1`, и мы не можем восстановить из неё предыдущее значение `1,1`.

**Переменные-ссылки отличаются от других переменных**; переменная-ссылка указывает только на объект, но не содержит его.

Приведение ссылочной переменной не затрагивает объект, на который она ссылается, а лишь по-другому маркирует этот объект, расширяя или сужая возможности для работы с ним. 
**Приведение вверх сужает список методов и свойств, доступных для этого объекта, а приведение вниз может его расширить.**

Ссылка — это как пульт дистанционного управления для объекта. 
На пульте дистанционного управления может быть больше или меньше кнопок в зависимости от его типа, а сам объект хранится в куче. 
При приведении типа мы меняем тип пульта дистанционного управления, но не меняем сам объект.

## 3. Повышающий коэффициент

**Приведение типа из подкласса в суперкласс называется повышением типа.** Как правило, повышение типа выполняется компилятором неявно.

Приведение типа тесно связано с наследованием — ещё одной ключевой концепцией в Java. 
Обычно для обращения к более конкретному типу используются ссылочные переменные. И каждый раз, когда мы это делаем, происходит неявное приведение типа.

Чтобы продемонстрировать повышение типа, давайте определим класс `Animal`:

```java
public class Animal {

    public void eat() {
        // ... 
    }
}
```

Теперь давайте расширим `Animal`:

```java
public class Cat extends Animal {

    public void eat() {
         // ... 
    }

    public void meow() {
         // ... 
    }
}
```

Теперь мы можем создать объект класса `Cat` и присвоить его ссылочной переменной типа `Cat`:

`Cat cat = new Cat();`

Мы также можем присвоить его ссылочной переменной типа Animal:

`Animal animal = cat;`

В приведённом выше примере происходит неявное приведение типа.

Мы могли бы сделать это явно:

`animal = (Animal) cat;`

Но нет необходимости явно приводить к типу по дереву наследования. 
Компилятор знает, что _кот — это животное_, и не выдаёт никаких ошибок.

Обратите внимание, что ссылка может вести на любой подтип объявленного типа.

С помощью апкастинга мы ограничили количество методов, доступных для экземпляра `Cat`, но не изменили сам экземпляр. 
Теперь мы не можем делать ничего специфичного для `Cat` — мы не можем вызвать `meow()` для переменной `animal`.

Хотя объект `Кот` остаётся объектом `Кот`, вызов _мяу()_ приведёт к ошибке компилятора:

```java
// animal.meow(); The method meow() is undefined for the type Animal
```

Чтобы вызвать `meow()`, нам нужно привести `animal` к другому типу, и мы сделаем это позже.

Но теперь мы расскажем, что даёт нам апкастинг. Благодаря апкастингу мы можем использовать преимущества полиморфизма.

## 3.1. Полиморфизм

Давайте определим ещё один подкласс `Animal` — класс `Dog`:

```java
public class Dog extends Animal {

    public void eat() {
         // ... 
    }
}
```

Теперь мы можем определить метод `feed()`, который относится ко всем кошкам и собакам как к животным:

```java
public class AnimalFeeder {

    public void feed(List<Animal> animals) {
        animals.forEach(animal -> {
            animal.eat();
        });
    }
}
```

Мы не хотим, чтобы `AnimalFeeder` заботился о том, какое животное находится в списке — _кошка_ или _собака_. 
В методе _feed()_ все они `животные`.

Неявное приведение типа происходит, когда мы добавляем объекты определённого типа в список `animals`:

```java
List<Animal> animals = new ArrayList<>();
animals.add(new Cat());
animals.add(new Dog());
new AnimalFeeder().feed(animals);
```

Мы добавляем кошек и собак, и они неявно приводятся к типу `Animal`. 
Каждая Кошка — это Животное, а каждая Собака — это Животное. 
Они полиморфны.

Кстати, все объекты `Java` являются полиморфными, потому что каждый объект как минимум является `Object`. 
Мы можем присвоить экземпляр `Animal` ссылочной переменной типа `Object`, и компилятор не выдаст ошибку:

```java
Object object = new Animal();
```

Вот почему все создаваемые нами объекты Java уже имеют _объектно-ориентированные методы_, например `toString()`.

Также часто используется приведение к интерфейсу.

Мы можем создать интерфейс `Mew` и заставить `Cat` его реализовать:

```java
public interface Mew {
    public void meow();
}

public class Cat extends Animal implements Mew {
    
    public void eat() {
         // ... 
    }

    public void meow() {
         // ... 
    }
}
```

Теперь любой объект `Cat` можно преобразовать в `Mew`:

```java
Mew mew = new Cat();
```

_Кот_ — это _Мяу_; приведение типа разрешено и выполняется неявно.

Таким образом, _Кот — это Мяу, Животное, Объект и Кот._ В нашем примере его можно присвоить ссылочным переменным всех четырёх типов.

## 3.2. Переопределение

В приведённом выше примере метод `eat()` переопределён. 
Это означает, что, хотя метод `eat()` вызывается для переменной типа `Animal`, работа выполняется методами, вызываемыми для реальных объектов — кошек и собак.

```java
public void feed(List<Animal> animals) {
    animals.forEach(animal -> {
        animal.eat();
    });
}
```

Если мы добавим в наши классы логирование, то увидим, что вызываются методы `Cat` и `Dog`:

```java
web - 2018-02-15 22:48:49,354 [main] INFO com.baeldung.casting.Cat - cat is eating
web - 2018-02-15 22:48:49,363 [main] INFO com.baeldung.casting.Dog - dog is eating
```

**Подводя итог:**

+ Ссылочная переменная может ссылаться на объект, если объект того же типа, что и переменная, или является его подтипом.
+ Апкастинг происходит неявно.
+ Все объекты Java являются полиморфными и могут рассматриваться как объекты супертипа благодаря приведению типов.

## 4. Понижающее вещание

Что, если мы хотим использовать переменную типа `Animal` для вызова метода, доступного только в классе `Cat`? 
Здесь используется приведение типа. 
**Это приведение типа из суперкласса в подкласс.**

Давайте рассмотрим пример:

```java
Animal animal = new Cat();
```

Мы знаем, что переменная `animal` ссылается на экземпляр `Cat`. 
И мы хотим вызвать метод `мяу()` `Cat` для животного. Но компилятор жалуется, что метод `meow()` не существует для типа Animal.

Чтобы вызвать `мяу()`, мы должны привести _животное_ к типу _Кошка_:

```java
((Cat) animal).meow();
```

Внутренние скобки и тип, который они содержат, иногда называют **оператором приведения типа**. 
Обратите внимание, что внешние скобки также необходимы для компиляции кода.

Давайте перепишем предыдущий пример `AnimalFeeder` с использованием метода` meow()`:

```java
public class AnimalFeeder {

    public void feed(List<Animal> animals) {
        animals.forEach(animal -> {
            animal.eat();
            if (animal instanceof Cat) {
                ((Cat) animal).meow();
            }
        });
    }
}
```

Теперь у нас есть доступ ко всем методам, доступным в классе `Cat`. 
Посмотрите в журнал, чтобы убедиться, что `meow()` действительно вызывается:

```java
web - 2018-02-16 18:13:45,445 [main] INFO com.baeldung.casting.Cat - cat is eating
web - 2018-02-16 18:13:45,454 [main] INFO com.baeldung.casting.Cat - meow
web - 2018-02-16 18:13:45,455 [main] INFO com.baeldung.casting.Dog - dog is eating
```


Обратите внимание, что в приведённом выше примере мы пытаемся выполнить приведение только для тех объектов, которые действительно являются экземплярами `Cat`. 
Для этого мы используем оператор `instanceof`.

### 4.1. instanceof Оператор

Мы часто используем оператор `instanceof` перед приведением типа, чтобы проверить, принадлежит ли объект к определённому типу:

```java
if (animal instanceof Cat) {
    ((Cat) animal).meow();
}
```

### 4.2. ClassCastException

Если бы мы не проверили тип с помощью оператора `instanceof`, компилятор не выдал бы ошибку. 
Но во время выполнения программы возникло бы исключение.

Чтобы продемонстрировать это, давайте _уберём_ оператор `instanceof` из приведённого выше кода:

```java
public void uncheckedFeed(List<Animal> animals) {
    animals.forEach(animal -> {
        animal.eat();
        ((Cat) animal).meow();
    });
}
```

Этот код компилируется без проблем. Но если мы попытаемся его запустить, то увидим исключение:

    java.lang.ClassCastException: com.baeldung.casting.Dog нельзя преобразовать в com.baeldung.casting.Cat

Это означает, что мы пытаемся преобразовать объект, являющийся экземпляром `Dog`, в экземпляр `Cat`.

`ClassCastException` всегда возникает во время выполнения, если тип, к которому мы приводим, не соответствует типу реального объекта.

Обратите внимание, что если мы попытаемся выполнить приведение к несвязанному типу, компилятор не допустит этого:

```java
Animal animal;
String s = (String) animal;
```

Компилятор выдаёт ошибку `«Невозможно преобразовать Animal в String»`.

Чтобы код скомпилировался, оба типа должны находиться _в одном дереве наследования_.

Подведём итог:

+ Даункастинг необходим для получения доступа к элементам, специфичным для подкласса.
+ Даункастинг выполняется с помощью оператора приведения типа.
+ Чтобы безопасно выполнить приведение типа объекта, нам нужен оператор `instanceof`.
+ Если реальный объект не соответствует типу, к которому мы приводим его, то во время выполнения будет выдано исключение `ClassCastException`.

## 5. cast() Метод

Есть ещё один способ приведения объектов с помощью методов `Class`:

```java
public void whenDowncastToCatWithCastMethod_thenMeowIsCalled() {
    Animal animal = new Cat();
    if (Cat.class.isInstance(animal)) {
        Cat cat = Cat.class.cast(animal);
        cat.meow();
    }
}
```

В приведенном выше примере вместо операторов `cast` и `instanceof` используются методы `cast() `и `isInstance()` соответственно.

При работе с обобщёнными типами часто используются методы` cast()` и `isInstance()`.

Давайте создадим класс `AnimalFeederGeneric<T>` с методом `feed()`, который «кормит» только один вид животных — кошек или собак — в зависимости от значения параметра `type`:

```java
public class AnimalFeederGeneric<T> {
    private Class<T> type;

    public AnimalFeederGeneric(Class<T> type) {
        this.type = type;
    }

    public List<T> feed(List<Animal> animals) {
        List<T> list = new ArrayList<T>();
        animals.forEach(animal -> {
            if (type.isInstance(animal)) {
                T objAsType = type.cast(animal);
                list.add(objAsType);
            }
        });
        return list;
    }

}
```

Метод `feed()` проверяет каждое животное и возвращает только тех, которые являются экземплярами T.

Обратите внимание, что экземпляр `Class` также должен быть передан универсальному классу, поскольку мы не можем получить его из параметра типа T. 
В нашем примере мы передаём его в конструкторе.

Давайте сделаем так, чтобы `T` было равно `Cat`, и убедимся, что метод возвращает только кошек:

```java
@Test
public void whenParameterCat_thenOnlyCatsFed() {
    List<Animal> animals = new ArrayList<>();
    animals.add(new Cat());
    animals.add(new Dog());
    AnimalFeederGeneric<Cat> catFeeder
      = new AnimalFeederGeneric<Cat>(Cat.class);
    List<Cat> fedAnimals = catFeeder.feed(animals);

    assertTrue(fedAnimals.size() == 1);
    assertTrue(fedAnimals.get(0) instanceof Cat);
}
```

## 6. Заключение

В этом базовом руководстве мы рассмотрели приведение типов, понижение типа, способы их использования и то, как эти концепции могут помочь вам воспользоваться преимуществами полиморфизма.
























