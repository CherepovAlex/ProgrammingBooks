# Пришел, увидел, обобщил: погружаемся в Java Generics

**Java Generics** — это одно из самых значительных изменений за всю историю языка Java. «Дженерики», доступные с Java 5,
сделали использование Java Collection Framework проще, удобнее и безопаснее. Ошибки, связанные с некорректным 
использованием типов, теперь обнаруживаются на этапе компиляции. Да и сам язык Java стал еще безопаснее. Несмотря на 
кажущуюся простоту обобщенных типов, многие разработчики сталкиваются с трудностями при их использовании. В этом посте 
я расскажу об особенностях работы с Java Generics, чтобы этих трудностей у вас было поменьше. Пригодится, если вы не 
гуру в дженериках, и поможет избежать много трудностей при погружении в тему.

## Работа с коллекциями

Предположим, банку нужно подсчитать сумму сбережений на счетах клиентов. До появления «дженериков» метод вычисления 
суммы выглядел так:

```java
public long getSum(List accounts) {
   long sum = 0;

   for (int i = 0, n = accounts.size(); i < n; i++) {
       Object account = accounts.get(i);
       if (account instanceof Account) {
           sum += ((Account) account).getAmount();
       }
   }

   return sum;
}
```

Мы итерировались, пробегались по списку аккаунтов и проверяли, действительно ли элемент из этого списка является 
экземпляром класса `Account` — то есть счетом пользователя. Выполняли приведение типа нашего объекта класса `Account` и 
метод `getAmount`, который возвращал сумму на этом счете. Дальше все это суммировали и возвращали итоговую сумму. 
Требовалось выполнить два действия:

```java
if (account instanceof Account) { // (1)
    
    sum += ((Account) account).getAmount(); // (2)
```

Если не сделать проверку (`instanceof`) на принадлежность к классу `Account`, то на втором этапе возможен 
`ClassCastException` – то есть аварийное завершение программы. Поэтому такая проверка была обязательной.

С появлением _Generics_ необходимость в проверке и приведении типа отпала:

```java
public long getSum2(List<Account> accounts) {
   long sum = 0;

   for (Account account : accounts) {
       sum += account.getAmount();
   }

   return sum;
}
```

Теперь метод

    getSum2(List<Account> accounts)

принимает в качестве аргументов только список объектов класса Account. Это ограничение указано в самом методе, в его 
сигнатуре, программист просто не может передать никакой другой список — только список клиентских счетов.

Нам не нужно выполнять проверку типа элементов из этого списка: она подразумевается описанием типа у параметра метода

    List<Account> accounts

(можно прочитать как список объектов класса `Account`). И компилятор выдаст ошибку, если что-то пойдет не так — то есть 
если кто-то попробует передать в этот метод список объектов, отличных от класса `Account`.

Во второй строчке проверки необходимость тоже отпадала. Если потребуется, приведение типов (_casting_) будет сделано 
на этапе компиляции.

## Принцип подстановки

Принцип подстановки Барбары Лисков – специфичное определение подтипа в объектно-ориентированном программировании. 
Идея Лисков о «подтипе» дает определение понятия замещения: если _S_ является подтипом _T_, тогда объекты типа _T_ в 
программе могут быть замещены объектами типа _S_ без каких-либо изменений желательных свойств этой программы.


| **Тип**                          | **Подтип**                      |
|:---------------------------------|:--------------------------------|
| Number                           | Integer                         |
| List<E>                          | ArrayList<E>                    |
| Collection<E>                    | List<E>                         |
| Iterable<E>                      | Collection<E>                   |

_Примеры отношения тип/подтип_

Вот пример использования принципа подстановки в Java:

```java
Number n = Integer.valueOf(42);
List<Number> aList = new ArrayList<>();
Collection<Number> aCollection = aList;
Iterable<Number> iterable = aCollection;
```

`Integer` является подтипом `Number`, следовательно, переменной `n` типа `Number` можно присвоить значение, которое 
возвращает метод `Integer.valueOf(42)`.

## Ковариантность, контравариантность и инвариантность

Сначала немного теории. _Ковариантность_ — это сохранение иерархии наследования исходных типов в производных типах в 
том же порядке. Например, если Кошка — это подтип Животные, то Множество<Кошки> — это подтип Множество<Животные>. 
Следовательно, с учетом принципа подстановки можно выполнить такое присваивание:

_Множество<Животные>  = Множество<Кошки>_

_Контравариантность_ — это обращение иерархии исходных типов на противоположную в производных типах. Например, если 
_Кошка_ — это подтип `Животные`, то _Множество<Животные>_ — это подтип _Множество<Кошки>_. Следовательно,  с учетом 
принципа подстановки можно выполнить такое присваивание:

_Множество<Кошки> = Множество<Животные>_

_Инвариантность_ — отсутствие наследования между производными типами. Если _Кошка_ — это подтип _Животные_, то 
_Множество<Кошки>_ не является подтипом Множество<Животные> и Множество<Животные> не является подтипом Множество<Кошки>.

**Массивы в Java ковариантны**. Тип `S[]` является подтипом `T[]`, если `S` — подтип `T`. Пример присваивания:

```java
String[] strings = new String[] {"a", "b", "c"};
Object[] arr = strings;
```

Мы присвоили ссылку на массив строк переменной `arr`, тип которой – `«массив объектов»`. Если бы массивы не были 
ковариантными, нам бы это сделать не удалось. Java позволяет это сделать, программа скомпилируется и выполнится без 
ошибок.

```java
arr[0] = 42; // ArrayStoreException. Проблема обнаружилась на этапе выполнения программы
```

Но если мы попытаемся изменить содержимое массива через переменную `arr` и запишем туда число 42, то получим 
`ArrayStoreException` на этапе выполнения программы, поскольку 42 является не строкой, а числом. В этом недостаток 
ковариантности массивов Java: мы не можем выполнить проверки на этапе компиляции, и что-то может сломаться уже в 
рантайме.

**«Дженерики» инвариантны**. Приведем пример:

```java
List<Integer> ints = Arrays.asList(1,2,3);
List<Number> nums = ints; // compile-time error. Проблема обнаружилась на этапе компиляции
nums.set(2, 3.14);
assert ints.toString().equals("[1, 2, 3.14]");
```

Если взять список целых чисел, то он не будет являться ни подтипом типа `Number`, ни каким-либо другим подтипом. Он 
является только подтипом самого себя. То есть `List <Integer>` — это `List<Integer>` и ничего больше. Компилятор 
позаботится о том, чтобы переменная `ints`, объявленная как список объектов класса `Integer`, содержала только объекты 
класса `Integer` и ничего кроме них. На этапе компиляции производится проверка, и у нас в рантайме уже ничего не упадет.

## Wildcards

Всегда ли Generics инварианты? Нет. Приведу примеры:

```java
List<Integer> ints = new ArrayList<Integer>();
List<? extends Number> nums = ints;
```

Это _ковариантность_. `List<Integer>` — подтип `List<? extends Number>`

```java
List<Number> nums = new ArrayList<Number>();
List<? super Integer> ints = nums;
```

Это контравариантность. `List<Number>` является подтипом `List<? super Integer>`.

Запись вида "`? extends ...`" или "`? super ...`" — называется **wildcard** или символом подстановки, с верхней 
границей (`extends`) или с нижней границей (`super`). 
`List<? extends Number>` может содержать объекты, класс которых является `Number` или _наследуется_ от `Number`. 
`List<? super Number>` может содержать объекты, класс которых `Number` или у которых `Number` является _наследником_ 
(супертип от `Number`).

![img_5.png](img_5.png)

`extends B` — символ подстановки с указанием верхней границы

`super B` — символ подстановки с указанием нижней границы

где `B` — представляет собой границу

Запись вида `T2 <= T1` означает, что набор типов описываемых `T2` является подмножеством набора типов описываемых `T1`.

т.е. `Number <=? extends Object` : `? extends Number <= ? extends Object`

и `? super Object <= ? super Number`

`Более математическая интерпретация темы`

Пара задачек для проверки знаний:

1. Почему в примере ниже _compile-time error_? Какое значение можно добавить в список nums?

```java
List<Integer> ints = new ArrayList<Integer>();
ints.add(1);
ints.add(2);
List<? extends Number> nums = ints;
nums.add(3.14); // compile-time error
```

Ответ: Если контейнер объявлен с wildcard - `? extends`, то можно только _читать_ значения. В список нельзя ничего 
добавить, кроме `null` (компилятор не знает точный тип элементов в списке `nums`). Для того чтобы добавить объект в 
список нам нужен другой тип wildcard — `? super`.

Решение для добавления: Использовать `? super T`, который говорит: "список может содержать `T` или любой его 
`супертип`".

2. Почему нельзя получить элемент из списка ниже?

```java
public static <T> T getFirst(List<? super T> list) {
   return list.get(0); // compile-time error
}
```

Ответ: Нельзя прочитать элемент из контейнера с `wildcard ? super`, кроме объекта класса `Object` (только `Object`, так 
как `Object` является супертипом для всех ссылочных типов).
(компилятор знает, что список содержит `T` или любой супертип `T`, но не знает точно какой)

```java
public static <T> Object getFirst(List<? super T> list) {
   return list.get(0);  // OK
}
```

Решения для получения: если нужно получить именно тип `T`, нужно использовать `bounded wildcard` с кастингом (но это 
небезопасно).

```java
public static <T> T getFirst(List<? super T> list) {
   return (T) list.get(0); // Небезопасно, возможен ClassCastException
}
```

## The Get and Put Principle или PECS (Producer Extends Consumer Super)

Особенность _wildcard_ с верхней и нижней границей дает дополнительные фичи, связанные с безопасным использованием 
типов. Из одного типа переменных можно только читать, в другой — только вписывать (исключением является возможность 
записать `null` для `extends` и прочитать `Object` для `super`). Чтобы было легче запомнить, когда какой `wildcard` 
использовать, существует принцип **PECS — Producer Extends Consumer Super**.

+ Если мы объявили` wildcard с extends`, то это `producer`. Он только «продюсирует», предоставляет элемент из контейнера, 
а сам ничего не принимает.
+ Если же мы объявили `wildcard с super` — то это `consumer`. Он только принимает, а предоставить ничего не может.

Рассмотрим использование `Wildcard` и принципа **PECS** на примере метода copy в классе `java.util.Collections`.

```java
public static <T> void copy(List<? super T> dest, List<? extends T> src) {
…
}
```

Метод осуществляет копирование элементов из исходного списка _src_ в список _dest_. _src_ — объявлен с 
`wildcard ? extends` и является _продюсером_, а _dest_ — объявлен с `wildcard ? super` и является _потребителем_. 
Учитывая ковариантность и контравариантность wildcard, можно скопировать элементы из списка _ints_ в список _nums_:

```java
List<Number> nums = Arrays.<Number>asList(4.1F, 0.2F);
List<Integer> ints = Arrays.asList(1,2);
Collections.copy(nums, ints);
```

Если же мы по ошибке перепутаем параметры метода `copy` и попытаемся выполнить копирование из списка `nums` в список 
`ints`, то компилятор не позволит нам это сделать:

```java
Collections.copy(ints, nums); // Compile-time error
```
Компилятор не может найти тип` T`, который удовлетворял бы обоим условиям:

+ `Integer` должен быть супертипом `T` (из первого параметра)
+ `Number` должен быть подтипом `T` (из второго параметра)

## <?> и Raw типы

Ниже приведен `wildcard` с неограниченным символом подстановки. Мы просто ставим `<?>`, без ключевых слов `super` или 
`extends`:

```java
static void printCollection(Collection<?> c) {
   // a wildcard collection
   for (Object o : c) {
       System.out.println(o);
   }
}
```

На самом деле такой «неограниченный» `wildcard` все-таки ограничен, сверху.
```bash
Collection<?>   — это тоже символ подстановки, как и `? extends Object`. 
```
Запись вида `Collection<?>` равносильна `Collection<? extends Object>` , а значит — коллекция может содержать объекты 
_любого_ класса, так как все классы в Java наследуются от `Object` – поэтому подстановка называется _неограниченной_.

Если мы опустим указание типа, например, как здесь:

```java
    ArrayList arrayList = new ArrayList();
```

то, говорят, что `ArrayList` — это _Raw_ тип параметризованного `ArrayList<T>`. Используя _Raw_ типы, мы возвращаемся 
в эру до дженериков и сознательно отказываемся от всех фич, присущих параметризованным типам.

Если мы попытаемся вызвать параметризованный метода у _Raw_ типа, то компилятор выдаст нам предупреждение 
`«Unchecked call»`. Если мы попытаемся выполнить присваивание ссылки на параметризованный тип `Raw` типу, то компилятор 
выдаст предупреждение `«Unchecked assignment»`. Игнорирование этих предупреждений, как мы увидим позже, может привести 
к ошибкам во время выполнения нашего приложения.

```java
ArrayList<String> strings = new ArrayList<>();
ArrayList arrayList = new ArrayList();
arrayList = strings; // Ok
strings = arrayList; // Unchecked assignment
arrayList.add(1); //unchecked call
```

## Wildcard Capture































