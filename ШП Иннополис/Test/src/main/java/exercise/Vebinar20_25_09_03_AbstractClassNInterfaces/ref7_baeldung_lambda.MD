# Лямбда-выражение против анонимного внутреннего класса

## 1. Общий обзор

Анонимные классы похожи на вложенные классы _без имени_. Лямбда-выражения были введены в Java 8 для поддержки 
функционального программирования. В некоторых случаях они используются вместо анонимных классов. В этой статье мы 
рассмотрим _различия_ между анонимным классом и лямбда-выражением.

## 2. Анонимный внутренний класс

Анонимный класс _реализует_ интерфейсы и абстрактные классы _без создания_ дополнительных подклассов. Кроме того, у 
анонимного класса нет имени, и он **одновременно предоставляет определение класса и создаёт его экземпляр**.

Теперь давайте рассмотрим _пример анонимного класса_, реализующего интерфейс `Runnable`:

```java
public class AnonymousClassExample{

    public static void main(String[] args){
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("Thread: "+Thread.currentThread().getName()+" started");
            }
        });
        t1.start();
    }
}
```

В приведённом выше примере мы создали класс с именем `AnonymousClassExample` и реализовали интерфейс `Runnable` с 
помощью анонимного класса. Мы _не создавали_ отдельный класс, реализующий интерфейс `Runnable`.

## 3. Лямбда-выражение

Лямбда-выражение _реализует_ функциональные интерфейсы, которые представляют собой интерфейсы, имеющие _единственный 
нереализованный метод_. _Лямбда-выражение_ - это, по сути, определение метода без имени. Это делает код более кратким и 
читаемым. **Он также предоставляет _способ передачи функции_ в качестве аргумента метода**. 

Теперь давайте рассмотрим пример лямбда-выражения, реализующего интерфейс `Runnable`:

```java
public class LambdaExpressionExample{

    public static void main(String[] args){
        Thread t1 = new Thread(()->System.out.println("Thread: "+Thread.currentThread().getName()+" started"));
        t1.start();
    }
}
```

Здесь мы используем _анонимный метод_. Он преобразуется в метод `run()` интерфейса `Runnable`.

Даже в случае с функциональными интерфейсами мы можем использовать анонимный класс и лямбда-выражение как 
взаимозаменяемые элементы. Но между ними есть различия. Давайте рассмотрим эти различия.

## 4. Анонимный класс в сравнении с лямбда-выражением 

Как упоминалось ранее, _анонимный класс_ используется для интерфейсов и абстрактных классов, а _лямбда-выражения_ — 
только для функциональных интерфейсов. Давайте рассмотрим некоторые дополнительные различия между ними.

### 4.1. Синтаксис

Анонимный класс содержит _определение_ класса и одновременно создаёт его _экземпляр_. Мы используем ключевое слово `new`
и имя реализуемого класса или интерфейса. Это похоже на вызов конструктора, но мы также предоставляем реализации методов 
и объявляем переменные состояния. **Анонимный класс — это выражение, присвоенное ссылочной переменной класса или 
интерфейса, который он реализует.** Поэтому в конце мы также ставим точку с запятой.

С другой стороны, **лямбда-выражение — это метод без имени**. Мы указываем сигнатуру нереализованного метода в 
функциональном интерфейсе без имени. Нам также не нужно указывать типы данных аргументов метода. Метод определяется 
во время выполнения.

### 4.2. Область применения ключевого слова this и переменных

В анонимном классе ключевое слово `this` относится _к самому анонимному классу_. Но в случае с лямбда-выражением `this` 
относится _к включающему его классу_.

Мы также можем объявлять _переменные-члены_ в анонимном классе, что _невозможно_ в случае с лямбда-выражением. Таким 
образом, анонимный класс может иметь _состояние_. Переменные, объявленные внутри лямбда-выражения, действуют как 
_локальные_ переменные. Однако обе они имеют доступ к переменным-членам окружающего класса.

### 4.3. Компиляция

При компиляции для каждого анонимного класса создаётся отдельный файл класса. Формат файла класса: имя класса, за 
которым следует знак доллара и число. Например, если мы определим анонимный класс в классе с именем `TestClass`, то 
после компиляции будет создан дополнительный файл `TestClass$1.class`.

С другой стороны, в случае с лямбда-выражением в файл класса добавляется инструкция `invokedynamic`. **Эта инструкция 
с кодом операции помогает определить, _какой метод_ функционального интерфейса нужно вызвать**.

**При компиляции лямбда-выражения в байт-код добавляется эквивалентный закрытый статический или нестатический метод**. 
Сигнатура этого метода соответствует методу функционального интерфейса.

Кроме того, захваченные аргументы, если используется лямбда-выражение, также добавляются в начало списка аргументов 
метода. Также добавляется дополнительный _indy_ сайт вызова. В нём содержится вся информация, необходимая для вызова 
приватного метода, сгенерированного для лямбда-выражения. Во время выполнения сайт вызова инициализируется и 
вызывается связанный приватный метод.

### 4.4. Производительность

Теперь давайте посмотрим, как анонимный класс и лямбда-выражение влияют на производительность на высоком уровне. 
Лямбда-выражение с точки зрения производительности лучше анонимного класса. Это связано с тем, что анонимный класс 
при компиляции приводит к созданию дополнительного файла класса, загрузка и проверка которого во время выполнения 
занимают дополнительное время.

Лямбда-выражения работают быстрее, потому что инструкция `invokedynamic` связывает лямбда-выражение с методом 
функционального интерфейса. Только первый вызов лямбда-выражения выполняется медленно. Последующие вызовы 
выполняются быстрее.

## 5. Заключение

В этой статье мы рассмотрели различия между лямбда-выражениями и анонимными внутренними классами. Мы узнали, чем 
они отличаются с точки зрения синтаксиса, процесса компиляции и производительности.
