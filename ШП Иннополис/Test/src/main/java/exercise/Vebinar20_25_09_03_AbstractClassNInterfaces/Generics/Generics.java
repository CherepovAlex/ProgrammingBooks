package exercise.Vebinar20_25_09_03_AbstractClassNInterfaces.Generics;

public class Generics {

    public static void main(String[] args) {
        // - Generic types - обобщённые типы
        //      1. классы (без enum, исключений, анонимных)
        //      2. интерфейсы (без аннотаций)
        // - Методы (generic methods)
        // - Конструкторы (generic constructors)
        // Преимущества
        // - определение ошибок использования типов на этапе компиляции
        // - использование параметризированных: <T>
        //      - типов
        //      - методов
        //      - конструкторов
        // - использование wildcards <?>
        //      - с ограничениями
        //      - без ограничений
    }
}
// Обозначения в Generics (буквы, параметры, заглавные)
// E - Element
// K - Key
// N - Number
// T - Type
// V - Value
// S, U, V etc. - 2nd, 3rd, 4th types

// Syntax to use generic collection: Class<Type> or Interface<Type>

// Параметризация:
// - подстановка вместо параметра конкретного значения при использовании generic
// - байт код параметризированных generic-ов - один байт-код на все варианты конкретных значений параметра

// Generic, T - параметр generic-a
class A<T> { // класс, чьи методы будут работать с типом данных T

    A<String> a = new A<String>(); // Параметризированный класс

    A a2 = new A(); // raw type - сырой тип (без параметра)

    public <T> A() {/*...*/}  // конструктор, работающий с типом данных T

    public <T> T m(T t) {/*...*/ return t;}// метод, c типом данных <T>, далее T - вернём из метода

}

// wildcard параметризованные типы нужны, чтобы задать ограничения сверху ии снизу
// ? extends <== extends wildcard - обязательно должен наследоваться от какого-то класса (нижняя граница)
// ? super   <== super wildcard - обязательно должен быть родителем какого-то класса (верхняя граница)
// ?         <== unbounded wildcard

// Generic класс:
class B<T> {/*...*/// Wildcard параметризированный класс
    B<?> b = new B<String>(); // будет далее вместо ? стоять String
    B<? extends Number> b1 = new B<Integer>();  // любой класс, наследуемый от Number
    B<? super Integer> b2 = new B<Number>();    // любый класс, являющимся родителем Integer (выше него)
}

// Ограничения по generic. Нельзя:
//  - создать объект этого типа (с вопросом)
//  - создать массив такого типа (можно только коллекции)
//  - использовать в секции catch
//  - использовать в статическом контексте
//  - использовать в instanceof (справа)
//  - наследовать





