# 9 лучших практик для обработки исключений в Java

Независимо от того, новичок вы или профессионал, всегда полезно освежить в памяти методы обработки исключений, чтобы 
убедиться, что вы и ваша команда можете справиться с проблемами.

Обработка исключений в Java - непростая тема. Новичкам сложно понять, и даже опытные разработчики могут часами 
обсуждать, как и какие исключения следует создавать или обрабатывать.

Вот почему у большинства команд разработчиков есть собственный набор правил их использования. И если вы новичок в 
команде, вас может удивить, насколько эти правила могут отличаться от тех, которые вы использовали раньше.

Тем не менее, есть несколько передовых практик, которые используются большинством команд. Вот 9 самых важных из них, 
которые помогут вам начать работу или улучшить обработку исключений.

## 1. Освободите ресурсы в блоке finally или используйте инструкцию "Try-With-Resource"

Довольно часто вы используете ресурс в своем блоке `try`, например `InputStream`, который вам нужно закрыть позже. 
Распространенной ошибкой в таких ситуациях является закрытие ресурса в конце блока `try`.

```java
public void doNotCloseResourceInTry() {
    FileInputStream inputStream = null;
    try {
        File file = new File("./tmp.txt");
        inputStream = new FileInputStream(file);

      // используем inputStream для чтения файла 
            
      // не делайте этого
        inputStream.close();
    } catch (FileNotFoundException e) {
        log.error(e);
    } catch (IOException e) {
        log.error(e);
    }
}
```

Проблема в том, что этот подход работает отлично до тех пор, пока не генерируется исключение. Все операторы в блоке 
`try` будут выполнены, и ресурс будет закрыт.

Но вы не зря добавили блок `try`. Вы вызываете один или несколько методов, которые могут вызвать исключение, или, может 
быть, вы сами вызываете исключение. Это означает, что вы можете не дойти до конца блока `try`. И как следствие, вы не закроете ресурсы.

Поэтому вам следует поместить весь код очистки в блок `finally` или использовать оператор `try-with-resource`.

### Используйте блок `Finally`

В отличие от последних нескольких строк вашего блока `try`, блок `finally` всегда выполняется. Это происходит либо 
после успешного выполнения блока `try`, либо после обработки исключения в блоке `catch`. Благодаря этому вы можете быть 
уверены, что освободите все захваченные ресурсы.

```java
public void closeResourceInFinally() {
    FileInputStream inputStream = null;
    try {
        File file = new File("./tmp.txt");
        inputStream = new FileInputStream(file);

        // используем inputStream для чтения файла

    } catch (FileNotFoundException e) {
        log.error(e);
    } finally {
        if (inputStream != null) {
            try {
                inputStream.close();
            } catch (IOException e) {
                log.error(e);
            }
        }
    }
}
```

### Оператор Java 7 "Try-With-Resource"

Другой вариант - это оператор `try-with-resource`.

Вы можете использовать его, если ваш ресурс реализует интерфейс `AutoCloseable`. Это то, что делает большинство 
стандартных ресурсов Java. Когда вы открываете ресурс в предложении `try`, он автоматически закрывается после выполнения 
блока `try` или обработки исключения.

```java
public void automaticallyCloseResource() {
    File file = new File("./tmp.txt");
    try (FileInputStream inputStream = new FileInputStream(file);) {
        // используем inputStream для чтения файла

    } catch (FileNotFoundException e) {
        log.error(e);
    } catch (IOException e) {
        log.error(e);
    }
}
```

## 2. Конкретные исключения предпочтительнее

Чем конкретнее исключение, которое вы генерируете, тем лучше. Всегда помните, что коллеге, который не знает вашего 
кода, а может быть, и вам через несколько месяцев, необходимо вызвать ваш метод и обработать исключение.

Поэтому постарайтесь предоставить им как можно больше информации. Это упрощает понимание вашего API. В результате 
вызывающий ваш метод сможет лучше обработать исключение или избежать его с помощью дополнительной проверки.

Поэтому всегда старайтесь найти класс, который лучше всего подходит для вашего исключительного события, например, 
генерируйте `NumberFormatException` вместо `IllegalArgumentException`. И избегайте создания неспецифического исключения.

```java
public void doNotDoThis() throws Exception {
    ...
}

public void doThis() throws NumberFormatException {
    ...
}
```

## 3. Документируйте определенные вами исключения

Каждый раз, когда вы определяете исключение в сигнатуре вашего метода, вы также должны задокументировать его в своем 
_Javadoc_. Это преследует ту же цель, что и предыдущая передовая практика: предоставить вызывающему как можно больше 
информации, чтобы он мог избежать или обработать исключение.

Итак, не забудьте добавить объявление `@throws `в свой _Javadoc_ и описать ситуации, которые могут вызвать исключение.

```java
/**
 * Этот метод делает что-то чрезвычайно полезное ...
 *
 * @param input
 * @throws MyBusinessException, если ... происходит
 */
public void doSomething(String input) throws MyBusinessException {
    ...
}
```

## 4. Генерирование исключений с описательными сообщениями

Идея, лежащая в основе этой передовой практики, аналогична двум предыдущим. Но на этот раз вы не предоставляете 
информацию вызывающей стороне вашего метода. Сообщение об исключении читают все, кто должен понимать, что произошло, 
когда исключение было зарегистрировано в файле журнала или в вашем инструменте мониторинга.

Следовательно, он должен как можно точнее описать проблему и предоставить наиболее актуальную информацию для понимания 
исключительного события.

Не поймите меня неправильно; вы не должны писать абзац текста. Но вам следует объяснить причину исключения в 1-2 
коротких предложениях. Это помогает вашей группе эксплуатации понять серьезность проблемы, а также упрощает анализ 
любых инцидентов, связанных с обслуживанием.

Если вы выберете конкретное исключение, его имя класса, скорее всего, уже будет описывать тип ошибки. Таким образом, 
вам не нужно предоставлять много дополнительной информации. Хорошим примером этого является `NumberFormatException`. 
Оно вызывается конструктором класса `java.lang.Long`, когда вы предоставляете `String` в неправильном формате.

```java
try {
    new Long("xyz");
} catch (NumberFormatException e) {
    log.error(e);
}
```

Название класса `NumberFormatException` уже говорит вам о типе проблемы. Его сообщение должно содержать только строку 
ввода, которая вызвала проблему. Если имя класса исключения не так выразительно, вам необходимо предоставить 
необходимую информацию в сообщении.

```bash
17:17:26,386 ERROR TestExceptionHandling:52 - java.lang.NumberFormatException: For input string: "xyz"
```

## 5. Сначала перехватите наиболее конкретное исключение

Большинство IDE помогут вам в этой лучшей практике. Они сообщают о недостижимом блоке кода, когда вы сначала пытаетесь 
перехватить менее конкретное исключение.

Проблема в том, что выполняется только первый блок `catch`, соответствующий исключению. Итак, если вы сначала поймаете 
`IllegalArgumentException`, вы никогда не достигнете блока `catch`, который должен обрабатывать более конкретное 
`NumberFormatException`, потому что это подкласс `IllegalArgumentException`.

Всегда сначала перехватывайте наиболее конкретный класс исключения и добавляйте менее конкретные блоки перехвата в 
конец вашего списка.

Пример такого оператора `try-catch` представлен в следующем фрагменте кода. Первый блок `catch` обрабатывает все 
`NumberFormatException`, а второй - все `IllegalArgumentException`, которые не являются `NumberFormatException`.

```java
public void catchMostSpecificExceptionFirst() {
    try {
        doSomething("Сообщение");
    } catch (NumberFormatException e) {
        log.error(e);
    } catch (IllegalArgumentException e) {
        log.error(e);
    }
}
```

## 6. Не перехватывайте Throwable

`Throwable` - это суперкласс всех исключений и ошибок. Вы можете использовать его в предложении `catch`, но никогда не 
должны этого делать!

Если вы используете `Throwable` в предложении `catch`, он не только перехватит все исключения; он также перехватит все 
ошибки. JVM выдает ошибки, чтобы указать на серьезные проблемы, которые не предназначены для обработки приложением. 
Типичными примерами этого являются `OutOfMemoryError` или `StackOverflowError`. И то, и другое вызвано ситуациями, 
которые находятся вне контроля приложения и не могут быть обработаны.

Итак, лучше не перехватывайте `Throwable`, если вы не абсолютно уверены, что находитесь в исключительной ситуации, в 
которой вы можете или обязаны обрабатывать ошибку.

```java
public void doNotCatchThrowable() {
    try {
        // делает что-нибудь
    } catch (Throwable t) {
        // не делает этого!
    }
}
```

## 7. Не игнорируйте исключения

Вы когда-нибудь анализировали отчет об ошибке, в котором выполнялась только первая часть вашего сценария использования?

Часто это вызвано игнорируемым исключением. Разработчик, вероятно, был уверен, что оно никогда не будет вызвано, и 
добавил `блок` catch, который не обрабатывает и не регистрирует его. И когда вы найдете этот блок, вы, скорее всего, 
даже найдете один из известных комментариев «Этого никогда не будет».

```java
public void doNotIgnoreExceptions() {
    try {
        // делает что-нибудь
    } catch (NumberFormatException e) {
        // это никогда не выполнится
    }
}
```

Что ж, возможно, вы анализируете проблему, в которой произошло невозможное.

Поэтому, пожалуйста, никогда не игнорируйте исключения. Вы не знаете, как код изменится в будущем. Кто-то может удалить 
проверку, которая предотвратила исключительное событие, не осознавая, что это создает проблему. Или код, который 
генерирует исключение, изменяется и теперь генерирует несколько исключений одного и того же класса, а вызывающий код не 
предотвращает их все.

Вы должны хотя бы написать сообщение в журнале, сообщающее всем, что произошло немыслимое и что кто-то должен это 
проверить.

```java
public void logAnException() {
    try {
        // делает что-нибудь
    } catch (NumberFormatException e) {
        log.error("Это никогда не должно происходить: " + e);
    }
}
```

## 8. Не пишите в лог сгенерированные исключения

Это, вероятно, наиболее часто игнорируемая передовая практика в списке. Вы можете найти множество фрагментов кода и 
даже библиотек, в которых исключение перехватывается, регистрируется и повторно генерируется.

```java
try {
    new Long("xyz");
} catch (NumberFormatException e) {
    log.error(e);
    throw e;
}
```

Может показаться интуитивно понятным регистрировать исключение, когда оно произошло, а затем повторно генерировать его, 
чтобы вызывающий мог обработать его соответствующим образом. Но, в таком случае, приложение будет писать в лог 
несколько сообщений об ошибках для одного и того же исключения.

```bash
17:44:28,945 ERROR TestExceptionHandling:65 - java.lang.NumberFormatException: For input string: "xyz"
Exception in thread "main" java.lang.NumberFormatException: For input string: "xyz"
at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
at java.lang.Long.parseLong(Long.java:589)
at java.lang.Long.(Long.java:965)
at com.stackify.example.TestExceptionHandling.logAndThrowException(TestExceptionHandling.java:63)
at com.stackify.example.TestExceptionHandling.main(TestExceptionHandling.java:58)
```

Повторные сообщения также не добавляют никакой информации. Как объясняется в лучшей практике №4, сообщение об 
исключении должно описывать исключительное событие. А трассировка стека сообщает вам, в каком классе, методе и строке 
было сгенерировано исключение.

Если вам нужно добавить дополнительную информацию, вы должны перехватить исключение и обернуть его в пользовательское. 
Но обязательно следуйте передовой практике номер 9.

```java
public void wrapException(String input) throws MyBusinessException {
    try {
        // делает что-нибудь
    } catch (NumberFormatException e) {
        throw new MyBusinessException("Сообщение с описанием ошибки.", e);
    }
}
```

Итак, перехватывайте исключение, только если вы хотите его обработать. В противном случае укажите это в сигнатуре 
метода и позвольте вызывающей стороне позаботиться об этом.


## 9. Оберните исключение, не обрабатывая его

Иногда лучше поймать стандартное исключение и превратить его в настраиваемое. Типичным примером такого исключения 
является бизнес-исключение для конкретного приложения или платформы. Это позволяет вам добавлять дополнительную 
информацию, а также вы можете реализовать специальную обработку для вашего класса исключения.

Когда вы это сделаете, обязательно установите исходное исключение в качестве причины. Класс `Exception` предоставляет 
определенные методы конструктора, которые принимают `Throwable` в качестве параметра. В противном случае вы потеряете 
трассировку стека и сообщение об исходном исключении, что затруднит анализ исключительного события, вызвавшего ваше 
исключение.

```java
public void wrapException(String input) throws MyBusinessException {
    try {
        // делает что-нибудь
    } catch (NumberFormatException e) {
        throw new MyBusinessException("Сообщение с описанием ошибки.", e);
    }
}
```

## Резюме

Как вы видели, есть много разных вещей, которые вы должны учитывать, когда генерируете или перехватываете исключение. 
Большинство из них имеют цель улучшить читаемость вашего кода или удобство использования вашего API.

Чаще всего исключения являются одновременно механизмом обработки ошибок и средством связи. Поэтому вам следует 
обязательно обсудить передовые практики и правила, которые вы хотите применять, со своими коллегами, чтобы все 
понимали общие концепции и использовали их одинаково.
