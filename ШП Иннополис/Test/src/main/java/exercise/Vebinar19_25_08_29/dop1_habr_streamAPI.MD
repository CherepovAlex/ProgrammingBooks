# Руководство по Java 8 Stream API

## 1. Обзор

В этом руководстве рассматривается практическое использование _Java 8 Streams_ от создания до параллельного выполнения.

Чтобы понять этот материал, читателям необходимо иметь базовые знания о _Java 8_ (лямбда-выражения, _Optional_, ссылки
на методы).

## 2. Создание потока

В Java существует множество способов создания экземпляра потока (_Stream_) из различных источников данных.

После создания экземпляра потока, он _не изменяет_ исходный источник данных.
Это означает, что любые операции, выполняемые над потоком (например, фильтрация, маппинг, сортировка), не влияют на сам
исходный набор данных.
Это обеспечивает _безопасность_ данных и предотвращает нежелательные побочные эффекты.

Благодаря тому, что потоки не модифицируют исходные данные, из одного и того же источника можно создать несколько
потоков. Это позволяет одновременно выполнять различные операции обработки данных над одним и тем же набором данных без
изменения исходных данных.

### 2.1. Пустой поток

Мы должны использовать метод `empty()` для создания пустого потока:

```java
Stream<String> streamEmpty = Stream.empty();
```

Мы часто используем метод `empty()` при создании, чтобы избежать возврата `null` для потоков без элементов:

```java
public Stream<String> streamOf(List<String> list) {
    return list == null || list.isEmpty() ? Stream.empty() : list.stream();
}
```

### 2.2. Поток коллекции

Мы также можем создать поток из любого типа _Collection_ (`Collection`, `List`, `Set`):

```java
Collection<String> collection = Arrays.asList("a", "b", "c");
Stream<String> streamOfCollection = collection.stream();
```

### 2.3. Поток массива

Массив также может быть источником потока:

```java
Stream<String> streamOfArray = Stream.of("a", "b", "c");
```

Мы также можем создать stream из существующего массива или части массива:

```java
String[] arr = new String[]{"a", "b", "c"};
Stream<String> streamOfArrayFull = Arrays.stream(arr);
Stream<String> streamOfArrayPart = Arrays.stream(arr, 1, 3); // "b" "c"
```

### 2.4. Stream.builder()

Желаемый тип должен быть дополнительно указан в правой части инструкции.
Когда используется _builder_, в противном случае метод `build()` создаст экземпляр `Stream<Object>`:

```java
Stream<String> streamBuilder =
        Stream.<String>builder().add("a").add("b").add("c").build();
```

### 2.5. Stream.generate()

Метод `generate()` принимает `Supplier<T>` для генерации элемента.
Поскольку результирующий поток бесконечен, разработчик должен указать желаемый размер, иначе метод `generate()` будет
работать до тех пор, пока не достигнет предела памяти:

```java
Stream<String> streamGenerated = Stream.generate(() -> "element").limit(10);
```

Приведенный выше код создает последовательность из десяти строк со значением "_element_".

### 2.6. Stream.iterate()

Другой способ создания бесконечного потока - это использование метода `iterate()`:

```java
Stream<Integer> streamIterated = Stream.iterate(40, n -> n + 2).limit(20);
```

Первый элемент результирующего stream является первым параметром метода `iterate()`. При создании каждого следующего
элемента указанная функция применяется к предыдущему элементу. В приведенном выше примере _вторым_ элементом будет `42`.

### 2.7. Поток примитивов

Java 8 предлагает возможность создавать потоки из трех примитивных типов: `int`, `long` и `double`. Поскольку
` Stream<T>`
является _универсальным_ интерфейсом, и нет способа использовать примитивы в качестве параметра типа с _generics_, были
созданы три новых специальных интерфейса: `IntStream`, `LongStream`, `DoubleStream`.

Использование новых интерфейсов _устраняет_ ненужную автоматическую упауовку, что позволяет повысить производительность

```java
IntStream intStream = IntStream.range(1, 3);
LongStream longStream = LongStream.rangeClosed(1, 3);
```

Метод `range(int startInclusive, int endExclusive)` создает упорядоченный поток от первого параметра ко второму
параметру.
Оно увеличивает значение последующих элементов с шагом, равным 1. Результат _не включает_ последний параметр, это просто
верхняя граница последовательности.

Метод `rangeClosed(int startInclusive, int endInclusive)` выполняет то же самое, только с одним отличием, _включен_
второй
элемент. Мы можем использовать эти два метода для генерации любого из трех типов потоков примитивов.

Начиная с Java 8, класс `Random` предоставляет широкий спектр методов для генерации потоков примитивов. Например,
следующий код создает `DoubleStream`, который состоит из трех элементов:

```java
Random random = new Random();
DoubleStream doubleStream = random.doubles(3);
```

### 2.8. Поток строк

Мы также можем использовать `String` в качестве источника для создания потока с помощью метода `chars()` класса
`String`.
Поскольку в JDK нет интерфейса для `CharStream`, мы используем `IntStream` вместо этого для представления потока
символов.

```java
IntStream streamOfChars = "abc".chars();
```

Следующий пример _разбивает_ строку на подстроки в соответствии с указанным регулярным выражением:

```java
Stream<String> streamOfString = Pattern.compile(", ").splitAsStream("a, b, c");
```

### 2.9. Поток файлов

Кроме того, Java NIO класс _Files_ позволяет нам генерировать `Stream<String>` текстового файла с помощью метода
`lines()`.
Каждая строка текста становится элементом потока:

```java
Path path = Paths.get("C:\file.txt");
Stream<String> streamOfStrings = Files.lines(path);
Stream<String> streamWithCharset = Files.lines(path, Charset.forName("UTF-8"));
```

Кодировка может быть указана в качестве аргумента метода `lines()`.

## 3. Ссылка на поток

Мы можем создать экземпляр потока и иметь _доступную_ ссылку на него, если вызываются только _промежуточные_ операции.
Выполнение _терминальной_ операции делает поток _недоступным_.

Чтобы продемонстрировать это, мы ненадолго забудем, что наилучшей практикой является объединение последовательности
операций в цепочку. Помимо ненужной многословности, технически следующий код допустим:

```java
Stream<String> stream = Stream.of("a", "b", "c").filter(element -> element.contains("b"));
Optional<String> anyElement = stream.findAny();
```

Однако попытка повторно использовать ту же ссылку после вызова операции терминала вызовет исключение
`IllegalStateException`:

```java
Optional<String> firstElement = stream.findFirst();
```

Поскольку исключение `IllegalStateException` является исключением `RuntimeException`, компилятор не будет
_сигнализировать_ о
проблеме. Поэтому очень важно помнить, что **потоки Java 8 нельзя использовать повторно**.

Такое поведение _логично_. Мы разработали _streams_ для применения _конечной_ последовательности операций к источнику
элементов в функциональном стиле, а не для хранения элементов.

Итак, чтобы предыдущий код работал _должным образом_, необходимо внести некоторые изменения:

```java
List<String> elements = Stream.of("a", "b", "c")
        .filter(element -> element.contains("b"))
        .collect(Collectors.toList());
Optional<String> anyElement = elements.stream().findAny();
Optional<String> firstElement = elements.stream().findFirst();
```

## 4. Потоковый конвейер

Для выполнения последовательности операций над элементами источника данных и агрегирования их результатов нам
понадобятся три части:

+ исходный код
+ промежуточные операции
+ терминальная операция.

_Промежуточные_ операции возвращают _новый измененный поток_. Например, чтобы создать новый поток вместо существующего
без
нескольких элементов, следует использовать метод skip():

```java
Stream<String> onceModifiedStream = Stream.of("abcd", "bbcd", "cbcd").skip(1);
```

Если нам нужно _больше одной_ модификации, мы можем связать промежуточные операции.
Давайте предположим, что нам также нужно заменить каждый элемент текущего `Stream<String>` подстрокой из первых
нескольких символов.
Мы можем сделать это, объединив методы `skip()` и `map()`:

```java
Stream<String> twiceModifiedStream = stream.skip(1).map(element -> element.substring(0, 3));
```

Поток **сам по себе ничего не стоит**; пользователя интересует _результат_ операции терминала, который может быть значением
некоторого типа или действием, применяемым к каждому элементу потока. 
Мы можем использовать только _одну терминальную операцию_ для каждого потока.

Правильный и наиболее удобный способ использования потоков - это конвейер потока, который представляет собой цепочку из
источника потока, промежуточных операций и терминальной операции:

```java
List<String> list = Arrays.asList("abc1", "abc2", "abc3");
long size = list.stream().skip(1)
        .map(element -> element.substring(0, 3)).sorted().count();
```

## 5. Отложенный вызов

Промежуточные операции являются ленивыми. Это означает, что они будут вызываться только в том случае, если это необходимо для выполнения терминальной операции.

Например, давайте вызовем метод wasCalled(), который увеличивает внутренний счетчик при каждом вызове:






































