https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/ClassLoader.html

Модуль java.base
Пакет java.lang

# Class загрузчик классов

`java.lang.Объект
    java.lang.ClassLoader`

**Прямые Известные Подклассы:**

`SecureClassLoader`

`public abstract class ClassLoader extends Object`

Загрузчик классов — это объект, отвечающий за загрузку классов. 
Класс `ClassLoader` является абстрактным классом. 
Получив двоичное имя класса, загрузчик классов должен попытаться найти или сгенерировать данные, составляющие определение класса. 
Типичная стратегия заключается в преобразовании имени в имя файла, а затем в чтении «файла класса» с таким именем из файловой системы.
Каждый `Class` объект содержит `reference` для `ClassLoader` который его определил.

`Class` Объекты классов массивов создаются не загрузчиками классов, а автоматически, как того требует среда выполнения Java. 
Загрузчик класса для класса массива, возвращаемый методом` Class.getClassLoader()`, совпадает с загрузчиком класса для типа его элемента; если тип элемента является примитивным, то у класса массива нет загрузчика класса.

Приложения реализуют подклассы `ClassLoader` для расширения возможностей динамической загрузки классов виртуальной машиной Java.

Менеджеры безопасности обычно используют загрузчики классов для обозначения доменов безопасности.

Помимо загрузки классов, загрузчик классов также отвечает за поиск ресурсов. 
Ресурс — это данные (например, файл «`.class`», данные конфигурации или изображение), которые идентифицируются с помощью абстрактного пути, разделённого символом «/». 
Ресурсы обычно поставляются вместе с приложением или библиотекой, чтобы их можно было найти с помощью кода в приложении или библиотеке. 
В некоторых случаях ресурсы включаются в состав других библиотек, чтобы их можно было найти с их помощью.

Класс `ClassLoader` использует модель делегирования для поиска классов и ресурсов. 
У каждого экземпляра `ClassLoader` есть связанный с ним родительский загрузчик классов. 
При запросе на поиск класса или ресурса экземпляр `ClassLoader` обычно делегирует поиск классу или ресурсу, связанному с его родительским загрузчиком классов, прежде чем пытаться найти класс или ресурс самостоятельно.

Загрузчики классов, поддерживающие _параллельную_ загрузку классов, называются поддерживающими параллельную загрузку загрузчиками классов. 
Они должны регистрироваться во время инициализации класса, вызывая метод `ClassLoader.registerAsParallelCapable`. 
Обратите внимание, что класс `ClassLoader` по умолчанию поддерживает параллельную загрузку. 
Однако его подклассы должны регистрироваться самостоятельно, если они поддерживают параллельную загрузку. 
В средах, где модель делегирования не является строго иерархической, загрузчики классов должны поддерживать параллельную обработку, иначе загрузка классов может привести к взаимоблокировкам, поскольку блокировка загрузчика удерживается на протяжении всего процесса загрузки класса (см. методы loadClass).

## Встроенные загрузчики классов во время выполнения

Среда выполнения Java имеет следующие встроенные загрузчики классов:

+ Загрузчик классов **Bootstrap**. 
Это встроенный загрузчик классов виртуальной машины, который обычно обозначается как `null` и не имеет родительского элемента.

+ Загрузчик классов **платформы**. 
Загрузчик классов платформы отвечает за загрузку классов платформы. 
Классы платформы включают в себя API платформы Java SE, классы их реализации и специфичные для JDK классы времени выполнения, которые определяются загрузчиком классов платформы или его предками. 
Загрузчик классов платформы может использоваться в качестве родительского для `ClassLoader` экземпляра.

Чтобы можно было обновлять/переопределять модули, привязанные к загрузчику классов платформы, и чтобы обновленные модули считывали модули, привязанные к загрузчикам классов, отличным от загрузчика классов платформы и его предков, загрузчику классов платформы может потребоваться делегировать полномочия другим загрузчикам классов, например загрузчику классов приложения. 
Другими словами, классы в именованных модулях, привязанных к загрузчикам классов, отличным от загрузчика классов платформы и его предков, могут быть видны загрузчику классов платформы.

+ Загрузчик **системных классов**. 
Он также известен как загрузчик **классов приложения** и отличается от загрузчика классов платформы. 
Загрузчик системных классов обычно используется для определения классов в пути к классам приложения, пути к модулям и в инструментах, специфичных для JDK. 
Загрузчик классов платформы является родительским или вышестоящим по отношению к загрузчику системных классов, поэтому загрузчик системных классов может загружать классы платформы, делегируя эту задачу своему родительскому элементу.

Обычно виртуальная машина Java загружает классы из локальной файловой системы в зависимости от платформы. 
Однако некоторые классы могут быть загружены не из файла, а из других источников, например из сети, или могут быть созданы приложением. 
Метод `defineClass` преобразует массив байтов в экземпляр класса `Class`. 
Экземпляры этого вновь определённого класса можно создать с помощью `Class.newInstance`.

Методы и конструкторы объектов, созданных загрузчиком классов, могут ссылаться на другие классы. 
Чтобы определить, на какой класс(ы) происходит ссылка, виртуальная машина Java вызывает `loadClass` метод загрузчика классов, который изначально создал этот класс.

Например, приложение может создать сетевой загрузчик классов для скачивания файлов классов с сервера. Пример кода может выглядеть следующим образом:

```java
ClassLoader loader = new NetworkClassLoader(host, port);
   Object main = loader.loadClass("Main", true).newInstance();
        . . .
```
Подкласс сетевого загрузчика классов должен определять методы `findClass` и `loadClassData` для загрузки класса из сети. 
После загрузки байтов, составляющих класс, следует использовать метод `defineClass` для создания экземпляра класса. Пример реализации:

```java
     class NetworkClassLoader extends ClassLoader {
         String host;
         int port;

         public Class findClass(String name) {
             byte[] b = loadClassData(name);
             return defineClass(name, b, 0, b.length);
         }

         private byte[] loadClassData(String name) {
             // load the class data from the connection
              . . .
         }
     }
 
```

## Двоичные имена

Любое имя класса, указанное в качестве параметра `String` для методов в `ClassLoader`, должно быть **двоичным именем**, как определено в Спецификации языка Java.

Примеры допустимых названий классов:

 "java.lang.String"
 "javax.swing.JSpinner$DefaultEditor"
 "java.security.KeyStore$Builder$FileBuilder$1"
 "java.net.URLClassLoader$3$1"
 
Любое имя пакета, указанное в качестве параметра `String` для методов в `ClassLoader`, должно быть либо **пустой строкой** (обозначающей безымянный пакет), либо **полным именем**, как определено в Спецификации языка Java.
