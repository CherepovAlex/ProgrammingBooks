# Загрузчики классов в Java

## 1. Введение

**Загрузчик классов** — это объект, отвечающий за загрузку классов. 
Кроме того, загрузчики классов **динамически загружают классы Java в JVM** (**виртуальную машину Java**) **во время выполнения**. 
Они также являются частью `JRE` (среды выполнения Java). 
Таким образом, благодаря загрузчикам классов `JVM` не нужно знать о базовых файлах или файловых системах для запуска программ на Java.

Кроме того, `JVM` загружает эти классы Java в память не сразу, а по мере необходимости для приложения. 
Здесь на сцену выходят загрузчики классов. Они отвечают за загрузку классов в память.

В этом обучающем материале мы поговорим о различных типах встроенных загрузчиков классов и о том, как они работают. 
Затем мы представим нашу собственную реализацию.

## 2. Каковы функции загрузчика классов?

У загрузчика классов есть две основные функции:

+ **Загрузка классов** — различные встроенные и пользовательские загрузчики классов загружают классы. 
Мы можем расширить абстрактный класс `java.lang.ClassLoader`, чтобы создать реализации загрузчиков классов.
+ **Поиск ресурсов** — ресурс — это какие-либо данные, например файл `.class`, информация о конфигурации или изображение. 
Обычно мы упаковываем ресурсы вместе с приложением или библиотекой, чтобы их было легко найти

Изначально загрузчики классов не создают объекты для классов массивов. 
Вместо этого среда выполнения Java создаёт их автоматически по мере необходимости. 
Поэтому, когда мы используем `Class#getClassLoader()` для поиска загрузчика класса массива, он возвращает загрузчик класса для типа его элемента. 
Соответственно, у класса массива нет загрузчика класса, если тип элемента является примитивным типом данных.

## 3. Типы встроенных загрузчиков классов

Среда выполнения Java поддерживает _три_ встроенных загрузчика классов:

+ **Bootstrap-загрузчик классов** — встроенный загрузчик классов виртуальной машины, представленный как `null`
+ **Загрузчик платформенных классов** — загружает платформенные классы, которые включают в себя API-интерфейсы платформы Java SE, классы их реализации и классы среды выполнения, специфичные для JDK. 
Загрузчик платформенных классов является родительским по отношению к системному загрузчику классов
+ **Системный загрузчик классов** — также известный как _загрузчик классов приложения_, загружает классы из пути к классам приложения, пути к модулям и инструментов, специфичных для JDK

### 3.1. Демонстрация

Давайте начнём с изучения того, _как_ можно загружать различные классы с помощью разных загрузчиков классов.

```java
public void printClassLoaders() throws ClassNotFoundException {

    System.out.println("Platform Classloader:" + ClassLoader.getPlatformClassLoader()); 

    System.out.println("System Classloader:" + ClassLoader.getSystemClassLoader());

    System.out.println("Classloader of this class:" + PrintClassLoader.class.getClassLoader());

    System.out.println("Classloader of DriverManager:" + DriverManager.class.getClassLoader());

    System.out.println("Classloader of ArrayList:" + ArrayList.class.getClassLoader());
}
```
При выполнении описанный выше метод выводит на экран:

    Platform Classloader:jdk.internal.loader.ClassLoaders$PlatformClassLoader@5674cd4d
    System Classloader:jdk.internal.loader.ClassLoaders$AppClassLoader@33909752
    Classloader of this class:jdk.internal.loader.ClassLoaders$AppClassLoader@33909752
    Classloader of DriverManager:jdk.internal.loader.ClassLoaders$PlatformClassLoader@5674cd4d
    Classloader of ArrayList:null

Как мы видим, здесь используются _три_ разных загрузчика классов: **bootstrap** (отображается как `null`), **platform** и **system**.

_Системный_ загрузчик классов загружает класс, содержащий метод `example`. 
**Давайте вспомним, что системный загрузчик классов загружает наши файлы в путь к классам.**

Затем загрузчик классов _платформы_ загружает класс _DriverManager_.

Наконец, загрузчик классов _начальной загрузки_ загружает класс `ArrayList`. 
Загрузчик классов начальной загрузки или первичный загрузчик классов является родительским для всех остальных; однако у него нет родительского элемента.

Однако мы видим, что для `ArrayList` в выводе отображается `null`. 
Это связано с тем, что загрузчик классов начальной загрузки написан на машинном коде, а не на Java, поэтому он не отображается как класс Java. 
В результате поведение загрузчика классов начальной загрузки будет отличаться в разных JVM.

Теперь давайте подробнее рассмотрим каждый из этих загрузчиков классов.

### 3.2. Загрузчик классов `Bootstrap`

Экземпляр `java.lang.ClassLoader` загружает классы Java. 
Однако загрузчики классов сами являются классами. 
Поэтому возникает вопрос: кто загружает сам `java.lang.ClassLoader`? 
Здесь в игру вступает _загрузочный_ или _первичный_ загрузчик классов. 
Он в основном отвечает за загрузку внутренних классов JDK, обычно `rt.jar`, и других основных библиотек, расположенных в каталоге `$JAVA_HOME/jre/lib`. 
Кроме того, **загрузчик классов `Bootstrap` служит родительским элементом для всех остальных экземпляров `ClassLoader`**.

**Этот загрузчик классов начальной загрузки является частью основной JVM и написан на машинном коде**, как указано в примере выше. 
На разных платформах этот загрузчик классов может быть реализован по-разному.

### 3.3. Платформенный загрузчик классов

Загрузчик классов платформы является дочерним элементом загрузчика классов начальной загрузки и отвечает за загрузку стандартных базовых классов Java, чтобы они были доступны всем приложениям, работающим на платформе.

### 3.4. Системный загрузчик классов

С другой стороны, системный загрузчик классов или загрузчик классов приложения отвечает за загрузку всех классов уровня приложения в JVM. 
**Он загружает файлы, указанные в переменной среды `classpath`, `-classpath`, или `-cp` в командной строке.** 
Он также является дочерним элементом платформенного загрузчика классов.

## 4. Как работают загрузчики классов?

Загрузчики классов являются _частью_ среды выполнения Java. 
Когда JVM запрашивает класс, загрузчик классов пытается найти его и загрузить определение класса в среду выполнения, используя полное имя класса. 
Метод `java.lang.ClassLoader.loadClass(String name, boolean resolve)` отвечает за загрузку определения класса в среду выполнения с использованием его двоичного имени. 
Этот метод является перегруженным; у него есть вариант `java.lang.ClassLoader.loadClass(String name)` с другими параметрами. 
Он выполняет упорядоченный поиск:

+ Он вызывает `findLoadedClass(String name)`, чтобы проверить, был ли класс уже загружен. 
Метод возвращает класс с заданным двоичным именем, если загрузчик уже загрузил этот класс. 
В противном случае он возвращает `null`.
+ Он вызывает метод `loadClass(String)` в загрузчике родительского класса. 
Далее он использует встроенный загрузчик классов виртуальной машины, если родительский класс равен `null`.
+ Для поиска класса вызывается метод `findClass(String)`.

В результате упорядоченного поиска, если класс не найден и при этом для флага `resolve` установлено значение `true`, вызывается метод `resolveClass(Class)` для полученного двоичного объекта `Class`.

Если в результате упорядоченного поиска класс не найден, возникает исключение `java.lang.ClassNotFoundException`.

Теперь давайте рассмотрим три важные особенности загрузчиков классов.

### 4.1. Модель делегирования

Модель делегирования означает, что класс `ClassLoader` делегирует поиск класса или ресурса своему родительскому загрузчику классов, прежде чем пытаться найти класс или ресурс самостоятельно. 
По умолчанию модель делегирования является иерархической. 
Класс `ClassLoader` поддерживает параллельную загрузку классов, то есть может работать в параллельном режиме. 
Загрузчики классов могут регистрироваться во время инициализации, если они поддерживают параллельную работу.

Загрузчики классов используют модель делегирования, **при которой при запросе на поиск класса или ресурса `ClassLoader` экземпляр делегирует поиск класса или ресурса родительскому загрузчику классов**.

Допустим, у нас есть запрос на загрузку класса приложения в JVM. 
Системный загрузчик классов сначала делегирует загрузку этого класса своему родительскому загрузчику классов платформы, который, в свою очередь, делегирует её загрузчику классов начальной загрузки.

Системный загрузчик классов пытается загрузить класс самостоятельно только в том случае, если загрузчик начальной загрузки, а затем и загрузчик классов платформы не смогли загрузить класс.

### 4.2. Уникальные классы

Благодаря модели делегирования легко обеспечить **уникальность классов**, **поскольку мы всегда стараемся делегировать полномочия вверх**.

Если загрузчик родительского класса не может найти класс, только тогда текущий экземпляр пытается сделать это самостоятельно.

### 4.3. Видимость

Кроме того, **загрузчики дочерних классов видны классам, загруженным загрузчиками родительских классов**.

Например, классы, загруженные системным загрузчиком классов, могут обращаться к классам, загруженным платформенным загрузчиком классов и загрузчиком классов начальной загрузки, но не наоборот.

Чтобы проиллюстрировать это, предположим, что _класс A_ загружается загрузчиком классов приложения, а _класс B_ — загрузчиком классов платформы. 
Тогда классы A и B будут видны другим классам, загруженным загрузчиком классов приложения.

Однако класс B — единственный класс, видимый для других классов, загруженных загрузчиком классов платформы.

## 5. Пользовательский ClassLoader

В большинстве случаев, когда файлы уже находятся в файловой системе, достаточно встроенного загрузчика классов.

Однако в случаях, когда нам нужно загрузить классы с локального жёсткого диска или из сети, нам может потребоваться использовать пользовательские загрузчики классов.

В этом разделе мы рассмотрим другие варианты использования пользовательских загрузчиков классов и покажем, как их создавать.

### 5.1. Примеры использования пользовательских загрузчиков классов

Пользовательские загрузчики классов полезны не только для загрузки классов во время выполнения программы. Вот несколько примеров их использования:

+ Помощь в модификации существующего байт-кода, например с помощью агентов
+ Создание классов, динамически адаптируемых к потребностям пользователя, например в JDBC, осуществляется за счёт динамической загрузки классов при переключении между различными реализациями драйверов.
+ Реализация механизма управления версиями классов при загрузке различных байт-кодов для классов с одинаковыми именами и пакетами. 
Это можно сделать с помощью загрузчика классов `URL` (загрузка jar-файлов по `URL`) или пользовательских загрузчиков классов.
Ниже приведены более конкретные примеры ситуаций, в которых могут пригодиться пользовательские загрузчики классов.

**Например, браузеры используют специальный загрузчик классов для загрузки исполняемого контента с веб-сайта.** 
Браузер может загружать апплеты с разных веб-страниц с помощью отдельных загрузчиков классов. 
Средство просмотра апплетов, которое используется для запуска апплетов, содержит загрузчик классов, который обращается к веб-сайту на удалённом сервере, а не к локальной файловой системе.

Затем он загружает необработанные файлы байт-кода по протоколу HTTP и преобразует их в классы внутри JVM. 
Даже если эти **апплеты имеют одинаковое имя, они считаются разными компонентами, если загружаются разными загрузчиками классов**.

Теперь, когда мы понимаем, почему пользовательские загрузчики классов так важны, давайте реализуем подкласс `ClassLoader`, чтобы расширить и обобщить функциональность загрузки классов в JVM.

### 5.2. Создание собственного загрузчика классов

Для наглядности предположим, что нам нужно загрузить классы из файла с помощью пользовательского загрузчика классов.

Нам нужно расширить класс `ClassLoader` и переопределить метод `findClass()`:

```java
public class CustomClassLoader extends ClassLoader {

    @Override
    public Class findClass(String name) throws ClassNotFoundException {
        byte[] b = loadClassFromFile(name);
        return defineClass(name, b, 0, b.length);
    }

    private byte[] loadClassFromFile(String fileName)  {
        InputStream inputStream = getClass().getClassLoader().getResourceAsStream(fileName.replace('.', File.separatorChar) + ".class");
        byte[] buffer;
        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
        int nextValue = 0;
        try {
            while ( (nextValue = inputStream.read()) != -1 ) {
                byteStream.write(nextValue);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        buffer = byteStream.toByteArray();
        return buffer;
    }
}
```

В приведённом выше примере мы определили собственный загрузчик классов, который расширяет стандартный загрузчик классов и загружает массив байтов из указанного файла.

## 6. Понимание java.lang.ClassLoader

Давайте рассмотрим несколько основных методов класса `java.lang.ClassLoader`, чтобы лучше понять, как он работает.

### 6.1. Метод loadClass()

Этот метод отвечает за загрузку класса с заданным параметром `name`. Параметр `name` указывает на полное имя класса:

    public Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {

Виртуальная машина Java вызывает метод `loadClass()` для разрешения ссылок на классы, устанавливая для параметра `resolve` значение `true`. 
Однако не всегда необходимо разрешать класс. 
Если нам нужно только определить, существует класс или нет, мы устанавливаем для параметра `resolve` значение `false`.

Этот метод служит точкой входа для загрузчика классов.

Реализация метода по умолчанию предполагает поиск классов в уже рассмотренном порядке.

### 6.2. Метод defineClass()

Этот метод отвечает за преобразование массива байтов в экземпляр класса. Прежде чем использовать класс, его нужно разрешить:

```java
protected final Class<?> defineClass(
  String name, byte[] b, int off, int len) throws ClassFormatError
```  

Если данные не содержат допустимый класс, возникает ошибка `ClassFormatError`.

Кроме того, мы не можем переопределить этот метод, так как он помечен как `final`.

### 6.3. Метод findClass()

Этот метод находит класс с полным именем, указанным в качестве параметра. 
Нам нужно переопределить этот метод в пользовательских реализациях загрузчика классов, которые используют модель делегирования для загрузки классов:

```java
protected Class<?> findClass(
  String name) throws ClassNotFoundException
```  

Кроме того, `loadClass()` вызывает этот метод, если загрузчик родительского класса не может найти запрошенный класс.

Реализация по умолчанию выдает `ClassNotFoundException`, если ни один из родительских классов загрузчика классов не находит класс.

### 6.4. Метод getParent()

Этот метод возвращает загрузчик родительского класса для делегирования.

```java
public final ClassLoader getParent()
```  

В некоторых реализациях, например в той, что была рассмотрена в разделе 4, для обозначения загрузчика классов начальной загрузки используется `null`.

### 6.5. Метод getResource()

Этот метод пытается найти ресурс с заданным именем.

    public URL getResource(String name)

Сначала запрос будет передан родительскому загрузчику классов для ресурса. 
Если родительский элемент равен `null`, выполняется поиск по пути загрузчика классов, встроенного в виртуальную машину.

Если это не поможет, метод вызовет `findResource(String)` для поиска ресурса. 
Имя ресурса, указанное в качестве входных данных, может быть относительным или абсолютным по отношению к пути к классам.

Он возвращает объект `URL` для чтения ресурса или значение `null`, если ресурс не найден или у вызывающей стороны нет достаточных прав для возврата ресурса.

Важно отметить, что Java загружает ресурсы из пути к классам.

Наконец, загрузка ресурсов в Java не зависит от местоположения, поскольку не имеет значения, где выполняется код, если среда настроена на поиск ресурсов.

### 7. Загрузчики контекстных классов

В целом, загрузчики контекстных классов представляют собой альтернативный метод делегирования загрузки классов, представленный в J2SE.

Как мы уже знаем, загрузчики классов в JVM следуют иерархической модели, согласно которой у каждого загрузчика классов есть только один родитель, за исключением загрузочного загрузчика классов.

Однако иногда, когда основным классам JVM требуется динамически загружать классы или ресурсы, предоставленные разработчиками приложений, могут возникать проблемы.

Например, в JNDI основная функциональность реализована в классах начальной загрузки `rt.jar`. 
Но эти классы JNDI могут загружать провайдеры JNDI, реализованные независимыми поставщиками (развёрнутыми в пути к классам приложения). 
В этом сценарии загрузчик классов начальной загрузки (родительский загрузчик классов) должен загрузить класс, видимый для загрузчика классов приложения (дочернего загрузчика классов).

Делегирование в J2SE здесь не работает, и, чтобы обойти эту проблему, нам нужно найти альтернативные способы загрузки классов. 
Этого можно добиться с помощью загрузчиков контекста потока.

В классе `java.lang.Thread` есть метод `getContextClassLoader()`, который возвращает `ContextClassLoader` для конкретного потока. 
`ContextClassLoader` предоставляется создателем потока при загрузке ресурсов и классов. 
Начиная с Java SE 9, потоки в общем пуле `fork/join` всегда возвращают системный загрузчик классов в качестве загрузчика классов контекста потока.

## 8. Заключение

Загрузчики классов необходимы для выполнения программы на Java. В этой статье мы подробно рассказали о них.

Мы обсудили различные типы загрузчиков классов, а именно загрузчики классов `Bootstrap`, `Platform` и `System`. 
`Bootstrap` является родительским для всех них и отвечает за загрузку _внутренних_ классов JDK. 
`Platform` и `System`, в свою очередь, загружают классы из _платформы_ Java и из пути к классам соответственно.

Мы также узнали, как работают загрузчики классов, и рассмотрели некоторые их функции, такие как _делегирование_, _видимость_ и _уникальность_. 
Затем мы вкратце объяснили, как создать собственный загрузчик классов. Наконец, мы познакомили вас с контекстными загрузчиками классов.
