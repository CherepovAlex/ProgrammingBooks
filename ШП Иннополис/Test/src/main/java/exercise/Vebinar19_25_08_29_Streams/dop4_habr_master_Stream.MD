# Мастерство работы с Java Stream

В этой статье мы постараемся подробно рассмотреть **Java Stream**. Без долгих предисловий сразу приступим к делу. 
Для начала возьмём знакомый класс _Student_. Представим, что у нас есть группа студентов:

```java
@Getter
@AllArgsConstructor
public static class Student {
    private String name;
    private Integer age;
}

List<Student> students = Lists.newArrayList(
    new Student("Bob", 18),
    new Student("Ted", 17),
    new Student("Zeka", 19));
```

Задача следующая:

_Необходимо вернуть студентов в возрасте 18 лет и старше из заданного списка, отсортированных по убыванию возраста, 
не более двух человек._

В коде на Java7 и более ранних версий мы реализуем это следующим образом:

```java
public List<Student> getTwoOldestStudents(List<Student> students) {
    List<Student> result = new ArrayList<>();
    // 1. Цикл для определения возраста студентов, сначала отфильтровываем студентов, соответствующих критериям возраста
    for (Student student : students) {
      if (student.getAge() >= 18) {
        result.add(student);
      }
    }
    // 2. Сортируем список подходящих студентов по возрасту
    result.sort((s1, s2) -> s2.getAge() - s1.getAge());
    // 3. Проверяем размер результата. Если он больше 2, обрезаем подсписок до первых двух записей и возвращаем его.
    if (result.size() > 2) {
      result = result.subList(0, 2);
    }
    return result;
}
```

В Java 8 и более поздних версиях с использованием Stream код можно написать более элегантно:

```java
public List<Student> getTwoOldestStudentsByStream(List<Student> students) {
        return students.stream()
                .filter(s -> s.getAge() >= 18)
                .sorted((s1, s2) -> s2.getAge() - s1.getAge())
                .limit(2)
                .collect(Collectors.toList());
    }
```

Различия между двумя подходами:

С точки зрения функционального подхода, реализация процедурного кода связывает элементы коллекции, итерации цикла и 
различные логические проверки, раскрывая чрезмерное количество деталей. По мере усложнения требований процедурный код 
становится сложным для понимания и поддержки.

Функциональный подход отделяет детали реализации от бизнес-логики. Подобно SQL-запросам, он описывает, _что_ нужно
сделать, а не _как_ это сделать, что позволяет программистам сосредоточиться на бизнес-логике и создавать более чистый,
понятный и легко поддерживаемый код.

Опираясь на свой повседневный опыт разработки, я составил подробное резюме основных моментов, сложных аспектов
использования, типичных сценариев и других важных аспектов работы со Stream. Надеюсь, это поможет вам лучше понять
Stream и применять его в разработке проектов более эффективно.

## Первое знакомство со Stream

В Java 8 был добавлен функционал Stream, который позволяет пользователям работать с такими структурами данных, как 
List и Collection в функциональном и более простом стиле, а также использовать параллельные вычисления без явного 
участия пользователя.

Говоря вкратце, выполнение вычислений с помощью Stream включает составление _конвейера потока_. Конвейер потока состоит
из следующих трёх частей:

1. **Создание Stream**: создаётся из исходных данных, которыми могут быть массивы, коллекции, функции-генераторы, каналы 
ввода-вывода и др.

2. **Промежуточные операции**: их может быть ноль или более, они преобразуют поток в новый поток, например, 
`filter(Predicate)`.

3. **Терминальная операция**: возвращает результат или побочный эффект, например, `count()` или `forEach(Consumer)`

Следующая диаграмма иллюстрирует эти процессы:

![img.png](img.png)

Каждому типу операций в конвейере потока соответствует несколько методов API. Давайте для начала перечислим функции 
каждого метода API.

**1. Начало конвейера**

Этап отвечает за создание нового потока (Stream) напрямую или на основе существующих объектов типа массивов, _List_, 
_Set_, _Map_ и других коллекций.

| **API**          | **Описание**                                                                            |
|:-----------------|:----------------------------------------------------------------------------------------|
| stream()         | Создаёт новый объект последовательного потока                                           |
| parallelStream() | Создаёт объект потока, который может выполняться параллельно                            |
| Stream.of()      | Создаёт новый объект последовательного потока из заданной последовательности элементов  |

Помимо обычного Stream, который является потоком ссылок на объекты, существуют примитивные специализации: _IntStream_, 
_LongStream_ и _DoubleStream_. Все они называются «потоками» и соответствуют описанным здесь характеристикам и 
ограничениям.

**2. Промежуточный конвейер**

Этот этап отвечает за обработку потока и возвращение нового объекта Stream. Операции промежуточного конвейера могут 
накладываться друг на друга.

| **API**    | **Описание**                                                                                                                                                                            |
|:-----------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| filter()   | Фильтрует элементы, которые соответствуют критериям, и возвращает новый поток                                                                                                           |
| sorted()   | Возвращает новый поток, отсортировав все элементы потока в соответствии с заданными правилами                                                                                           |
| skip()     | Пропускает указанное количество элементов в начале коллекции и возвращает новый поток                                                                                                   |
| distinct() | Убирает дубликаты из потока и возвращает новый поток                                                                                                                                    |
| limit()    | Сохраняет указанное количество элементов в начале коллекции и возвращает новый поток                                                                                                    |
| concat()   | Объединяет данные из двух потоков в новый поток и возвращает его                                                                                                                        |
| peek()     | Обходит и обрабатывает каждый элемент потока по одному и возвращает обработанный поток                                                                                                  |
| map()      | Преобразует существующий элемент в объект другого типа (один-к-одному) и возвращает новый поток                                                                                         |
| flatMap()  | Преобразует существующие элементы в объекты другого типа (один-ко-многим), то есть один элемент может быть преобразован в один или несколько новых элементов, и возвращает новый поток  |

**3. Завершение конвейера**

Как следует из названия, после завершения операции конвеера поток заканчивается. На этом этапе могут быть выполнены 
логические операции или возвращены данные с результатами выполнения, в зависимости от требований.


| **API**     | **Описание**                                                                                                                              |
|:------------|:------------------------------------------------------------------------------------------------------------------------------------------|
| findFirst() | Обработка потока завершается, когда найден первый элемент, соответствующий критериям                                                      |
| findAny()   | Завершает обработку потока, когда найден любой элемент, соответствующий условиям                                                          |
| anyMatch()  | Возвращает логическое значение (boolean), аналогичное isContains(), используется для проверки наличия элементов, соответствующих условиям |
| allMatch()  | Возвращает логическое значение, используется для проверки, соответствуют ли все элементы условиям                                         |
| noneMatch() | Возвращает логическое значение, используется для проверки, не соответствует ли ни один элемент условиям                                   |
| min()       | Возвращает минимальное значение после обработки потока                                                                                    |
| max()       | Возвращает максимальное значение после обработки потока                                                                                   |
| count()     | Возвращает итоговое количество элементов после обработки потока                                                                           |
| collect()   | Преобразует поток в указанный тип, используя Collectors                                                                                   |
| toArray()   | Преобразует поток в массив                                                                                                                |
| iterator()  | Преобразует поток в объект типа Iterator                                                                                                  |
| forEach()   | Не возвращает значение, обходит элементы по одному и выполняет заданную логику обработки                                                  |

## Stream API: Детальное использование

**1. Создание Stream**

```java
//Stream.of, IntStream.of...
Stream nameStream = Stream.of("Bob", "Ted", "Zeka");
IntStream ageStream = IntStream.of(18, 17, 19);

//stream, parallelStream
Stream studentStream = students.stream();
Stream studentParallelStream = students.parallelStream();
```

**2. Промежуточные операции**

**2.1 map**

`map` и `flatMap` используются для преобразования существующих элементов в элементы других типов. Различие между ними:
+ `map` предполагает преобразование «один-к-одному», то есть каждый элемент может быть преобразован только в один новый
элемент.
+ `flatMap` допускает преобразование «один-ко-многим», то есть каждый элемент может быть преобразован в один или 
несколько новых элементов.

![img_1.png](img_1.png)

Рассмотрим метод `map`. Текущая задача:

_Преобразовать предыдущий список объектов студентов в список их имён и вывести результат_:

```java
/**
     * Использование map: один-к-одному   
     * @param students
     * @return
     */
    public List<String> objectToString(List<Student> students) {
        return students.stream()
                .map(Student::getName)
                .collect(Collectors.toList());
    }
```

Вывод:

`[Bob, Ted, Zeka]`

Как видно, на входе три объекта `Student`, а на выходе три имени студентов.

**2.2 flatMap**

Теперь давайте расширим задачу.

В соответствии с правилами школы каждый учащийся должен присоединиться к какой-либо команде. Допустим:
+ Боб, Тед и Зека присоединяются к баскетбольной команде.
+ Алан, Энн и Дэвис присоединяются к футбольной команде.

```java
@Getter
@AllArgsConstructor
public static class Team {
    private String type;
    private List<Student> students;
}

List<Student> basketballStudents = Lists.newArrayList(
                new Student("Bob", 18),
                new Student("Ted", 17),
                new Student("Zeka", 19));

List<Student> footballStudent = Lists.newArrayList(
                new Student("Alan", 19),
                new Student("Anne", 21),
                new Student("Davis", 21));

Team basketballTeam = new Team("basketball", basketballStudents);
Team footballTeam = new Team("football", footballStudent);
List<Team> teams = Lists.newArrayList(basketballTeam, footballTeam);    // Объект Lists зависит от com.google.common.collect
```

Теперь нужно посчитать всех учащихся во всех командах и вернуть их в объединённом списке. Как это можно реализовать?

Попробуем использовать метод `map`:

```java
List<List<Student>> allStudents = teams.stream()
    .map(Team::getStudents)
    .collect(Collectors.toList());
```

Мы видим, что если это не удаётся, возвращаемый тип результата — `List<List>`, тогда как нам нужен именно `List`.

Тем не менее, в Java 7 и более ранних версиях мы могли бы легко решить эту задачу следующим образом:

```java
List<Student> allStudents = new ArrayList<>();
for (Team team : teams) {
    for (Student student : team.getStudents()) {
      allStudents.add(student);
    }
}
```

Однако код с двумя вложенными циклами выглядит неэлегантно. В этом случае на помощь приходит метод `flatMap`

```java
List<Student> allStudents = teams.stream()
    .flatMap(t -> t.getStudents().stream())
    .collect(Collectors.toList());
```

Разве это не круто? Всё реализуется в одну строку кода. Метод `flatMap` принимает лямбда-функцию. Возвращаемое значение
этой функции должно быть типа Stream. В итоге метод `flatMap` объединяет все возвращаемые потоки, создавая новый Stream,
чего метод `map` сделать не может.

Следующая диаграмма наглядно иллюстрирует логику обработки метода `flatMap`:

![img_2.png](img_2.png)

**2.3 filter, distinct, sorted, limit**





































